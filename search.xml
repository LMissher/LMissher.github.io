<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2017 Latin America I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAmeIImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 给一幅联通图，$q$次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int tot,cnt,head[M],f[M];ll ans;struct edge&#123; int v,next;ll w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v;ll w; edge1()&#123;&#125; edge1 (int u1,int v1,ll w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; tot=ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int sz[M],dep[M],fat[M],son[M],rnk[M],id[M],top[M];ll val[M];void dfs(int u,int fa,int d)&#123; sz[u]=1;dep[u]=d;son[u]=-1,fat[u]=fa; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; val[v]=w; dfs(v,u,d+1); sz[u]+=v; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fat[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=val[rnk[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;ll query(int x,int y)&#123; int fx=top[x],fy=top[y];ll res=0; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; res=max(res,seg.query(id[fx],id[x],1,n,1)); x=fat[fx],fx=top[x]; &#125; else&#123; res=max(res,seg.query(id[fy],id[y],1,n,1)); y=fat[fy],fy=top[y]; &#125; &#125; if(x==y) return res; if(dep[x]&gt;dep[y]) res=max(res,seg.query(id[son[y]],id[x],1,n,1)); else res=max(res,seg.query(id[son[x]],id[y],1,n,1)); return res;&#125;void solve()&#123; dfs(1,-1,0);dfs1(1,1);seg.build(1,n,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%lld\n",ans); else&#123; printf("%lld\n",ans-query(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%lld",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Moscow Subregional C Carpet]]></title>
    <url>%2F2019%2F03%2F29%2F2017MoscowSubregionalCCarpet%2F</url>
    <content type="text"><![CDATA[2017 Moscow Subregional C Carpethttps://vjudge.net/contest/260542#problem/C 给一个 $1000000 \times 20$ 的格子图，要求找一种方式把一颗不超过 $100000$ 个节点的树放到格子图里，并且没有边交叉。考虑把树剖分，因为不超过对数条数的链，所以依次把重链放到一列中，轻链放到下一列即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;int n;int cnt,head[M];int sz[M],f[M],son[M],x[M],y[M],tmp[M];struct edge&#123; int v,next;&#125;e[M&lt;&lt;1];void init()&#123; cnt=0;memset(head,-1,sizeof(head));memset(tmp,0,sizeof(tmp));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=1,f[u]=fa,son[u]=-1; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int z)&#123; y[u]=z;x[u]=++tmp[z]; if(son[u]==-1) return; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,z+1); &#125; dfs1(son[u],z); return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1);dfs1(1,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n", x[i],y[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5242]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5242%2F</url>
    <content type="text"><![CDATA[hdu 5242 Gamehttp://acm.hdu.edu.cn/showproblem.php?pid=5242 给一棵点权树，问从根节点出发$k$次最多能获得多少能量。同一个点的能量只能获取一次。每次从根节点出发肯定要走到叶子节点才是最优的选择。而且每次都要走的是上一次走完后的能量最多的路径。很容易想到按点权把树剖分成轻重链。每一条链都是从叶子到某个节点的，所以当重链被选择后，最重的轻链便成了重链，所以只要把剖分出的前 $k$ 条链的能量相加即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;int _,n,k,cas=1;int cnt,head[M],tot;struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];int son[M],f[M];ll sz[M],a[M],tmp[M],ans[M];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=a[u];son[u]=-1;f[u]=fa; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); if(sz[v]&gt;sz[son[u]]||son[u]==-1)&#123; sz[u]=sz[u]-sz[son[u]]+sz[v]; son[u]=v; &#125; &#125;&#125;void dfs1(int u,ll w)&#123; tmp[u]=a[u]+w; if(son[u]==-1)&#123; ans[++tot]=tmp[u]; return ; &#125; dfs1(son[u],tmp[u]); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,0); &#125; return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1); // for(int i=1;i&lt;=n;i++) printf("%d %d\n",f[i],son[i]); dfs1(1,0); ll res=0; printf("Case #%d: ",cas++); if(k&gt;tot)&#123; for(int i=1;i&lt;=tot;i++) res+=ans[i]; printf("%lld\n",res); &#125; else&#123; sort(ans+1,ans+1+tot); for(int i=tot;i&gt;tot-k;i--) res+=ans[i]; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wannafly day1 I]]></title>
    <url>%2F2019%2F03%2F29%2Fwannafly-day1-I%2F</url>
    <content type="text"><![CDATA[wannafly_day1_I.cpphttp://newoj.acmclub.cn/contests/1389/problem/8 给一棵树，给出 $m$ 次染色，问每个点的第 $k$ 次染色是什么颜色。倒着做，用线段树维护区间染色的最大次数，如果有 $k - 1$次的区间存在，就找到那个点把它的颜色更新，并把它的染色次数变为 $-inf$。复杂度 $O(nlog(n)^2)$，注意下 $update$ 的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 1e5+7;const int inf = 2147483647;int n,m,k;int tot,cnt,head[M];int sz[M],f[M],son[M],dep[M],rnk[M],top[M],id[M];int lazy[M&lt;&lt;2],mx[M&lt;&lt;2],ans[M];struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));memset(ans,0,sizeof(ans));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int d)&#123; sz[u]=1,f[u]=fa,son[u]=-1,dep[u]=d; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u,d+1); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return ; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]);&#125;void pushdown(int rt,int l,int r)&#123; if(lazy[rt]&gt;0)&#123; int v=lazy[rt]; lazy[rt]=0; mx[r]+=v;lazy[r]+=v; mx[l]+=v;lazy[l]+=v; &#125; return ;&#125;void build(int l,int r,int rt)&#123; mx[rt]=0;lazy[rt]=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int l,int r,int rt,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(mx[rt]==k-1)&#123; if(l==r)&#123; mx[rt]=-inf,ans[rnk[l]]=v,lazy[rt]=0; &#125; else&#123; pushdown(up); int mid=(l+r)&gt;&gt;1; if(mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); &#125; &#125; else mx[rt]++,lazy[rt]++; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(R&gt;mid&amp;&amp;mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); return ;&#125;void query(int x,int y,int v)&#123; int fx=top[x],fy=top[y]; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; update(id[fx],id[x],1,n,1,v); x=f[fx],fx=top[x]; &#125; else&#123; update(id[fy],id[y],1,n,1,v); y=f[fy],fy=top[y]; &#125; &#125; if(dep[x]&gt;dep[y]) update(id[y],id[x],1,n,1,v); else update(id[x],id[y],1,n,1,v);&#125;int qu[M],qv[M],qc[M];int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); init(); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); build(1,n,1); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1,1); dfs1(1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;qu[i],&amp;qv[i],&amp;qc[i]); &#125; for(int i=m;i&gt;=1;i--)&#123; query(qu[i],qv[i],qc[i]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin Ame I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-IImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 倍增找两点与$LCA$路径上的最大边权。给一幅联通图，$q$ 次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int ans,cnt,head[M],f[M];int fa[M][26],mx[M][26],dep[M];struct edge&#123; int v,next,w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v,w; edge1()&#123;&#125; edge1 (int u1,int v1,int w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); memset(dep,0,sizeof(dep));memset(fa,0,sizeof(fa));memset(mx,0,sizeof(mx)); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,int w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void dfs(int u,int depth)&#123; dep[u]=depth; int j=1; while ((1&lt;&lt;j)&lt;depth)&#123; fa[u][j]=fa[fa[u][j-1]][j-1]; mx[u][j]=max(mx[u][j-1],mx[fa[u][j-1]][j-1]); j++; &#125; for (int i=head[u];~i;i=e[i].next) if (dep[e[i].v]==0)&#123; int v=e[i].v; fa[v][0]=u;mx[v][0]=e[i].w; dfs(v,depth+1); &#125;&#125;void up(int &amp;u,int step,int &amp;res)&#123; for (int i=0;i&lt;=20;i++) if (step&amp;(1&lt;&lt;i)) &#123; res=max(mx[u][i],res); u=fa[u][i]; &#125; return ;&#125;int work(int u,int v)&#123; int res=0; if (dep[u]&lt;dep[v]) up(v,dep[v]-dep[u],res); else up(u,dep[u]-dep[v],res); for (int i=20;i&gt;=0;i--) if (fa[u][i]!=fa[v][i])&#123; res=max(res,max(mx[u][i],mx[v][i])); u=fa[u][i];v=fa[v][i]; &#125; if (u!=v) res=max(res,max(mx[u][0],mx[v][0])); return res;&#125;void solve()&#123; dfs(1,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%d\n",ans); else&#123; printf("%d\n",ans-work(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%d",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5950]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5950%2F</url>
    <content type="text"><![CDATA[hdu 5950 Recursive sequencehttp://acm.hdu.edu.cn/showproblem.php?pid=5950 $F_1=a,F_2=b。F_n=F_{n-1}+2\times F_{n-2}+n^4$。输入$n$，求$F_n$。用二项式定理把 $n^4$ 拆开，就是裸的矩阵快速幂了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 2147493647;int _;ll n,a,b;struct mat&#123; ll a[8][8]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;7;i++) a[i][i]=1; &#125; mat operator * (const mat &amp; t)const&#123; mat tmp; for(int i=0;i&lt;7;i++) for(int j=0;j&lt;7;j++) for(int k=0;k&lt;7;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=1ll,x.a[0][1]=2ll,x.a[0][2]=1ll,x.a[0][3]=4ll,x.a[0][4]=6ll,x.a[0][5]=4ll,x.a[0][6]=1ll; x.a[1][0]=1ll; x.a[2][2]=1ll,x.a[2][3]=4ll,x.a[2][4]=6ll,x.a[2][5]=4ll,x.a[2][6]=1ll; x.a[3][3]=1ll,x.a[3][4]=3ll,x.a[3][5]=3ll,x.a[3][6]=1ll; x.a[4][4]=1ll,x.a[4][5]=2ll,x.a[4][6]=1ll; x.a[5][5]=1ll,x.a[5][6]=1ll; x.a[6][6]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); if(n==1)&#123; printf("%lld\n",a); continue; &#125; if(n==2)&#123; printf("%lld\n",b); continue; &#125; mat y=matrix_pow(x,n-2ll); printf("%lld\n",((((((y.a[0][0]*b%mod+y.a[0][1]*a%mod)%mod+y.a[0][2]*16ll%mod)%mod+y.a[0][3]*8ll%mod)%mod+y.a[0][4]*4ll%mod)%mod+y.a[0][5]*2ll%mod)%mod+y.a[0][6])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2018程序设计竞赛G]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62018%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BG%2F</url>
    <content type="text"><![CDATA[湘潭大学2018程序设计竞赛Ghttps://www.nowcoder.com/acm/contest/105/G 给一个递推式，$F_i=F_{i-1}+F_{i-2}+i^3+i^2+i+1。F_1=1,F_0=0$。问$F_n$是多少。典型的用矩阵快速幂加速解决斐波那契递推式。$F_{i+1}=F_i+F_{i-1}+(i+1)^3+(i+1)^2+(i+1)+1=F_i+F_{i-1}+i^3+4 \times i^2+6 \times i+4$。构造一个$6$阶矩阵即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7ll; int _;ll n;struct mat&#123; ll a[7][7]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;6;i++) a[i][i]=1; &#125; mat operator * (const mat&amp; t)const&#123; mat tmp; for(int i=0;i&lt;6;i++) for(int j=0;j&lt;6;j++) for(int k=0;k&lt;6;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=x.a[0][1]=x.a[0][2]=1ll;x.a[0][3]=x.a[0][5]=4ll;x.a[0][4]=6ll; x.a[1][0]=1ll; x.a[2][2]=x.a[2][5]=1ll;x.a[2][3]=x.a[2][4]=3ll; x.a[3][3]=x.a[3][5]=1ll;x.a[3][4]=2ll; x.a[4][4]=x.a[4][5]=1ll; x.a[5][5]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld",&amp;n); mat y=matrix_pow(x,n-1ll); printf("%lld\n",((((y.a[0][0]+y.a[0][2])%mod+y.a[0][3])%mod+y.a[0][4])%mod+y.a[0][5])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Tsukuba H]]></title>
    <url>%2F2019%2F03%2F29%2F2017Tsukuba-H%2F</url>
    <content type="text"><![CDATA[2017Tsukuba Hhttps://vjudge.net/contest/259596#problem/G 有个人有两个课程，每个课程有很多个作业，每个作业有开始日期与截至日期。每天只能选择一个课程的一个作业做。问这个人最多与最少可以完成多少作业。最多的话贪心的去找到每天可以做的所有作业中截止日期最近的那个即可。最少的话将日期拆点表示日期只能用一次，一种作业与源点连接容量为 $1$，然后与日期一边 $[start,deadline]$ 连接容量为 $1$。另一种作业与汇点连接容量为 $1$，然后与日期另一边 $[start,deadline]$ 连接容量为 $1$。因为当日期只与一个种类作业连接或者没有作业连接时这一天都可以没作业做。相当于寻找一个最小的割集让图不连通也就是所有日期都最多只有一个种类的作业连接，找不到作业去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2010,inf=0x3f3f3f3f;int n,m,st[407],ed[407],st1[407],ed1[407],ans,ans1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;vector&lt;int&gt; s[407],s1[407];void init()&#123; while(!q.empty()) q.pop();ans=0;ans1=0; for(int i=1;i&lt;=401;i++) s[i].clear(),s1[i].clear();&#125;struct Dinic&#123; struct edge &#123; int from,to,cap,flow; &#125;; vector&lt;edge&gt;es; vector&lt;int&gt;G[maxn]; bool vis[maxn]; int dist[maxn]; int iter[maxn]; void init(int n)&#123; for(int i=0; i&lt;=n+10; i++) G[i].clear(); es.clear(); &#125; void addedge(int from,int to,int cap)&#123; es.push_back((edge)&#123; from,to,cap,0 &#125;); es.push_back((edge)&#123; to,from,0,0 &#125;); int x=es.size(); G[from].push_back(x-2); G[to].push_back(x-1); &#125; bool BFS(int s,int t)&#123; memset(vis,0,sizeof(vis)); queue &lt;int&gt; Q; vis[s]=1; dist[s]=0; Q.push(s); while(!Q.empty())&#123; int u=Q.front(); Q.pop(); for(int i=0; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; vis[e.to]=1; dist[e.to]=dist[u]+1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int u,int t,int f)&#123; if(u==t||f==0) return f; int flow=0,d; for(int &amp;i=iter[u]; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(dist[u]+1==dist[e.to]&amp;&amp;(d=DFS(e.to,t,min(f,e.cap-e.flow)))&gt;0)&#123; e.flow+=d; es[G[u][i]^1].flow-=d; flow+=d; f-=d; if(f==0) break; &#125; &#125; return flow; &#125; int Maxflow(int s,int t)&#123; int flow=0; while(BFS(s,t)) &#123; memset(iter,0,sizeof(iter)); int d=0; while(d=DFS(s,t,inf)) flow+=d; &#125; return flow; &#125;&#125;dinic;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init();dinic.init(1000+n); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;st[i],&amp;ed[i]); s[st[i]].push_back(ed[i]); &#125; for(int i=1;i&lt;=n-m;i++)&#123; scanf("%d%d",&amp;st1[i],&amp;ed1[i]); s1[st1[i]].push_back(ed1[i]); &#125; for(int i=1;i&lt;=400;i++)&#123; for(int j=0;j&lt;s[i].size();j++) q.push(s[i][j]); for(int j=0;j&lt;s1[i].size();j++) q.push(s1[i][j]); while(!q.empty())&#123; if(q.top()&lt;i) q.pop(); else&#123; q.pop(); ans++; break; &#125; &#125; &#125; printf("%d\n",ans); int s=0,t=800+n+1; for(int i=m+1;i&lt;=m+400;i++)&#123; dinic.addedge(i,i+400,1); &#125; for(int i=1;i&lt;=m;i++)&#123; dinic.addedge(s,i,1); for(int j=st[i];j&lt;=ed[i];j++) dinic.addedge(i,m+j,1); &#125; for(int i=1;i&lt;=n-m;i++)&#123; dinic.addedge(m+800+i,t,1); for(int j=st1[i];j&lt;=ed1[i];j++) dinic.addedge(m+400+j,m+800+i,1); &#125; printf("%d\n",dinic.Maxflow(s,t)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Daejeon E]]></title>
    <url>%2F2019%2F03%2F29%2F2017Daejeon-E%2F</url>
    <content type="text"><![CDATA[2017Daejeon E给出一个有 $n$ 个点 $m$ 条边的图，每条边有一个边权。问要使第 $i$ 条边成为图的最小生成树的一条边最少要删掉多少条边，求出每条边的对应答案的和。枚举边 $i$ ，找出那些边权小于 $i$ 的边权的边，这些边都是网络流里的边，然后以连接 $i$ 的两个点为源点和汇点跑网络流求最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000;const int MAXM = 4000;const int inf = 0x3f3f3f3f;struct edge&#123; int to,next,cap,flow;&#125;e[MAXM];int n,m;int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol=0;memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw=0)&#123; e[tol].to=v;e[tol].cap=w;e[tol].next=head[u]; e[tol].flow=0;head[u]=tol++; e[tol].to=u;e[tol].cap=rw;e[tol].next=head[v]; e[tol].flow=0;head[v]=tol++;&#125;int sap(int st,int ed,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u=st; pre[u]=-1; gap[0]=N; int ans=0; while(dep[st]&lt;N)&#123; if(u==ed)&#123; int Min=inf; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; if(Min&gt;e[i].cap-e[i].flow) Min=e[i].cap-e[i].flow; &#125; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; e[i].flow+=Min; e[i^1].flow-=Min; &#125; u=st; ans+=Min; continue; &#125; bool flag=false; int v; for(int i=cur[u];~i;i=e[i].next)&#123; v=e[i].to; if(e[i].cap-e[i].flow&amp;&amp;dep[v]+1==dep[u])&#123; flag=true; cur[u]=pre[v]=i; break; &#125; &#125; if(flag)&#123; u=v; continue; &#125; int Min=N; for(int i=head[u];~i;i=e[i].next)&#123; if(e[i].cap-e[i].flow&amp;&amp;dep[e[i].to]&lt;Min)&#123; Min=dep[e[i].to]; cur[u]=i; &#125; &#125; gap[dep[u]]--; if(!gap[dep[u]]) return ans; dep[u]=Min+1; gap[dep[u]]++; if(u!=st) u=e[pre[u]^1].to; &#125; return ans;&#125;struct E&#123; int u,v,w,fl; bool operator &lt; (const E &amp;k) const&#123; return w&lt;k.w; &#125;&#125;ee[1000];int tot=0;void solve()&#123; int ans=0; for(int i=1;i&lt;=tot;i++)&#123; init(); for(int j=1;j&lt;i;j++)&#123; if(ee[j].w&lt;ee[i].w)&#123; addedge(ee[j].u,ee[j].v,1); addedge(ee[j].v,ee[j].u,1); &#125; &#125; ans+=sap(ee[i].u,ee[i].v,n); &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ee[++tot].u=u;ee[tot].v=v;ee[tot].w=w;ee[tot].fl=0; &#125; sort(ee+1,ee+tot+1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017LatinAme F]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-F%2F</url>
    <content type="text"><![CDATA[2017LatinAme F Fundraisinghttps://vjudge.net/contest/259114#problem/F n个人有漂亮值、财富值以及钱财三个属性。当一个人的漂亮值比另一个人严格大，且财富值比那个人小的时候，这两个人会发生争吵。问怎样选择一个集合，使得集合里的人互不争吵且钱财之和最大。先将相同漂亮值财富值的人合并然后将人按照漂亮值排序。然后遍历所有的人找到财富值比它小的钱财最大的状态然后加上那个状态更新当前财富值。注意同样的漂亮值的人互不影响。最后看所有的财富值中最大的即是答案。注意离散化财富值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;struct node&#123; int b,f;ll d; node () &#123;&#125; node (int b1,int f1,ll d1)&#123; b=b1;f=f1;d=d1; &#125; bool operator &lt; (const node &amp; k)const &#123; if(b!=k.b) return b&lt;k.b; return f&lt;k.f; &#125;&#125;p[M];map&lt;node,ll&gt; mp;int n,tot,f[M];struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=0; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll v)&#123; if(l==r)&#123; if(v&gt;mx[rt]) mx[rt]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,v); else update(pos,rson,v); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;vector&lt;pair&lt;int,ll&gt; &gt; vec;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; mp.clear();tot=0;vec.clear(); for(int i=1;i&lt;=n;i++)&#123; int x,y;ll z; scanf("%d%d%lld",&amp;x,&amp;y,&amp;z); mp[node(x,y,0)]+=z; &#125; for(map&lt;node,ll&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; p[++tot].b=it-&gt;first.b;p[tot].f=it-&gt;first.f;p[tot].d=it-&gt;second; f[tot]=p[tot].f; &#125; sort(p+1,p+tot+1);int pre=0; sort(f+1,f+tot+1); int sz=unique(f+1,f+tot+1)-f-1; seg.build(0,sz,1); for(int i=1;i&lt;=tot;i++)&#123; if(p[i].b!=pre)&#123; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,0,sz,1,vec[i].second); &#125; vec.clear(); int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); pre=p[i].b; &#125; else&#123; int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); &#125; &#125; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,1,sz,1,vec[i].second); &#125; printf("%lld\n",seg.mx[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LYOI 2016 41]]></title>
    <url>%2F2019%2F03%2F29%2FLYOI2016-41%2F</url>
    <content type="text"><![CDATA[LYOI2016_41 一次函数https://lyoi.ac/problem/41 $n$ 个一次函数 $f_i(x) = k_i \times x + b_i$,有两个操作。第一个操作把指定一个二次函数的 $k$ 和 $b$ 改变。第二个操作给出区间 $[l,r]$ 以及 $x$ , 求 $f_r(f_{r-1}(…f_l(x)))$ 的值。根据推算得出对于一个区间的两个子区间 $l$ 与 $r$ ,$k_{rt} = k_l \times k_r$, $b_{rt} = k_r \times b_l + b_r$ 。用线段树维护 $k$ 与 $b$ ,询问的时候合并区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 2e5+7;typedef long long ll;const ll mod = 1e9+7;int n,q;ll a[M],c[M];char s[2];int ql,qr,qpos,tot;ll qx,qk,qb;struct Seg&#123; ll k[M&lt;&lt;3],b[M&lt;&lt;3]; void pushup(int rt,int l,int r)&#123; k[rt]=k[l]*k[r]%mod; b[rt]=(b[l]*k[r]%mod+b[r])%mod; &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; k[rt]=a[l],b[rt]=c[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll a,ll c)&#123; if(l==r)&#123; k[rt]=a,b[rt]=c; return ; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,a,c); else update(pos,rson,a,c); pushup(up); &#125; int query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return rt; &#125; int mid=(l+r)&gt;&gt;1,ll,rr,res; if(L&gt;mid)&#123; res=query(L,R,rson); return res; &#125; else if(R&lt;=mid)&#123; res=query(L,R,lson); return res; &#125; else&#123; ll=query(L,R,lson),rr=query(L,R,rson); pushup(++tot,ll,rr); return tot; &#125; &#125;&#125;seg;void solve()&#123; while(q--)&#123; scanf("%s",s); if(s[0]=='Q')&#123; tot=(M&lt;&lt;2)+1; scanf("%d%d%lld",&amp;ql,&amp;qr,&amp;qx); tot=seg.query(ql,qr,1,n,1); printf("%lld\n",(seg.k[tot]*qx%mod+seg.b[tot])%mod); &#125; else&#123; scanf("%d%lld%lld",&amp;qpos,&amp;qk,&amp;qb); seg.update(qpos,1,n,1,qk,qb); &#125; &#125;&#125;int main()&#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;q))&#123; for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;a[i],&amp;c[i]); seg.build(1,n,1); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nowcoder practice28 B]]></title>
    <url>%2F2019%2F03%2F29%2FNowcoder-practice28-B%2F</url>
    <content type="text"><![CDATA[Nowcoder_practice28_B 数据结构https://www.nowcoder.com/acm/contest/200/B $n$ 个数 $m$ 个操作。$1.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}$。$2.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}^{2}$。$3.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $\times x$。$4.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $+ x$。线段树模板题，维护一个加 $lazy$ 与一个乘 $lazy$ ,再维护两个答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int Nmax = 1e4+7;int n,q;ll a[Nmax];struct Seg&#123; ll sum[Nmax&lt;&lt;2],fsum[Nmax&lt;&lt;2],len[Nmax&lt;&lt;2],lazyadd[Nmax&lt;&lt;2],lazymul[Nmax&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; sum[rt]=sum[l]+sum[r]; fsum[rt]=fsum[l]+fsum[r]; &#125; void pushdown(int rt,int l,int r)&#123; if(lazymul[rt]!=1)&#123; ll v=lazymul[rt]; lazymul[rt]=1; sum[l]*=v;sum[r]*=v; fsum[l]*=(v*v);fsum[r]*=(v*v); lazymul[l]*=v;lazymul[r]*=v; lazyadd[l]*=v;lazyadd[r]*=v; &#125; if(lazyadd[rt])&#123; ll v=lazyadd[rt]; lazyadd[rt]=0; fsum[r]+=(2*sum[r]*v+v*v*len[r]);fsum[l]+=(2*sum[l]*v+v*v*len[l]); sum[r]+=(v*len[r]);sum[l]+=(v*len[l]); lazyadd[r]+=v;lazyadd[l]+=v; &#125; &#125; void build(int l,int r,int rt)&#123; sum[rt]=fsum[rt]=0;len[rt]=(ll)(r-l+1);lazyadd[rt]=0;lazymul[rt]=1; if(l==r)&#123; sum[rt]=a[l];fsum[rt]=a[l]*a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int L,int R,int l,int r,int rt,ll v,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==2)&#123; fsum[rt]+=(2*sum[rt]*v+v*v*len[rt]); sum[rt]+=(len[rt]*v); lazyadd[rt]+=v; &#125; else&#123; sum[rt]*=v;fsum[rt]*=(v*v); lazyadd[rt]*=v;lazymul[rt]*=v; &#125; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson,v,op); if(R&gt;mid) update(L,R,rson,v,op); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==1) return sum[rt]; else return fsum[rt]; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res+=query(L,R,lson,op); if(R&gt;mid) res+=query(L,R,rson,op); return res; &#125;&#125;seg;void solve()&#123; while(q--)&#123; int op,l,r;ll v; scanf("%d",&amp;op); if(op==1||op==2)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",seg.query(l,r,1,n,1,op)); &#125; else&#123; scanf("%d%d%lld",&amp;l,&amp;r,&amp;v); seg.update(l,r,1,n,1,v,op-2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); seg.build(1,n,1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[codeforces 1051Fhttp://codeforces.com/contest/1051/problem/F 给一副图，图中的边最多比点多 $20$ 条。给 $q$ 次询问，每次询问两点的最短路。随便弄一个生成树，然后求出两点在树上的距离。把非树边的两端点保存然后求分别求一次最短路。然后以所有非树边端点的最短距离更新即可。 wannafly_day1_Jhttp://newoj.acmclub.cn/contests/1389/problem/9 改成了边比点多100条，不过所有边的距离都是1，把非树边抽出来跑一下bfs求互相的最短距离。和cf1051F差不多。 wannafly_day3_Ihttps://www.nowcoder.com/acm/contest/203/I 多源最短路。在一幅无向图中给出点集，问点集中的每个点到其他点的最短距离是多少。把点集里的点都做为源点，每个点都再增加一个祖先属性，表示这个点被哪个源点的最短路所更新。然后跑一次多源最短路即可。 2017Tsukuba_Fhttps://vjudge.net/contest/259357#problem/F 问一幅有向图中每条边如果反向会让图中点1到点2的最短距离变大变小还是不变。先求出点1到各个点的最短距离与边反向之后点2到各个点的最短距离。如果变小的话就是 $dis_{1to} + dis_{2from} + w &lt; dis$ 。变大的话就是上述等式变成大于符号，但因为最短路可能有多条，所以只有这条边还是最短路无向图里的桥时才会让最短距离变大。上述两个情况都不满足的话，最短距离不变。 codeforces 1076Dhttp://codeforces.com/contest/1076/problem/D 最短路生成树$+dfs$给 $n$ 个点 $m$ 条边，找出一个边集不超过 $k$ 条边使得距离节点 $1$ 的距离是最短距离的点最多，输出这个边集首先将 $1$ 节点跑最短路建出最短路生成树，然后再在生成树上 $dfs$ 出一个 $k$ 条边的边集 2018SEERC Chttp://codeforces.com/gym/101964/problem/C 给出一棵树，这棵树由黑白点组成。选出一个黑点点集，点集中点数小于给定的k，找出所有可能的黑点点集里直径最小的那个并输出直径。考虑枚举所有的黑点点对，求出点对的距离，当有黑点满足离点对两点距离都小于等于点对距离时就可以将点加入。数形结合，可以理解为这些点在两个圆的相交部分，所以最大距离必是点对距离。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>spfa</tag>
        <tag>bfs</tag>
        <tag>Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git+hexo搭建]]></title>
    <url>%2F2019%2F03%2F29%2Fgit-hexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建所需环境首先需要 $git+node.js$。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
