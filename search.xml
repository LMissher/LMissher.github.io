<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[蒟蒻ACM退役贴&&总结]]></title>
    <url>%2F2019%2F03%2F31%2Fjuruo%2F</url>
    <content type="text"><![CDATA[我来过，未征服。我走了，还有千千万个我。 收获 学会写代码 2018 ACM-ICPC 焦作区域赛铜牌 2018 ACM-ICPC EC-Final铜牌 2018 CCPC 吉林区域赛铜牌 2018 ACM-ICPC 西安邀请赛铜牌 2019 CCCC天梯赛 华山论剑团队国二 2019 CCCC天梯赛 华山论剑学校北京市特等奖 2018 CCCC天梯赛 华山论剑团队国二 CCFCSP认证 单次前1.7% 学校在XCPC拿银 CCFCSP 350分|总排名前1% 某桥杯进一次国赛 天梯赛 200分 初识第一次参加宣讲会与新生赛&emsp;&emsp;初入大学的我参加的第一次宣讲会就是学院社团招新的宣讲会，在这一次宣讲会上成功加入了心心念念已久的足球队。但是有一个新鲜事物映入了我的眼帘–“ACM爱好者协会”。还很懵懂的我听见斌哥在台上讲着协会的历史，不知怎的有一种中二的热血感。当听到迄今为止协会最好成绩还只是铜牌的，什么都还不懂的我暗暗自语道一定要拿一块银牌，想必当时所有的人都是这种感觉吧^_^。宣讲的最后斌哥的那句暂不招新可以说是营造了十足的神秘感，超级炫酷！但好像这次宣讲会之后ACM就从生活中消失了，就买了几本书带着看，自己也没有去刷题啊什么的。&emsp;&emsp;可能从A协11月正式的宣讲会以及随之而来的新生赛，我才算正式开始了自己的算法竞赛生涯吧。新生赛的题感觉很友好的，那时的我都能做出几道题并拿到二等奖，虽然被很多人踩，还是很开心，毕竟是大学生活的第一个奖。梦想便从这时启航~ 寒假集训&amp;&amp;问题求解与编程&amp;&amp;暑假集训 寒假集训&emsp;&emsp;只记得第一天是教使用STL，第二天好像我就溜了，思乡心切xxx。可能这就是蒟蒻吧。 问题求解与编程&emsp;&emsp;这是一门大一下的专选课，任课老师是A协教练徐老师，自己也没想到以后还会和徐老师有更多交集。这个课让我学会了贪心、分治、搜索、dp。还熟悉了oj的使用，简直爽的飞起。也是从这学期开始自己开始买各种书看，刷一些很水很水的题，打一些其他学校的校赛，虽然好像打了两场校赛都爆零了给幼小的心灵造成严重的打击。不过却让自己认识到了自己的蒟蒻水平。也是在这学期坚定了要转专业的决心(只是院内转)。 暑假集训&emsp;&emsp;暑假集训其实才算真正的入门吧，在此之前不过是在学习C语言与C++罢了。集训的时间很长，长到自己只有二十天的暑假，长到自己感觉机房是自己的家，不过还好有LJY同学的陪伴，这就是一路上有你吧。&emsp;&emsp;每天惯例是上午讲算法，下午一场CF或专题赛。这样日复一日的生活看起来会很枯燥，但其实每天都过的很幸福很充实，因为每天都可以学到新的东西，可能这就是算法的魅力吧。最短路、线段树、KMP等等算法都是在集训中学到的，虽然距离学会还有很远的路要走。(这些算法现在已经是新生大一寒假的集训内容了，还是偏简单的那种)。后来多校合练开始了，自闭的噩梦也开始了，每天下午只能做出一两道题，这都是些什么题啊，也太难了吧，这可能是我第一次多校的唯一记忆。&emsp;&emsp;现在记得的事也不太多了，只记得博哥趁中午休息的时候从公司带了很多雪糕来分发给我们，当时就觉得协会也太暖了吧！！还有自己A掉了一道看起来比较难的最短路(还不是正解的那种)以及十分钟AK掉了线段树专场，导致我旻被我奇骂了好久出原题hhhh。&emsp;&emsp;不出所料的自己被选入了最后的集训队，一想到自己以后可以代表学校去参数了就超级超级兴奋！！！！！选拔结束的当天晚上一群人去聚餐了，认识了之前一起在机房待了一个月却不认识的很多人(属实自闭男孩)。 相守第二次参加宣讲会与新生赛&emsp;&emsp;大二上的时候稀里糊涂的就成了协会的副会长，开始翘课学算法、熬夜打比赛、熬夜刷题，基本所有时间都花在算法上了吧，进步还是挺大的。但其实现在想来学习和算法应该是可以兼顾的吧。第二次参加宣讲会，我校诞生了第一枚金牌(跨过了银牌。我也不再是在台下的那个人，我负责给新生讲解新生赛的规则。而这次新生赛我也不再是做题人而是成了出题人，见证了大一两个OI爷的神仙打架，其中一个每次训练都踩我们这些大二的学长学姐，没想到的是最后我们成了队友。 组队&amp;&amp;寒假训练&emsp;&emsp;按照学校惯例会在寒假之前进行三人组队并在寒假进行队伍合练，本蒟蒻和两个OI爷组了队，成了本队最蒻的人。寒假本来该去给大一的新生们讲算法的，但是因为320过于舒适，便咕咕咕。这次集训zn开了算法专题训练，不过很多东西我都是第一次做，做的很吃力，产生了厌学情绪，很多东西都没有认真做没用认真学，集训一周之后就回家了，定好的学习计划也都没有完成，算是废掉的一个寒假。可惜时间不能重来，现在想想真是后悔。 第一次参加某桥杯&amp;&amp;天梯赛&amp;&amp;邀请赛&emsp;&emsp;新的一学期一开学就是蓝桥杯和天梯赛，作为萌新即将要参加人生中的正式比赛特别兴奋，但却没有因此而好好刷题。大概因为那时我在学算法而且觉得没必要对桥杯和天梯赛刷题，这两个比赛又不是很难。事实证明确实不是很难，自己却打得不好，桥杯只拿了省三，大概集训队都是省二吧？天梯赛虽然在本校十个人中排名第三，但170+的分不算太高。事实证明算法竞赛是不能懈怠的，当你在现役时松懈下来那么码力和思维都会下降的特别快。受到打击之后开始认真学习以前没有吃透的算法，一遍一遍写着模板题，一遍一遍看着算法实现，直到自己完全理解，直到滚瓜烂熟。打基础的过程是不能省略的，否则便不能对一个算法融会贯通。此时觉得自己好像很强了，但再次遭遇打击，邀请赛信心满满要拿个银牌，结果却是铜首铩羽而归。因而整个人还失落了几天，便再次认识到自己的不足，会的东西还是太少了，不应该只拘泥于自己负责的那一小模块所有的算法都应该有掌握才行！ 总结&emsp;&emsp;大二是很重要的一年，基本上成型就应该是在这一年了，不应该有丝毫的怠惰。对于算法的学习也应该是成体系的，而不是杂乱的学习单个的算法，刷书应该是最明智的做法，先刷掉一两本书建立一个良好的知识体系，再查漏补缺学习书中没有但是会用到的算法。而后才是刷自己负责部分的专题，每周的cf、wannafly挑战赛、EOJ月赛等等都要做，碰到自己不会的知识才好强化学习。最重要的是每周一次的三人一机合练，培养默契与配合。另外cf的c、d、e都是可以刷掉的。 结局暑期训练&emsp;&emsp;一个暑假我的身边全是它，它伴我从南到北。两个多校合练，一个wannafly-camp，共27场比赛，近300道高质量题。区域赛中甚至出现了其中的原题。当时的我好像每一场比赛都认真打完并把力所能及的题都补完。多校一定得打、camp一定得参加、题一定得补！少了一步都不行。回学校之后便开始猛刷数据结构，虽然好像这是大多数强校大一新生都能完成得事情，不过两周做了一百多道平均码量100+行得题还是很有成就感的！ 网络赛在每年现场赛之前都会有网络赛选拔出最后的而参赛学校，网络赛&emsp;=&emsp;有没有区域赛打。第一场网络赛我校被教育的明明白白，决定着三场CCPC参数资格的CCPC网络赛我们并没有打进去而且名次还很低。幸好申请到了名额，不然莫得比赛打了。接着是南京、焦作、徐州、青岛、北京的网络赛。南京、焦作都成功入围，北京虽然没打进去但也申请到了一个名额。我记得我焦作原题场好像C了，南京也还行吧。网络赛就是原题满天飞的比赛，只要你题做的够多，你就够强(逃。 吉林&emsp;&emsp;线段树没调出来，就差一点。卒。 南京&emsp;&emsp;网络流被一个trick点坑了，全队全场在演，打铁而归。 焦作&emsp;&emsp;bfs愣是头铁写dij，差点就铁了(雾。 西安&emsp;&emsp;全程很轻松，不上不下。 某桥&amp;&amp;CSP&amp;&amp;天梯&emsp;&emsp;第二年打桥杯以为能拿省一的结果还是被安排了，CSP打的也不符预期，天梯赛中规中矩吧。对于这三个比赛只有一句话，当你和对手实力差距不大时，最大的敌人是粗心和你自己。 食堂排名 南航说第二没人敢说第一 河南理工胜在物美价廉餐券还多 北工大超级nice就是饭太少了 北华大学记不太清了，中规中矩吧 西瓜大的饭最差，没有之一 技能树 就这些吧，退役蒟蒻准备ky了！每周要用半天学习算法和做题！]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+uWsgi+Django部署网站到linux服务器]]></title>
    <url>%2F2019%2F03%2F31%2FNginx-uWsgi-Django%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E5%88%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[准备工作：安装Mysql和Python3.x注意事项：安装之前，我们需要给默认的Python2.7安装pymysql+Django库，因为后面会出错就是因为未安装这两个库！12pip install pymysql==0.7.10pip install django==1.10.6 安装虚拟环境：提示：因Python3+自带虚拟环境，更简单好用，所以没必要再装一个。在home目录下创建名称为vcmt的虚拟环境。1python3.6 -m venv /home/vcmt 激活虚拟环境：1source /home/vcmt/bin/activate 退出命令：1deactivate 安装Python扩展库：第一步，在已配置好的机器上使用：1pip freeze &gt; requirements.txt 第二步，把生成的requirements.txt文件复制到目标机器上的root目录下。第三步，在目标机器上执行pip install -r requirements.txt，读取文件requirements.txt中的扩展库信息并在本机进行安装。 上传项目到服务器：把Django项目上传到服务器上。 注意：上传项目文件后把 /项目名/app名/migrations/ 下的类似00.. 的记录文件删除，有几个删除几个，但是不要删除别的文件。 修改settings.py文件：123456789101112DEBUG = FalseALLOWED_HOSTS = ['*']STATIC_ROOT = os.path.join(BASE_DIR, 'static')MEDIA_ROOT = os.path.join(BASE_DIR, 'media')STATIC_URL = '/static/' 配置Django项目：安装好Django等必须库后，进入Django项目下，同步并创建数据库，执行：12python manage.py makemigrationspython manage.py migrate 建立后台超级用户：1python manage.py createsuperuser 启动自带的服务器，测试是否可以正常运行！（此时settings.py 中的DEBUG = False）输入：1python manage.py runserver 0.0.0.0:8000 同步静态文件：1python manage.py collectstatic 配置uWsgi：在Django项目主目录下创建uwsgi.ini文件：12345678910111213141516171819202122232425262728293031[uwsgi]# 项目目录chdir=/root/biomass/# 指定项目的applicationmodule=biomass.wsgi:application# 进程个数workers=5pidfile=/root/biomass/script/uwsgi.pid# 指定IP端口#http=:9090# 指定静态文件static-map=/static=/root/biomass/static# 启动uwsgi的用户名和用户组uid=rootgid=root# 启用主进程master=true# 自动移除unix Socket和pid文件当服务停止的时候vacuum=true# 序列化接受的内容，如果可能的话thunder-lock=true# 启用线程enable-threads=true# 设置自中断时间harakiri=30# 设置缓冲post-buffering=4096# 设置日志目录daemonize=/root/biomass/script/uwsgi.log# 指定sock的文件路径socket=127.0.0.1:9090 1234567$ uwsgi --ini uwsgi.ini # 启动uwsgi配置[uwsgi-static] added mapping for /static =&gt; /home/trunk/static # 启动成功$ uwsgi --stop uwsgi.pid # 关闭uwsgisignal_pidfile()/kill(): Operation not permitted [core/uwsgi.c line 1659]$ uwsgi --reload uwsgi.pid #重新加载配置 Nginx配置：Nginx常用命令：123456789$ /etc/init.d/nginx start #启动$ /etc/init.d/nginx stop #关闭$ /etc/init.d/nginx restart #重启$ killall nginx #杀死所有nginx$ nginx -t #检查配置文件是否有错# 如果是生产环境的话Nginx正在运行，就不要直接stop start 或者 restart 直接reload就行了# 对线上影响最低$ /etc/init.d/nginx reload 创建一个xxx.conf配置文件（nginx的默认配置目录为/etc/nginx/conf.d）：1234567891011121314151617181920212223242526server &#123; # 这个server标识我要配置了 listen 80; # 80 是http默认的端口， 443 是https默认的端口（网页一般使用这两个端口） server_name 39.105.157.191 ; # 你访问的路径前面的url名称 access_log /var/log/nginx/access.log; # Nginx日志配置 error_log /var/log/nginx/error.log; # Nginx错误日志配置 charset utf-8; # Nginx编码 gzip on; # 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多 gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; # 支持压缩的类型 error_page 404 /404.html; # 错误页面 error_page 500 502 503 504 /50x.html; # 错误页面 # 指定项目路径uwsgi location / &#123; # 这个location就和咱们Django的url(r'^admin/', admin.site.urls), include /etc/nginx/uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的 uwsgi_connect_timeout 30; # 设置连接uWSGI超时时间 # 指定uwsgi的sock文件所有动态请求就会直接丢给他 uwsgi_pass 127.0.0.1:9090; &#125; # 指定静态文件路径 # location /static/ &#123; # alias /root/biomass/static/; # index index.html index.htm; #&#125;&#125; 启动uWsgi后再启动Nginx即可]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[网络流swust P1736 飞行员配对方案问题题目链接：https://www.oj.swust.edu.cn/problem/show/1736 题意有两种飞行员，一种可以和另一种的几个飞行员配对，求最大匹配。 题解二分图最大匹配问题。 在二分图的基础上增加源$S$和汇$T$，一种飞行员为$X$集合，另一种为$Y$集合。$1$、$S$向$X$集合中每个顶点连一条容量为$1$的有向边。$2$、$Y$集合中每个顶点向$T$连一条容量为$1$的有向边。$3$、$XY$集合之间的边都设为从$A$集合中的点到B集合之中的点，容量为$1$的有向边。求网络最大流，流量就是匹配数，所有满流边是一组可行解。(匈牙利写起来更方便) swust P1737 太空飞行计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1737 题意有 $n$ 个实验，每个实验有收入 $x_{i}$ ，而且实验会使用 $m_i$ 个仪器。每个仪器会有 $y_i$支出。问实施哪些实验并配置哪些仪器使收入最大。 题解最大权闭合图问题，可以转化成最小割问题，进而用最大流解决。 把每个实验看作二分图 $X$ 集合中的顶点，每个设备看作二分图 $Y$ 集合中的顶点，增加源 $S$ 和汇 $T$。1、从 $S$ 向每个 $X_i$ 连接一条容量为该点收入的有向边。2、从 $Y_i$ 向 $T$ 连接一条容量为该点支出的有向边。3、如果一个实验 $i$ 需要设备 $j$ ，连接一条从 $X_i$ 到 $Y_j$ 容量为无穷大的有向边。 统计出所有实验的收入之和$Total$，求网络最大流$Maxflow$，最大收益就是$Total - Maxflow$。对应的解就是最小割划分出的 $S$ 集合中的点，也就是最后一次增广找到阻塞流时能从 S 访问到的顶点。定义一个割划分出的$S$集合为一个解，那么割集的容量之和就是(未被选的 $A$ 集合中的顶点的权值 $+$ 被选的 $B$ 集合中的顶点的权值)，记为$Cut$。 $A$ 集合中所有顶点的权值之和记为$Total$，那么$Total - Cut$就是(被选的 $A$ 集合中的顶点的权值 $-$ 被选的 $B$ 集合中的顶点的权值)，即为我们的目标函数，记为 $A$ 。要想最大化目标函数 $A$ ，就要尽可能使$Cut$小，$Total$是固定值，所以目标函数 $A$ 取得最大值的时候，$Cut$最小，即为最小割。 swust P1738 最小路径覆盖问题题目链接：https://www.oj.swust.edu.cn/problem/show/1738 题意问最少多少条路径可以覆盖一个有向无环图所有的点。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 构造二分图，把原图每个顶点$i$拆分成二分图$X$，$Y$集合中的两个顶点$X_i$和$Y_i$。对于原图中存在的每条边$(i,j)$，在二分图中连接边$(X_i,Y_j)$。然后把二分图最大匹配模型转化为网络流模型，求网络最大流。最小路径覆盖的条数，就是原图顶点数，减去二分图最大匹配数（因为路径长度可为$0$，所以最大路径覆盖数为顶点数，每多一条边则少一个路径覆盖）。沿着匹配边查找，就是一个路径上的点，输出所有路径即可。 swust P1739 魔术球问题题目链接：https://www.oj.swust.edu.cn/problem/show/1739 题意问 $n$ 根柱子一共可以放下多少个球。放球规则为数字从小到大依次放且每根柱子的相邻的两个球的值相加为平方数。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 先从 $1$ 至无穷枚举可能放下多少个球（不能二分，因为二分得重新构图）。一旦数字 $m$ 放不下则结束枚举。可以把所有的球看成有向无环图的点，柱子看成路径。所以问题就成了最小路径覆盖 $m$ 个点。先拆点，枚举的时候每加一个点 $x_i$ 与源点相连， $y_i$ 与汇点相连，再连小于这个点且能与他相加能开方的点的边 $x_i -&gt; y_j$ 。一旦 $m$ 个点覆盖的路径大于 $n$ ，则结束枚举，并输出 $m - 1$ 。 swust P1740 圆桌问题题目链接：https://www.oj.swust.edu.cn/problem/show/1740 题意要把 $n$ 个单位的人安排到 $m$ 个餐桌上（同个餐桌不能有来自相同单位的人）。 题解二分图多重匹配问题，可以用最大流解决。 建立二分图，每个单位为$X$集合中的顶点，每个餐桌为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$顶点连接一条容量为该单位人数的有向边。2、从每个$Y_i$顶点向$T$连接一条容量为该餐桌容量的有向边。3、$X$集合中每个顶点向$Y$集合中每个顶点连接一条容量为$1$的有向边（每个单位只能有一个人去一个餐桌）。求网络最大流，如果最大流量等于所有单位人数之和，则存在解，否则无解。对于每个单位，从$X$集合对应点出发的所有满流边指向的$Y$集合的顶点就是该单位人员的安排情况（一个可行解）。 swust P1741 最长递增子序列问题题目链接：https://www.oj.swust.edu.cn/problem/show/1741 题意计算序列的最长递增子序列的长度 $s$ 。 并给出序列中最多可取出多少个长度为 $s$ 的递增子序列。如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列。 题解分层图问题，可用最大流解决。 先 $dp$ 出每个 $i$ 的最长递增子序列 $F[i]$ 。对于规则$1$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。对于规则$2$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。（ $1$ 与 $n$ 点容量为无穷）。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。求最大流。 swust P1742 试题库问题题目链接：https://www.oj.swust.edu.cn/problem/show/1742 题意试题库中有 $n$ 道题（每道题各有几种属性，共有 $k$ 种属性），现在每种类型各需要 $m_i$ 道题共 $m$ 道题组成一套试卷，问是否能组成，能的话输出选择的题目。 题解二分图多重匹配问题，用最大流解决。 建立二分图，每个类别为$X$集合中的顶点，每个题为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$连接一条容量为该类别所需数量的有向边。2、从每个$Yi$向$T$连接一条容量为$1$的有向边。3、如果一个题$i$属于一个类别$j$，连接一条从$X_j$到$Y_i$容量为$1$的有向边。求网络最大流，如果最大流量等于所有类别所需之和，则存在解，否则无解。对于每个类别，从$X$集合对应点出发的所有满流边，指向的$B$集合中的顶点就是该类别的所选的题（一个可行解）。 swust P1744 方格取数题目链接：https://www.oj.swust.edu.cn/problem/show/1744 题意一个方格取出一些数（所有的数都不想邻）的和最大。 题解选出的点满足任意两个都不相邻，这是点独立集的概念。使选出的总和最大:最大点权独立集。最大点权独立集 = 总点权 - 最小点权覆盖集 = 总点权 - 最小割 = 总点权 - 最大流。取得数总和最大转化为不取的损失最小。所以问题即可以转化为割掉最小的边，使原图不连通（即找不出方格中相邻且二分图中有边相连的点）。 把棋盘黑白染色。对于黑色的，连接源点，容量为格子中的数。对于白色的，连接汇点，容量为格子中的数。然后把所有黑点和相邻的白点连边，容量无穷大。于是我们构造出了一个二分图。题目说不能取相邻的格子，那么对于这张二分图来说，就不能让他有一条边有流经过（否则就取了两个相邻的格子了）。于是求最小割即可。等于求最大流。最后用总和减去最小割即可。 swust P1745 餐巾计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1745 题意一个餐厅 $n$ 天里每天都需要 $x$ 餐巾，可以选择花费 $p$ 元购买新的，也可以选择将已有的花 $s$ 元送去慢洗 $m$ 天，或者花 $f$ 元送去快洗 $k$ 天，或者延期洗。要花费最小。 题解最小费用最大流问题。 将 $n$ 天拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与源点相连，容量为 $x$，花费为 $0$。将 $y_i$ 与汇点相连，容量为 $x$，花费为 $0$。将 $x_i$ 与 $y_i + m$ 相连，容量无穷，费用为 $s$ 。将 $x_i$ 与 $y_i + k$ 相连，容量无穷，费用为 $f$ 。将 $x_i$ 与 $x_i + 1$ 相连，容量无穷，费用为 $0$ 。将源点与 $y_i$ 相连，容量为无穷，费用为 $p$。求最小费用最大流。 swust P1746 航空路线问题题目链接：https://www.oj.swust.edu.cn/problem/show/1746 题意给一幅图，求从最西边到最东边再回到最西边经过的城市最多。（除了起点其他城市只能走一次） 题解最大费用最大流问题。 将 $n$ 个城市拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ ，费用为 $1$ 。起点与终点容量为 $2$ 。（如果这个点流量为 $1$ ，表示这个点被使用。）如果两城市相连则连接 $x_i$ 与 $y_j$ ，容量为 $1$ ，费用为 $0$ 。从起点到终点跑最小费用最大流。 swust P1748 星际转移问题题目链接：https://www.oj.swust.edu.cn/problem/show/1748 题意人得借助 $m$ 艘太空船（容量限定）与 $n$ 个空间站从地球转移到月球，每艘太空船每天有规律的停靠在某个空间站，问最少多少天转移所有人。 题解分层图网络流问题，枚举答案。 我们把网络优化问题转化为枚举答案+可行性判定问题。枚举天数，按天数把图分层，因为乘船每坐一站天数都要增加一，把太空船航线抽象成图中的一条边，跨图的两层。由于太空船容量有限，边上也要加上容量限制。除了坐船以外，人还可以在某个空间站等待下一班太空船的到来，所以每个点要与下一层同一点连接一条容量为无穷的边。 从源点向每一天的地球链接一条容量无穷的边。从每一天的月亮向汇点链接一条容量无穷的边。从上一天的每一个节点向当天的对应节点链接一条容量无穷的边（因为人们可以留在中转站等一等）。针对每一艘飞船，获取其上一天的位置，再获取这一天的位置，在这两个点之间连一条容量为飞船满载人数的流。每次新加一天然后跑到最大流超过$k$即可。至于无解的情况只要当$ans$达到一个很大的值的时候跳出来即可。 swust P1751 数字梯形问题题目链接：https://www.oj.swust.edu.cn/problem/show/1751 题意梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。规则1：从梯形的顶至底的 $m$ 条路径互不相交。规则2：从梯形的顶至底的 $m$ 条路径仅在数字结点处相交。规则3：从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 题解求图的最大权不相交路径及其变种，用最大费用最大流解决。 把梯形每个位置拆点为 $x_i$ 与 $y_i$ 。（因为要保证每个点只能用一次）$x_i$ 与 $y_i$ 相连容量为 $1$ ，费用为点值。从一点向它的左下或右下（ $y_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为 $0$ 的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为 $1$ ，费用为 $0$。 对于规则 $2$ ，不用拆点，因为不限制点的使用。从一点向它的左下或右下（ $x_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为点值的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为无穷，费用为点值。（无穷因为不限制点的使用）对于规则 $3$ ，只需要把规则 $2$ 中除了第一层与源点连边之外的边容量全部改为无穷大。（因为不限制边的使用） swust P1752 运输问题题目链接：https://www.oj.swust.edu.cn/problem/show/1752 题意把 $m$ 个仓库的 $a_i$ 货物运送到 $n$ 个需求为 $b_i$ 的商店去，第 $i$ 个仓库运到第 $j$ 个商店的费用为 $c_{ij}$ 。求最小与最大费用。 题解费用流问题。 把所有仓库看做二分图中顶点$X_i$，所有零售商店看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为仓库中货物数量$a_i$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为商店所需货物数量$b_i$，费用为$0$的有向边。从每个Xi向每个$Y_j$连接一条容量为无穷大，费用为$c_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少运费，求最大费用最大流，最大费用流值就是最多运费。 swust P1753 分配问题题目链接：https://www.oj.swust.edu.cn/problem/show/1753 题意$n$ 个人需要工作，第 $i$ 个人需要第 $j$ 个工作的工资为 $c_{ij}$。求最小与最大费用。 题解费用流问题。 把所有人看做二分图中顶点$X_i$，所有工作看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为$1$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为$1$，费用为$0$的有向边。从每个$X_i$向每个$Y_j$连接一条容量为无穷大，费用为$C_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少工资，求最大费用最大流，最大费用流值就是最多工资。 swust P1754 负载平衡问题题目链接：https://www.oj.swust.edu.cn/problem/show/1754 题意有 $n$ 个环形仓库存着不同的货物，求最小步数使得所有仓库货物相等。 题解费用流问题。 首先求出所有仓库存货量平均值，设第$i$个仓库的盈余量为$A[i]$，$A[i] = $第$i$个仓库原有存货量 $-$ 平均存货量。建立二分图，把每个仓库抽象为两个节点$X_i$和$Y_i$。增设附加源$S$汇$T$。如果$A[i]&gt;0$，从$S$向$X_i$连一条容量为$A[i]$，费用为$0$的有向边。（有盈余）如果$A[i]&lt;0$，从$Y_i$向$T$连一条容量为$-A[i]$，费用为$0$的有向边。（需添加）每个$X_i$向两个相邻顶点$j$，从$X_i$到$X_j$连接一条容量为无穷大，费用为$1$的有向边，从$X_i$到$Y_j$连接一条容量为无穷大，费用为$1$的有向边。（旁边可能是终点，也可能是中转站）求最小费用最大流，最小费用流值就是最少搬运量。 swust P1755 深海机器人问题题目链接：https://www.oj.swust.edu.cn/problem/show/1755 题意深海资源考察探险队的潜艇将到达深海的海底进行科学考察。潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物的标本只能采集一次。本题限定深海机器人只能从其出发的位置沿着向北或者向东方向移动，而且多个深海机器人可以在同一时间占据同一位置。 题解费用流问题。 把网格中每个位置抽象成网络中一个节点，建立附加源$S$汇$T$。对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为$1$ ，费用为该边价值的有向边。（每个点的价值只能使用一次）对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为无穷大，费用为$0$ 的有向边。（多个机器人可同时在同点，不限制点的使用）从$S$到每个出发点$i$连接一条容量为该点出发的机器人数量，费用为$0$的有向边。从每个目标点$i$到$T$连接一条容量为可以到达该点的机器人数量，费用为$0$的有向边。求最大费用最大流，最大费用流值就采集到的生物标本的最高总价值。 poj P1149 PIGS题目链接：http://poj.org/problem?id=1149 题意有 $m$ 个猪圈与 $n$ 个客人，每个客人可以到 $k$ 个猪圈买猪，最多可以买 $x$ 头猪，（每个顾客走后他所打开的猪圈里的猪可以任意交换）求所有顾客最多可以买多少猪。 题解最大流 可以想到每个猪圈都有第一个顾客，后面的顾客可以拿的数量取决于前面的顾客所拿的数量，所以就单个猪圈而言，当前顾客可拿量取决于上一个顾客。所以可以拿同一个猪圈的顾客 $i$ 与 $i + 1$ 连边，边权为无穷。这样除每个猪圈第一顾客后的所有顾客都有了猪的来源，再将每个猪圈的第一个顾客与源点连边，边权为猪圈中猪数量，这样第一个顾客也有了猪的来源。再将每个顾客与汇点连边，边权为其最多可买的猪的数量。跑一次最大流即为答案。 poj P2391 Ombrophobic Bovines题目链接：http://poj.org/problem?id=2391 题意有 $n$ 个牛棚，每个牛棚有其牛的数量与其容量，现在下雨了，求最少的时间把所有的牛放到牛棚里。 题解最大流 先用 $floyd$ 求出每个点之间的最短路，那么时间限制了点对之间是否可以连边。二分时间，拆点与源汇连边，如果两点间的距离小于等于时间则连边。如果跑出满流证明时间可满足。最后通过二分求出答案。 2017urumuqi j题目链接： 题意从一个点经过另一个点到一个点的最小费用（每个点只能经过一次）。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量除中转点外都为 $1$ ，中转点容量为 $2$ 。再把图上有的边连上，费用为边权，容量为无穷。源点与起点终点连接，容量为 $1$ ，费用为 $0$ ；汇点与中转点连接，容量为 $2$ ，费用为 $0$ 。如果流量为 $2$ ，则答案为费用，否则输出 $-1$ 。 2017qingdao k题目链接： 题意上一题的复杂版，从西安到上海后再从上海到青岛，最后从青岛返回上海。上海有两个机场，其中从西安到是到浦东机场到虹桥机场到青岛，青岛回上海是回虹桥机场。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量青岛及虹桥容量为 $2$ ，其余点容量都为 $1$ 。再把图上有的无向边连上，费用为边权，容量为无穷。源点与西安、青岛连接，西安容量为 $1$ ，青岛容量为 $2$ ，费用为 $0$ ；汇点与虹桥及浦东连接，虹桥容量为 $2$ ，浦东容量为 $1$ ，费用为 $0$ 。如果流量为 $3$ ，则答案为费用，否则输出 $-1$ 。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin America I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAmeIImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 给一幅联通图，$q$次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int tot,cnt,head[M],f[M];ll ans;struct edge&#123; int v,next;ll w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v;ll w; edge1()&#123;&#125; edge1 (int u1,int v1,ll w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; tot=ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int sz[M],dep[M],fat[M],son[M],rnk[M],id[M],top[M];ll val[M];void dfs(int u,int fa,int d)&#123; sz[u]=1;dep[u]=d;son[u]=-1,fat[u]=fa; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; val[v]=w; dfs(v,u,d+1); sz[u]+=v; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fat[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=val[rnk[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;ll query(int x,int y)&#123; int fx=top[x],fy=top[y];ll res=0; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; res=max(res,seg.query(id[fx],id[x],1,n,1)); x=fat[fx],fx=top[x]; &#125; else&#123; res=max(res,seg.query(id[fy],id[y],1,n,1)); y=fat[fy],fy=top[y]; &#125; &#125; if(x==y) return res; if(dep[x]&gt;dep[y]) res=max(res,seg.query(id[son[y]],id[x],1,n,1)); else res=max(res,seg.query(id[son[x]],id[y],1,n,1)); return res;&#125;void solve()&#123; dfs(1,-1,0);dfs1(1,1);seg.build(1,n,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%lld\n",ans); else&#123; printf("%lld\n",ans-query(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%lld",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Moscow Subregional C Carpet]]></title>
    <url>%2F2019%2F03%2F29%2F2017MoscowSubregionalCCarpet%2F</url>
    <content type="text"><![CDATA[2017 Moscow Subregional C Carpethttps://vjudge.net/contest/260542#problem/C 给一个 $1000000 \times 20$ 的格子图，要求找一种方式把一颗不超过 $100000$ 个节点的树放到格子图里，并且没有边交叉。考虑把树剖分，因为不超过对数条数的链，所以依次把重链放到一列中，轻链放到下一列即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;int n;int cnt,head[M];int sz[M],f[M],son[M],x[M],y[M],tmp[M];struct edge&#123; int v,next;&#125;e[M&lt;&lt;1];void init()&#123; cnt=0;memset(head,-1,sizeof(head));memset(tmp,0,sizeof(tmp));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=1,f[u]=fa,son[u]=-1; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int z)&#123; y[u]=z;x[u]=++tmp[z]; if(son[u]==-1) return; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,z+1); &#125; dfs1(son[u],z); return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1);dfs1(1,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n", x[i],y[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5242]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5242%2F</url>
    <content type="text"><![CDATA[hdu 5242 Gamehttp://acm.hdu.edu.cn/showproblem.php?pid=5242 给一棵点权树，问从根节点出发$k$次最多能获得多少能量。同一个点的能量只能获取一次。每次从根节点出发肯定要走到叶子节点才是最优的选择。而且每次都要走的是上一次走完后的能量最多的路径。很容易想到按点权把树剖分成轻重链。每一条链都是从叶子到某个节点的，所以当重链被选择后，最重的轻链便成了重链，所以只要把剖分出的前 $k$ 条链的能量相加即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;int _,n,k,cas=1;int cnt,head[M],tot;struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];int son[M],f[M];ll sz[M],a[M],tmp[M],ans[M];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=a[u];son[u]=-1;f[u]=fa; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); if(sz[v]&gt;sz[son[u]]||son[u]==-1)&#123; sz[u]=sz[u]-sz[son[u]]+sz[v]; son[u]=v; &#125; &#125;&#125;void dfs1(int u,ll w)&#123; tmp[u]=a[u]+w; if(son[u]==-1)&#123; ans[++tot]=tmp[u]; return ; &#125; dfs1(son[u],tmp[u]); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,0); &#125; return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1); // for(int i=1;i&lt;=n;i++) printf("%d %d\n",f[i],son[i]); dfs1(1,0); ll res=0; printf("Case #%d: ",cas++); if(k&gt;tot)&#123; for(int i=1;i&lt;=tot;i++) res+=ans[i]; printf("%lld\n",res); &#125; else&#123; sort(ans+1,ans+1+tot); for(int i=tot;i&gt;tot-k;i--) res+=ans[i]; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wannafly day1 I]]></title>
    <url>%2F2019%2F03%2F29%2Fwannafly-day1-I%2F</url>
    <content type="text"><![CDATA[wannafly_day1_I.cpphttp://newoj.acmclub.cn/contests/1389/problem/8 给一棵树，给出 $m$ 次染色，问每个点的第 $k$ 次染色是什么颜色。倒着做，用线段树维护区间染色的最大次数，如果有 $k - 1$次的区间存在，就找到那个点把它的颜色更新，并把它的染色次数变为 $-inf$。复杂度 $O(nlog(n)^2)$，注意下 $update$ 的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 1e5+7;const int inf = 2147483647;int n,m,k;int tot,cnt,head[M];int sz[M],f[M],son[M],dep[M],rnk[M],top[M],id[M];int lazy[M&lt;&lt;2],mx[M&lt;&lt;2],ans[M];struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));memset(ans,0,sizeof(ans));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int d)&#123; sz[u]=1,f[u]=fa,son[u]=-1,dep[u]=d; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u,d+1); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return ; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]);&#125;void pushdown(int rt,int l,int r)&#123; if(lazy[rt]&gt;0)&#123; int v=lazy[rt]; lazy[rt]=0; mx[r]+=v;lazy[r]+=v; mx[l]+=v;lazy[l]+=v; &#125; return ;&#125;void build(int l,int r,int rt)&#123; mx[rt]=0;lazy[rt]=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int l,int r,int rt,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(mx[rt]==k-1)&#123; if(l==r)&#123; mx[rt]=-inf,ans[rnk[l]]=v,lazy[rt]=0; &#125; else&#123; pushdown(up); int mid=(l+r)&gt;&gt;1; if(mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); &#125; &#125; else mx[rt]++,lazy[rt]++; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(R&gt;mid&amp;&amp;mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); return ;&#125;void query(int x,int y,int v)&#123; int fx=top[x],fy=top[y]; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; update(id[fx],id[x],1,n,1,v); x=f[fx],fx=top[x]; &#125; else&#123; update(id[fy],id[y],1,n,1,v); y=f[fy],fy=top[y]; &#125; &#125; if(dep[x]&gt;dep[y]) update(id[y],id[x],1,n,1,v); else update(id[x],id[y],1,n,1,v);&#125;int qu[M],qv[M],qc[M];int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); init(); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); build(1,n,1); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1,1); dfs1(1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;qu[i],&amp;qv[i],&amp;qc[i]); &#125; for(int i=m;i&gt;=1;i--)&#123; query(qu[i],qv[i],qc[i]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin Ame I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-IImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 倍增找两点与$LCA$路径上的最大边权。给一幅联通图，$q$ 次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int ans,cnt,head[M],f[M];int fa[M][26],mx[M][26],dep[M];struct edge&#123; int v,next,w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v,w; edge1()&#123;&#125; edge1 (int u1,int v1,int w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); memset(dep,0,sizeof(dep));memset(fa,0,sizeof(fa));memset(mx,0,sizeof(mx)); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,int w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void dfs(int u,int depth)&#123; dep[u]=depth; int j=1; while ((1&lt;&lt;j)&lt;depth)&#123; fa[u][j]=fa[fa[u][j-1]][j-1]; mx[u][j]=max(mx[u][j-1],mx[fa[u][j-1]][j-1]); j++; &#125; for (int i=head[u];~i;i=e[i].next) if (dep[e[i].v]==0)&#123; int v=e[i].v; fa[v][0]=u;mx[v][0]=e[i].w; dfs(v,depth+1); &#125;&#125;void up(int &amp;u,int step,int &amp;res)&#123; for (int i=0;i&lt;=20;i++) if (step&amp;(1&lt;&lt;i)) &#123; res=max(mx[u][i],res); u=fa[u][i]; &#125; return ;&#125;int work(int u,int v)&#123; int res=0; if (dep[u]&lt;dep[v]) up(v,dep[v]-dep[u],res); else up(u,dep[u]-dep[v],res); for (int i=20;i&gt;=0;i--) if (fa[u][i]!=fa[v][i])&#123; res=max(res,max(mx[u][i],mx[v][i])); u=fa[u][i];v=fa[v][i]; &#125; if (u!=v) res=max(res,max(mx[u][0],mx[v][0])); return res;&#125;void solve()&#123; dfs(1,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%d\n",ans); else&#123; printf("%d\n",ans-work(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%d",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5950]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5950%2F</url>
    <content type="text"><![CDATA[hdu 5950 Recursive sequencehttp://acm.hdu.edu.cn/showproblem.php?pid=5950 $F_1=a,F_2=b。F_n=F_{n-1}+2\times F_{n-2}+n^4$。输入$n$，求$F_n$。用二项式定理把 $n^4$ 拆开，就是裸的矩阵快速幂了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 2147493647;int _;ll n,a,b;struct mat&#123; ll a[8][8]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;7;i++) a[i][i]=1; &#125; mat operator * (const mat &amp; t)const&#123; mat tmp; for(int i=0;i&lt;7;i++) for(int j=0;j&lt;7;j++) for(int k=0;k&lt;7;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=1ll,x.a[0][1]=2ll,x.a[0][2]=1ll,x.a[0][3]=4ll,x.a[0][4]=6ll,x.a[0][5]=4ll,x.a[0][6]=1ll; x.a[1][0]=1ll; x.a[2][2]=1ll,x.a[2][3]=4ll,x.a[2][4]=6ll,x.a[2][5]=4ll,x.a[2][6]=1ll; x.a[3][3]=1ll,x.a[3][4]=3ll,x.a[3][5]=3ll,x.a[3][6]=1ll; x.a[4][4]=1ll,x.a[4][5]=2ll,x.a[4][6]=1ll; x.a[5][5]=1ll,x.a[5][6]=1ll; x.a[6][6]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); if(n==1)&#123; printf("%lld\n",a); continue; &#125; if(n==2)&#123; printf("%lld\n",b); continue; &#125; mat y=matrix_pow(x,n-2ll); printf("%lld\n",((((((y.a[0][0]*b%mod+y.a[0][1]*a%mod)%mod+y.a[0][2]*16ll%mod)%mod+y.a[0][3]*8ll%mod)%mod+y.a[0][4]*4ll%mod)%mod+y.a[0][5]*2ll%mod)%mod+y.a[0][6])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2018程序设计竞赛G]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62018%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BG%2F</url>
    <content type="text"><![CDATA[湘潭大学2018程序设计竞赛Ghttps://www.nowcoder.com/acm/contest/105/G 给一个递推式，$F_i=F_{i-1}+F_{i-2}+i^3+i^2+i+1。F_1=1,F_0=0$。问$F_n$是多少。典型的用矩阵快速幂加速解决斐波那契递推式。$F_{i+1}=F_i+F_{i-1}+(i+1)^3+(i+1)^2+(i+1)+1=F_i+F_{i-1}+i^3+4 \times i^2+6 \times i+4$。构造一个$6$阶矩阵即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7ll; int _;ll n;struct mat&#123; ll a[7][7]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;6;i++) a[i][i]=1; &#125; mat operator * (const mat&amp; t)const&#123; mat tmp; for(int i=0;i&lt;6;i++) for(int j=0;j&lt;6;j++) for(int k=0;k&lt;6;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=x.a[0][1]=x.a[0][2]=1ll;x.a[0][3]=x.a[0][5]=4ll;x.a[0][4]=6ll; x.a[1][0]=1ll; x.a[2][2]=x.a[2][5]=1ll;x.a[2][3]=x.a[2][4]=3ll; x.a[3][3]=x.a[3][5]=1ll;x.a[3][4]=2ll; x.a[4][4]=x.a[4][5]=1ll; x.a[5][5]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld",&amp;n); mat y=matrix_pow(x,n-1ll); printf("%lld\n",((((y.a[0][0]+y.a[0][2])%mod+y.a[0][3])%mod+y.a[0][4])%mod+y.a[0][5])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Tsukuba H]]></title>
    <url>%2F2019%2F03%2F29%2F2017Tsukuba-H%2F</url>
    <content type="text"><![CDATA[2017Tsukuba Hhttps://vjudge.net/contest/259596#problem/G 有个人有两个课程，每个课程有很多个作业，每个作业有开始日期与截至日期。每天只能选择一个课程的一个作业做。问这个人最多与最少可以完成多少作业。最多的话贪心的去找到每天可以做的所有作业中截止日期最近的那个即可。最少的话将日期拆点表示日期只能用一次，一种作业与源点连接容量为 $1$，然后与日期一边 $[start,deadline]$ 连接容量为 $1$。另一种作业与汇点连接容量为 $1$，然后与日期另一边 $[start,deadline]$ 连接容量为 $1$。因为当日期只与一个种类作业连接或者没有作业连接时这一天都可以没作业做。相当于寻找一个最小的割集让图不连通也就是所有日期都最多只有一个种类的作业连接，找不到作业去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2010,inf=0x3f3f3f3f;int n,m,st[407],ed[407],st1[407],ed1[407],ans,ans1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;vector&lt;int&gt; s[407],s1[407];void init()&#123; while(!q.empty()) q.pop();ans=0;ans1=0; for(int i=1;i&lt;=401;i++) s[i].clear(),s1[i].clear();&#125;struct Dinic&#123; struct edge &#123; int from,to,cap,flow; &#125;; vector&lt;edge&gt;es; vector&lt;int&gt;G[maxn]; bool vis[maxn]; int dist[maxn]; int iter[maxn]; void init(int n)&#123; for(int i=0; i&lt;=n+10; i++) G[i].clear(); es.clear(); &#125; void addedge(int from,int to,int cap)&#123; es.push_back((edge)&#123; from,to,cap,0 &#125;); es.push_back((edge)&#123; to,from,0,0 &#125;); int x=es.size(); G[from].push_back(x-2); G[to].push_back(x-1); &#125; bool BFS(int s,int t)&#123; memset(vis,0,sizeof(vis)); queue &lt;int&gt; Q; vis[s]=1; dist[s]=0; Q.push(s); while(!Q.empty())&#123; int u=Q.front(); Q.pop(); for(int i=0; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; vis[e.to]=1; dist[e.to]=dist[u]+1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int u,int t,int f)&#123; if(u==t||f==0) return f; int flow=0,d; for(int &amp;i=iter[u]; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(dist[u]+1==dist[e.to]&amp;&amp;(d=DFS(e.to,t,min(f,e.cap-e.flow)))&gt;0)&#123; e.flow+=d; es[G[u][i]^1].flow-=d; flow+=d; f-=d; if(f==0) break; &#125; &#125; return flow; &#125; int Maxflow(int s,int t)&#123; int flow=0; while(BFS(s,t)) &#123; memset(iter,0,sizeof(iter)); int d=0; while(d=DFS(s,t,inf)) flow+=d; &#125; return flow; &#125;&#125;dinic;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init();dinic.init(1000+n); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;st[i],&amp;ed[i]); s[st[i]].push_back(ed[i]); &#125; for(int i=1;i&lt;=n-m;i++)&#123; scanf("%d%d",&amp;st1[i],&amp;ed1[i]); s1[st1[i]].push_back(ed1[i]); &#125; for(int i=1;i&lt;=400;i++)&#123; for(int j=0;j&lt;s[i].size();j++) q.push(s[i][j]); for(int j=0;j&lt;s1[i].size();j++) q.push(s1[i][j]); while(!q.empty())&#123; if(q.top()&lt;i) q.pop(); else&#123; q.pop(); ans++; break; &#125; &#125; &#125; printf("%d\n",ans); int s=0,t=800+n+1; for(int i=m+1;i&lt;=m+400;i++)&#123; dinic.addedge(i,i+400,1); &#125; for(int i=1;i&lt;=m;i++)&#123; dinic.addedge(s,i,1); for(int j=st[i];j&lt;=ed[i];j++) dinic.addedge(i,m+j,1); &#125; for(int i=1;i&lt;=n-m;i++)&#123; dinic.addedge(m+800+i,t,1); for(int j=st1[i];j&lt;=ed1[i];j++) dinic.addedge(m+400+j,m+800+i,1); &#125; printf("%d\n",dinic.Maxflow(s,t)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Daejeon E]]></title>
    <url>%2F2019%2F03%2F29%2F2017Daejeon-E%2F</url>
    <content type="text"><![CDATA[2017Daejeon E给出一个有 $n$ 个点 $m$ 条边的图，每条边有一个边权。问要使第 $i$ 条边成为图的最小生成树的一条边最少要删掉多少条边，求出每条边的对应答案的和。枚举边 $i$ ，找出那些边权小于 $i$ 的边权的边，这些边都是网络流里的边，然后以连接 $i$ 的两个点为源点和汇点跑网络流求最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000;const int MAXM = 4000;const int inf = 0x3f3f3f3f;struct edge&#123; int to,next,cap,flow;&#125;e[MAXM];int n,m;int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol=0;memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw=0)&#123; e[tol].to=v;e[tol].cap=w;e[tol].next=head[u]; e[tol].flow=0;head[u]=tol++; e[tol].to=u;e[tol].cap=rw;e[tol].next=head[v]; e[tol].flow=0;head[v]=tol++;&#125;int sap(int st,int ed,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u=st; pre[u]=-1; gap[0]=N; int ans=0; while(dep[st]&lt;N)&#123; if(u==ed)&#123; int Min=inf; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; if(Min&gt;e[i].cap-e[i].flow) Min=e[i].cap-e[i].flow; &#125; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; e[i].flow+=Min; e[i^1].flow-=Min; &#125; u=st; ans+=Min; continue; &#125; bool flag=false; int v; for(int i=cur[u];~i;i=e[i].next)&#123; v=e[i].to; if(e[i].cap-e[i].flow&amp;&amp;dep[v]+1==dep[u])&#123; flag=true; cur[u]=pre[v]=i; break; &#125; &#125; if(flag)&#123; u=v; continue; &#125; int Min=N; for(int i=head[u];~i;i=e[i].next)&#123; if(e[i].cap-e[i].flow&amp;&amp;dep[e[i].to]&lt;Min)&#123; Min=dep[e[i].to]; cur[u]=i; &#125; &#125; gap[dep[u]]--; if(!gap[dep[u]]) return ans; dep[u]=Min+1; gap[dep[u]]++; if(u!=st) u=e[pre[u]^1].to; &#125; return ans;&#125;struct E&#123; int u,v,w,fl; bool operator &lt; (const E &amp;k) const&#123; return w&lt;k.w; &#125;&#125;ee[1000];int tot=0;void solve()&#123; int ans=0; for(int i=1;i&lt;=tot;i++)&#123; init(); for(int j=1;j&lt;i;j++)&#123; if(ee[j].w&lt;ee[i].w)&#123; addedge(ee[j].u,ee[j].v,1); addedge(ee[j].v,ee[j].u,1); &#125; &#125; ans+=sap(ee[i].u,ee[i].v,n); &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ee[++tot].u=u;ee[tot].v=v;ee[tot].w=w;ee[tot].fl=0; &#125; sort(ee+1,ee+tot+1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017LatinAme F]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-F%2F</url>
    <content type="text"><![CDATA[2017LatinAme F Fundraisinghttps://vjudge.net/contest/259114#problem/F n个人有漂亮值、财富值以及钱财三个属性。当一个人的漂亮值比另一个人严格大，且财富值比那个人小的时候，这两个人会发生争吵。问怎样选择一个集合，使得集合里的人互不争吵且钱财之和最大。先将相同漂亮值财富值的人合并然后将人按照漂亮值排序。然后遍历所有的人找到财富值比它小的钱财最大的状态然后加上那个状态更新当前财富值。注意同样的漂亮值的人互不影响。最后看所有的财富值中最大的即是答案。注意离散化财富值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;struct node&#123; int b,f;ll d; node () &#123;&#125; node (int b1,int f1,ll d1)&#123; b=b1;f=f1;d=d1; &#125; bool operator &lt; (const node &amp; k)const &#123; if(b!=k.b) return b&lt;k.b; return f&lt;k.f; &#125;&#125;p[M];map&lt;node,ll&gt; mp;int n,tot,f[M];struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=0; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll v)&#123; if(l==r)&#123; if(v&gt;mx[rt]) mx[rt]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,v); else update(pos,rson,v); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;vector&lt;pair&lt;int,ll&gt; &gt; vec;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; mp.clear();tot=0;vec.clear(); for(int i=1;i&lt;=n;i++)&#123; int x,y;ll z; scanf("%d%d%lld",&amp;x,&amp;y,&amp;z); mp[node(x,y,0)]+=z; &#125; for(map&lt;node,ll&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; p[++tot].b=it-&gt;first.b;p[tot].f=it-&gt;first.f;p[tot].d=it-&gt;second; f[tot]=p[tot].f; &#125; sort(p+1,p+tot+1);int pre=0; sort(f+1,f+tot+1); int sz=unique(f+1,f+tot+1)-f-1; seg.build(0,sz,1); for(int i=1;i&lt;=tot;i++)&#123; if(p[i].b!=pre)&#123; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,0,sz,1,vec[i].second); &#125; vec.clear(); int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); pre=p[i].b; &#125; else&#123; int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); &#125; &#125; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,1,sz,1,vec[i].second); &#125; printf("%lld\n",seg.mx[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LYOI 2016 41]]></title>
    <url>%2F2019%2F03%2F29%2FLYOI2016-41%2F</url>
    <content type="text"><![CDATA[LYOI2016_41 一次函数https://lyoi.ac/problem/41 $n$ 个一次函数 $f_i(x) = k_i \times x + b_i$,有两个操作。第一个操作把指定一个二次函数的 $k$ 和 $b$ 改变。第二个操作给出区间 $[l,r]$ 以及 $x$ , 求 $f_r(f_{r-1}(…f_l(x)))$ 的值。根据推算得出对于一个区间的两个子区间 $l$ 与 $r$ ,$k_{rt} = k_l \times k_r$, $b_{rt} = k_r \times b_l + b_r$ 。用线段树维护 $k$ 与 $b$ ,询问的时候合并区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 2e5+7;typedef long long ll;const ll mod = 1e9+7;int n,q;ll a[M],c[M];char s[2];int ql,qr,qpos,tot;ll qx,qk,qb;struct Seg&#123; ll k[M&lt;&lt;3],b[M&lt;&lt;3]; void pushup(int rt,int l,int r)&#123; k[rt]=k[l]*k[r]%mod; b[rt]=(b[l]*k[r]%mod+b[r])%mod; &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; k[rt]=a[l],b[rt]=c[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll a,ll c)&#123; if(l==r)&#123; k[rt]=a,b[rt]=c; return ; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,a,c); else update(pos,rson,a,c); pushup(up); &#125; int query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return rt; &#125; int mid=(l+r)&gt;&gt;1,ll,rr,res; if(L&gt;mid)&#123; res=query(L,R,rson); return res; &#125; else if(R&lt;=mid)&#123; res=query(L,R,lson); return res; &#125; else&#123; ll=query(L,R,lson),rr=query(L,R,rson); pushup(++tot,ll,rr); return tot; &#125; &#125;&#125;seg;void solve()&#123; while(q--)&#123; scanf("%s",s); if(s[0]=='Q')&#123; tot=(M&lt;&lt;2)+1; scanf("%d%d%lld",&amp;ql,&amp;qr,&amp;qx); tot=seg.query(ql,qr,1,n,1); printf("%lld\n",(seg.k[tot]*qx%mod+seg.b[tot])%mod); &#125; else&#123; scanf("%d%lld%lld",&amp;qpos,&amp;qk,&amp;qb); seg.update(qpos,1,n,1,qk,qb); &#125; &#125;&#125;int main()&#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;q))&#123; for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;a[i],&amp;c[i]); seg.build(1,n,1); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nowcoder practice28 B]]></title>
    <url>%2F2019%2F03%2F29%2FNowcoder-practice28-B%2F</url>
    <content type="text"><![CDATA[Nowcoder_practice28_B 数据结构https://www.nowcoder.com/acm/contest/200/B $n$ 个数 $m$ 个操作。$1.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}$。$2.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}^{2}$。$3.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $\times x$。$4.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $+ x$。线段树模板题，维护一个加 $lazy$ 与一个乘 $lazy$ ,再维护两个答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int Nmax = 1e4+7;int n,q;ll a[Nmax];struct Seg&#123; ll sum[Nmax&lt;&lt;2],fsum[Nmax&lt;&lt;2],len[Nmax&lt;&lt;2],lazyadd[Nmax&lt;&lt;2],lazymul[Nmax&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; sum[rt]=sum[l]+sum[r]; fsum[rt]=fsum[l]+fsum[r]; &#125; void pushdown(int rt,int l,int r)&#123; if(lazymul[rt]!=1)&#123; ll v=lazymul[rt]; lazymul[rt]=1; sum[l]*=v;sum[r]*=v; fsum[l]*=(v*v);fsum[r]*=(v*v); lazymul[l]*=v;lazymul[r]*=v; lazyadd[l]*=v;lazyadd[r]*=v; &#125; if(lazyadd[rt])&#123; ll v=lazyadd[rt]; lazyadd[rt]=0; fsum[r]+=(2*sum[r]*v+v*v*len[r]);fsum[l]+=(2*sum[l]*v+v*v*len[l]); sum[r]+=(v*len[r]);sum[l]+=(v*len[l]); lazyadd[r]+=v;lazyadd[l]+=v; &#125; &#125; void build(int l,int r,int rt)&#123; sum[rt]=fsum[rt]=0;len[rt]=(ll)(r-l+1);lazyadd[rt]=0;lazymul[rt]=1; if(l==r)&#123; sum[rt]=a[l];fsum[rt]=a[l]*a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int L,int R,int l,int r,int rt,ll v,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==2)&#123; fsum[rt]+=(2*sum[rt]*v+v*v*len[rt]); sum[rt]+=(len[rt]*v); lazyadd[rt]+=v; &#125; else&#123; sum[rt]*=v;fsum[rt]*=(v*v); lazyadd[rt]*=v;lazymul[rt]*=v; &#125; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson,v,op); if(R&gt;mid) update(L,R,rson,v,op); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==1) return sum[rt]; else return fsum[rt]; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res+=query(L,R,lson,op); if(R&gt;mid) res+=query(L,R,rson,op); return res; &#125;&#125;seg;void solve()&#123; while(q--)&#123; int op,l,r;ll v; scanf("%d",&amp;op); if(op==1||op==2)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",seg.query(l,r,1,n,1,op)); &#125; else&#123; scanf("%d%d%lld",&amp;l,&amp;r,&amp;v); seg.update(l,r,1,n,1,v,op-2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); seg.build(1,n,1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[codeforces 1051Fhttp://codeforces.com/contest/1051/problem/F 给一副图，图中的边最多比点多 $20$ 条。给 $q$ 次询问，每次询问两点的最短路。随便弄一个生成树，然后求出两点在树上的距离。把非树边的两端点保存然后求分别求一次最短路。然后以所有非树边端点的最短距离更新即可。 wannafly_day1_Jhttp://newoj.acmclub.cn/contests/1389/problem/9 改成了边比点多100条，不过所有边的距离都是1，把非树边抽出来跑一下bfs求互相的最短距离。和cf1051F差不多。 wannafly_day3_Ihttps://www.nowcoder.com/acm/contest/203/I 多源最短路。在一幅无向图中给出点集，问点集中的每个点到其他点的最短距离是多少。把点集里的点都做为源点，每个点都再增加一个祖先属性，表示这个点被哪个源点的最短路所更新。然后跑一次多源最短路即可。 2017Tsukuba_Fhttps://vjudge.net/contest/259357#problem/F 问一幅有向图中每条边如果反向会让图中点1到点2的最短距离变大变小还是不变。先求出点1到各个点的最短距离与边反向之后点2到各个点的最短距离。如果变小的话就是 $dis_{1to} + dis_{2from} + w &lt; dis$ 。变大的话就是上述等式变成大于符号，但因为最短路可能有多条，所以只有这条边还是最短路无向图里的桥时才会让最短距离变大。上述两个情况都不满足的话，最短距离不变。 codeforces 1076Dhttp://codeforces.com/contest/1076/problem/D 最短路生成树$+dfs$给 $n$ 个点 $m$ 条边，找出一个边集不超过 $k$ 条边使得距离节点 $1$ 的距离是最短距离的点最多，输出这个边集首先将 $1$ 节点跑最短路建出最短路生成树，然后再在生成树上 $dfs$ 出一个 $k$ 条边的边集 2018SEERC Chttp://codeforces.com/gym/101964/problem/C 给出一棵树，这棵树由黑白点组成。选出一个黑点点集，点集中点数小于给定的k，找出所有可能的黑点点集里直径最小的那个并输出直径。考虑枚举所有的黑点点对，求出点对的距离，当有黑点满足离点对两点距离都小于等于点对距离时就可以将点加入。数形结合，可以理解为这些点在两个圆的相交部分，所以最大距离必是点对距离。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>spfa</tag>
        <tag>bfs</tag>
        <tag>Spanning Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git+hexo搭建]]></title>
    <url>%2F2019%2F03%2F29%2Fgit-hexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建所需环境首先需要 $git+node.js$。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
