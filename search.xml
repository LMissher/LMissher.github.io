<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[tasks.jsoninvscode]]></title>
    <url>%2F2019%2F04%2F28%2Ftasks-jsoninvscode%2F</url>
    <content type="text"><![CDATA[tasks配置##简介##tasks的任务就是帮我们快捷的在命令行中输出命令。按ctrl+shift+b可以选择配置的所有任务。也可以为任务设置快捷键。 ##Python配置12345678910111213&#123; "label": "python", //任务名称 "type": "shell", "group": &#123; //所在分组 "kind": "build", //类型编译 "isDefault": true &#125;, "command": "D:/Anaconda3/python.exe", //编译命令 "args": [ "$&#123;file&#125;" //参数，表示文件路径 ], "problemMatcher": []&#125; ##dot配置12345678910111213141516171819202122&#123; "label": "dot", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "reveal": "silent",//只在出错时弹出命令行 "echo": true, "showReuseMessage": false, "panel": "shared" &#125;, "command": "dot", "args": [ "-Tpdf", "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.pdf" ], "problemMatcher": []&#125;]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj4109]]></title>
    <url>%2F2019%2F04%2F28%2Fzoj4109%2F</url>
    <content type="text"><![CDATA[Welcome PartyProblemsThe 44th World Finals of the International Collegiate Programming Contest (ICPC 2020) will be held in Moscow, Russia. To celebrate this annual event for the best competitive programmers around the world, it is decided to host a welcome party for all participants of the World Finals, numbered from to for convenience. The party will be held in a large hall. For security reasons, all participants must present their badge to the staff and pass a security check in order to be admitted into the hall. Due to the lack of equipment to perform the security check, it is decided to open only one entrance to the hall, and therefore only one person can enter the hall at a time. Some participants are friends with each other. There are pairs of mutual friendship relations. Needless to say, parties are more fun with friends. When a participant enters the hall, if he or she finds that none of his or her friends is in the hall, then that participant will be unhappy, even if his or her friends will be in the hall later. So, one big problem for the organizer is the order according to which participants enter the hall, as this will determine the number of unhappy participants. You are asked to find an order that minimizes the number of unhappy participants. Because participants with smaller numbers are more important (for example the ICPC director may get the number 1), if there are multiple such orders, you need to find the lexicographically smallest one, so that important participants enter the hall first. Please note that if participant and are friends, and if participant and are friends, it’s NOT necessary that participant and are friends. InputThere are multiple test cases. The first line of the input contains a positive integer $T$, indicating the number of cases. For each test case: The first line contains two integers $n$ and $m$ $(1 \leq n,m \leq 10^6)$, the number of participants and the number of friendship relations. The following lines each contains two integers $a$ and $b$ $(1 \leq a,b \leq n, a \not= b)$, indicating that the $a$-th and the $b$-th participant are friends. Each friendship pair is only described once in the input. It is guaranteed that neither the sum of $n$ nor the sum of $m$ of all cases will exceed $10^6$. OutputFor each case, print a single integer on the first line, indicating the minimum number of unhappy participants. On the second line, print a permutation of $1$ to $n$ separated by a space, indicating the lexicographically smallest ordering of participants entering the hall that achieves this minimum number. Please, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect! Sample Input24 31 21 31 44 21 23 4Sample Output11 2 3 421 2 3 4 Solve给一个森林，只有当森林里节点的父亲节点被遍历过这个点才有机会被遍历。求遍历森立的最小字典序并输出。并查集判森林。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 1000000 + 5;int f[maxn],a,b,_,n,m,flag[maxn];vector&lt;int&gt; e[maxn];int find(int x)&#123; int tmp=x; while(tmp!=f[tmp]) tmp=f[tmp]; int y; while(x!=tmp)&#123; y=f[x]; f[x]=tmp; x=y; &#125; return x; &#125;int bfs()&#123; int ans=0; vector&lt;int&gt; vec; priority_queue&lt;int,vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i=1;i&lt;=n;++i)&#123; if(f[i]==i)&#123; ++ans;q.push(i); &#125; flag[i]=0; &#125; while(!q.empty())&#123; int u=q.top();q.pop(); if(flag[u]) continue; vec.push_back(u); flag[u]=1; for(int i=0;i&lt;e[u].size();++i)&#123; q.push(e[u][i]); &#125; &#125; printf("%d\n",ans); for(int i=0;i&lt;vec.size();++i) printf("%d%c",vec[i],i==vec.size()-1?'\n':' ');&#125;int main() &#123; #ifdef LOCAL freopen("zoj4109.in", "r", stdin); freopen("zoj4109.out", "w", stdout); #endif scanf("%d",&amp;_); while(_--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; f[i]=i;e[i].clear(); &#125; for(int i=1;i&lt;=m;++i)&#123; int ff,t; scanf("%d%d",&amp;ff,&amp;t); e[ff].push_back(t); e[t].push_back(ff); int fx=find(ff),fy=find(t); if(fx&lt;fy)&#123; f[fy]=fx; &#125; else&#123; f[fx]=fy; &#125; &#125; bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-2050-1006]]></title>
    <url>%2F2019%2F04%2F27%2F2019-2050-1006%2F</url>
    <content type="text"><![CDATA[冰水挑战描述现在，我们要依次面对 $n$ 个冰水挑战，每个挑战你都可以选择接受或不接受。接受第 $i$ 个挑战会让你丧失 $a_i$点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力 $x$ 会变成 $min(x,b_i)$，当你完成这个挑战的时候，你的体力会变成 $x−a_i$，体力任何时候不允许小于等于 $0$，无论你是否接受第 $i$ 个挑战，在这个挑战结束以后你的体力都会增加 $c_i$。现在我们想知道最多可以完成多少个挑战。 输入格式第一行一个正整数 $T (T \leq 50)$ 表示数据组数。接下来 $T$ 组数据，每组第一行两个正整数 $n,c (1 \leq n \leq 10^3, 1 \leq c \leq 10^9)$，表示挑战的数量和初始体力，接下来 $n$ 行，每行三个非负整数 $a_i,b_i,c_i(0 \leq a_i, b_i, c_i \leq 10^9)$。 输出格式对于每组数据输出一行一个数，表示你最多能完成几个挑战。 样例输入23 101 2 04 8 36 10 12 11 1 11 1 1 样例输出20 Solve这是一道01背包的改版题，$dp[i][j]$表示前$i$个冰桶挑战挑战$j$个的最大值，每到一个挑战要判断是否满足条件，满足的话进行状态转移，因为不管是否挑战都要加上$c_i$所以一定要有加上$c_i$的状态转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e3+7;ll dp[N][N],st;ll a[N],b[N],c[N];int _,n;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; scanf("%d%lld",&amp;n,&amp;st);memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;++i)&#123; scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); &#125; dp[0][0]=st; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;i;++j)&#123; if(dp[i-1][j])&#123; dp[i][j]=max(dp[i][j],dp[i-1][j]+c[i]); if(min(dp[i-1][j],b[i])&gt;a[i]) dp[i][j+1]=max(dp[i][j+1],min(dp[i-1][j],b[i])-a[i]+c[i]); &#125; &#125; &#125; /*dp[0]=st; for(int i=1;i&lt;=n;++i)&#123; dp[0]+=c[i]; for(int j=i;j&gt;0;--j)&#123; if(dp[j-1])&#123; ll tmp=min(dp[j-1],b[i]); if(tmp&gt;a[i]) dp[j]=max(dp[j],tmp-a[i]+c[i]); if(j-1) dp[j-1]+=c[i]; &#125; &#125; &#125;*/ for(int i=n;i&gt;=0;--i)&#123; if(dp[n][i])&#123; printf("%d\n",i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-2050-1005]]></title>
    <url>%2F2019%2F04%2F27%2F2019-2050-1005%2F</url>
    <content type="text"><![CDATA[球赛描述Alice和Bob在进行乒乓球比赛，比赛一共打了 $n$ 个球，对于每一球，如果Alice赢了，那么裁判员会在计分板上记下’$A$’，如果Bob赢了则会记下’$B$’。时间转眼间到了2050年，计分板上某些信息因为时间流逝丢失了，但我们想要复现当年的激烈局面。丢失的位置用’$?$’表示，我们想知道，计分板上对应的乒乓球球赛，最多进行了多少局（最后一局可以没打完，但是如果没打完的话就不计入答案）？在一局比赛中，先得$11$分的一方为胜方，$10$平后，先多得$2$分的一方为胜方。 输入格式对于每组数据输出一行一个数，表示乒乓球球赛最多进行的局数。 输出格式每行输出一个整数表示最小花费。 样例输入1AAAAAAAAAA?BBBBBBBBBB? 样例输出2 Solve设$dp[i][j][k]$表示前 $i$ 场对局比分为 $j:k$ 的最多局数。由于$10:10$的比分与$9:9$的比分是等价的，所有如果有$10:10$的比分出现就把它变成$9:9$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10000 + 5;int dp[maxn][12][12];//表示前i场对局比分为j:k的最多局数char s[maxn];struct node&#123; int x, y, z;&#125;;node cal(int i, int j)&#123; node tmp; if (i == 11 || j == 11) &#123; tmp.x = tmp.y = 0; tmp.z = 1; &#125; else &#123; tmp.z = 0; if (i == 10 &amp;&amp; j == 10) &#123; tmp.x = tmp.y = 9; &#125; else &#123; tmp.x = i; tmp.y = j; &#125; &#125; return tmp;&#125;int main()&#123;#ifdef LOCAL freopen("1005.in", "r", stdin); freopen("1005.out", "w", stdout);#endif int _; scanf("%d", &amp;_); while (_--) &#123; scanf("%s", s); int len = strlen(s); memset(dp, 128, sizeof(dp)); dp[0][0][0] = 0; for (int i = 1; i &lt;= len; ++i) &#123; for (int j = 0; j &lt;= 10; ++j) &#123; for (int k = 0; k &lt;= 10; ++k) &#123; if (s[i - 1] == 'A' || s[i - 1] == '?') &#123; node tmp = cal(j + 1, k); dp[i][tmp.x][tmp.y] = max(dp[i][tmp.x][tmp.y], dp[i - 1][j][k] + tmp.z); &#125; if (s[i - 1] == 'B' || s[i - 1] == '?') &#123; node tmp = cal(j, k + 1); dp[i][tmp.x][tmp.y] = max(dp[i][tmp.x][tmp.y], dp[i - 1][j][k] + tmp.z); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt;= 10; ++i) for (int j = 0; j &lt;= 10; ++j) ans = max(ans, dp[len][i][j]); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1935]]></title>
    <url>%2F2019%2F04%2F23%2Fbzoj1935%2F</url>
    <content type="text"><![CDATA[Tree 园丁的烦恼问题很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……” “是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。 “该死的，你究竟是什么来头？” “陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。 这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。 Input第一行有两个整数$n$，$m$（$0 \leq n \leq 500000$，$1 \leq m \leq 500000$）。$n$代表皇家花园的树木的总数，$m$代表骑士们询问的次数。 文件接下来的$n$行，每行都有两个整数$x_i$，$y_i$，代表第$i$棵树的坐标（$0 \leq x_i$，$y_i \leq 10000000$）。 文件的最后$m$行，每行都有四个整数$a_j$，$b_j$，$c_j$，$d_j$，表示第$j$次询问，其中所问的矩形以（$a_j$，$b_j$）为左下坐标，以（$c_j$，$d_j$）为右上坐标。 Output共输出$m$行，每行一个整数，即回答国王以（$a_j$，$b_j$）和（$c_j$，$d_j$）为界的矩形里有多少棵树。 Sample Input3 10 00 11 00 0 1 1 Sample Output3 Solve给$n$($n \leq 10^5$)个点，$0 \leq x_i,y_i \leq 10^7$。随后m次询问子矩形中有多少个点。二维偏序问题，先把询问的矩形拆成四个以原点为左下角的子矩形，然后把点与询问按$x$轴排序。for所有的询问，每到一个询问把$x$轴坐标小于他的点的$y$轴坐标加入到bit中，然后再询问得到的就是$x$与$y$都小于他的点。 Note如果点的范围再扩大得话使用离散化即可，因为点的个数始终是很小的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 500000 + 5;const int N = 1e7+1;int c[N+1],x1,yy,x2,y2,n,m,ans[maxn];struct Point&#123; int x,y,flag,pos; bool operator &lt; (const Point &amp; k)const&#123; if(x!=k.x) return x&lt;k.x; return y&lt;k.y; &#125;&#125;p[maxn],q[maxn&lt;&lt;2];void add(int x,int y)&#123; for(;x&lt;=N;x+=x&amp;(-x))&#123; c[x]+=y; &#125;&#125;int query(int x)&#123; int ans=0; for(;x;x-=x&amp;(-x)) ans+=c[x]; return ans;&#125;int main() &#123; #ifdef LOCAL freopen("bzoj1935.in", "r", stdin); freopen("bzoj1935.out", "w", stdout); #endif scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y);p[i].x+=1;p[i].y+=1; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d%d",&amp;x2,&amp;y2,&amp;x1,&amp;yy);x2+=1;x1+=1;y2+=1;yy+=1; int t=4*(i-1)+1; q[t].x=x1,q[t].y=yy,q[t].flag=1,q[t].pos=q[t+1].pos=q[t+2].pos=q[t+3].pos=i; if(x2-1&amp;&amp;y2-1) q[t+1].x=x2-1,q[t+1].y=y2-1,q[t+1].flag=1; if(x2-1) q[t+2].x=x2-1,q[t+2].y=yy,q[t+2].flag=-1; if(y2-1) q[t+3].x=x1,q[t+3].y=y2-1,q[t+3].flag=-1; &#125; sort(p+1,p+n+1); sort(q+1,q+4*m+1); for(int i=1,j=1;i&lt;=4*m;++i)&#123; while(p[j].x&lt;=q[i].x&amp;&amp;j&lt;=n)&#123; add(p[j].y,1);++j; &#125; ans[q[i].pos]+=(q[i].flag*query(q[i].y)); &#125; for(int i=1;i&lt;=m;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[establish vscode c/c++ environment]]></title>
    <url>%2F2019%2F04%2F19%2Festablishvscodec-c-environment%2F</url>
    <content type="text"><![CDATA[Mingw on Windows之前一直使用VSC自带的Compile&amp;&amp;Run插件，但不能自定义编译参数很难受。 配置所需环境 下载VSCode 下载Mingw(如果有Codeblocks可以使用Codeblocks里的Mingw) 将Mingw的bin加入到环境变量 配置编译器路径这一步将告诉VSC使用哪个编译器对.cpp/.c文件进行编译。 按Ctrl + Shift + P打开命令板。它看起来像这样： 键入“C / C ++”，然后从建议列表中选择“ 编辑配置 ”。VSC创建一个文件c_cpp_properties.json。配置如下。 1234567891011121314151617181920&#123; "configurations": [ &#123; "name": "Win32", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "D:/software/CodeBlocks/MinGW/bin/g++.exe",//换成自己的gcc.exe或者g++.exe "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "gcc-x64"//gcc和g++使用gcc-x64 &#125; ], "version": 4&#125; 创建tasks.json这一步将对源程序进行编译，可以自己设置编译命令以及编译参数。 按Ctrl + Shift + P打开命令板，然后键入“任务”并选择Tasks: Add a default build task 然后选择 Others。VSC将创建一个tasks.json文件并在编辑器中打开它。配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "reveal": "silent", "echo": true, "showReuseMessage": false, "panel": "shared", &#125;, "command": "g++", //编译命令 "args": [ //编译参数 "--std=c++14", "$&#123;file&#125;", //文件路径 "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", //将生成的filename.exe放到与.cpp文件同一文件夹下 //$&#123;fileDirname&#125;为.cpp文件上一级路径，$&#123;fileBasenameNoExtension&#125;为不带扩展的原文件名 "-g", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-D LOCAL" //编译时DEFINE一个LOCAL ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "\\"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125; &#125; ]&#125; 配置调试文件前两步完成之后就可以按F5对文件编译并产生.exe文件了，但是还无法调试，这一步将配置调试信息。 按Ctrl + Shift + D到调试页面，然后再点击上方小齿轮选择GDB\LLDB，VSC将创建一个launch.json文件并打开它。配置如下 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Launch", "preLaunchTask": "build", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", //调试的.exe文件所在位置 "args": [], "stopAtEntry": false, "cwd": "$&#123;fileDirname&#125;", //调试将在此目录也就是文件所在目录下进行，将读取此目录下的in、out文件 "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "D:\\software\\CodeBlocks\\MinGW\\bin\\gdb32.exe", //填写gdb.exe所在路径 "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ]&#125; F5运行由于VSC的弹出框会一闪而逝，所以一般将输入输出重定向，也就是为什么要在tasks.json的编译参数中加上”-D LOCAL“的原因。新建一个test.cpp写上如下代码并运行，发现虽然代码中没有定义LOCAL，但是还是会重定向输入输出，因为在编译时-D命令帮我们完成了”#define LOCAL“的工作。123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int x;int main() &#123; #ifdef LOCAL freopen("test.in", "r", stdin); freopen("test.out", "w", stdout); #endif cin&gt;&gt;x; cout&lt;&lt;x; puts("hh"); return 0;&#125; 编写代码片段由于每个文件都得使用重定向，那每个文件都敲一次显然是很浪费时间的。所以使用VSC提供的代码片段功能节省时间。 点击左下角齿轮并点击用户代码片段，选择cpp.json文件进行配置。 配置文件init片段，每次新建一个文件夹后可以快速补全所有信息。 配置debug片段。 配置好了每次输入acm回车即可将头文件及main函数补充完整，输入debug即可得到”#ifdef LOCAL…#endif”。 12345678910111213141516171819202122232425262728&#123; "ACM-model": &#123; "prefix": "acm", //匹配前缀，当输入这个字符串的前缀时，会有代码补全信息 "body": [ //补全的代码片段 "#include &lt;bits/stdc++.h&gt;", "using namespace std;", "typedef long long ll;", "const int maxn = $&#123;1:100000&#125; + 5;", //补全后的代码光标会停在$1处 "$2\nint main() &#123;", //按一次tab键后光标转移到$2处 "\t#ifdef LOCAL", "\t\tfreopen(\"$&#123;TM_FILENAME_BASE&#125;.in\", \"r\", stdin);", //$&#123;TM_FILENAME_BASE&#125;是提供的变量，得到不带后缀的文件名 "\t\tfreopen(\"$&#123;TM_FILENAME_BASE&#125;.out\", \"w\", stdout);", "\t#endif", "\t$0", //$0为按tab键光标的终止位置 "\treturn 0;", "&#125;" ], "description": "init acm model" &#125;, "Debug-model":&#123; "prefix": "debug", "body": [ "#ifdef LOCAL\n\t$0", "#endif" ], "description": "debug" &#125;, &#125; VSC还提供许多变量，并且允许对变量利用re和format转换，有兴趣的可以去官网看。 分屏使用]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 2050 1003]]></title>
    <url>%2F2019%2F04%2F15%2F2019-2050-1003%2F</url>
    <content type="text"><![CDATA[分宿舍描述现在一共有$n+m+2k$个人要住进房间里，包括$n+k$个男生以及$m+k$个女生，其中k对异性男女为情侣。房间有三种类型，双人间$a$元一间，三人间$b$元一间，情侣间$c$元一间。除情侣间外，其他间房都可以不住满。最少花多少钱使得所有人都有房住？ 输入格式一共$T(T \leq 50)$组数据。每组数据输入$6$个整数，分别是$n,m,k,a,b,a$。$0 \leq n,m,k \leq 10^3$, $0 \leq a,b,c \leq 10^9$。 输出格式每行输出一个整数表示最小花费。 样例输入23 0 1 1 3 33 3 2 1 6 2 样例输出36 Solve设$dp[i]$表示前i个人安排双人间和三人间的最优解。先预处理出来$dp$数组，其中$dp[0] = 0$,$dp[1] = min(a, b) = dp[2]$,$dp[3] = min(2 \times a, b)$。输出$max( dp[n+i] + dp[m+i] + (k-i) \times c ),0 \leq i\leq k$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,m,k,a,b,c,dp[2007];int _;ll Min(ll x,ll y)&#123; return x&gt;y?y:x;&#125;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c); dp[0]=0;dp[1]=dp[2]=Min(a,b);dp[3]=Min(2*a,b); for(int i=4;i&lt;=2003;++i)&#123; dp[i]=Min(dp[i-2]+a,dp[i-3]+b); &#125; ll ans=dp[n+k]+dp[m+k]; for(ll i=0;i&lt;k;++i)&#123; ans=Min(ans,dp[n+i]+dp[m+i]+(k-i)*c); &#125; printf("%lld\n",ans); &#125; return 0;&#125;// ll check(ll x)&#123;// ll k=x/3+(x%3==0?0:1);// ll tot=k*b;// for(ll i=0;i&lt;k;++i)&#123;// ll tmp=i*b;// ll p=x-i*3;// ll k1=p/2+(p%2==0?0:1);// tmp+=k1*a;// tot=Min(tot,tmp);// &#125;// return tot;// &#125;// int main()&#123;// scanf("%d",&amp;_);// while(_--)&#123;// ll ans=1e18;// scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c);// for(ll i=0;i&lt;=k;++i)&#123;// ll tmpn=n+i,tmpm=m+i;// ll tmp=(k-i)*c;// tmp+=(check(tmpn)+check(tmpm));// ans=Min(ans,tmp);// &#125;// printf("%lld\n",ans);// &#125;// return 0;// &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ RoundA 3]]></title>
    <url>%2F2019%2F04%2F15%2F2019GCJ-RoundA-3%2F</url>
    <content type="text"><![CDATA[Alien RhymeProblemDuring some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $PROL$ and $TARPOL$ rhyme if the accented letter in both is the $O$ or the $L$, but they do not rhyme if the accented letters are the Rs, or the $R$ in $PROL$ and the $P$ in $TARPOL$, or the $O$ in $PROL$ and the $L$ in $TARPOL$. You have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs. You want to know the largest number of words that can be arranged into pairs in this way. InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string Wi of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the size of the largest subset of words meeting the criteria described above. Limits$1 \leq T \leq 100.$Time limit: 20 seconds per test set.Memory limit: 1GB.1 $\leq$ length of $W_i \leq 50$, for all $i$.Wi consists of uppercase English letters, for all $i$.$W_i \not= W_j$, for all $i \not= j$. (Words are not repeated within a test case.) Test set 1 (Visible)$2 \leq N \leq 6$. Test set 2 (Hidden)$2 \leq N \leq 1000.$ Sample Input42TARPOLPROL3TARPORPROLTARPRO6CODEJAMJAMHAMNALAMHUMNOLOM4PIHIWIFI OutputCase #1: 2Case #2: 0Case #3: 6Case #4: 2 Solve给定$n$个字符串，如果两个字符串有相同的后缀，那么后缀开始的那个字母就被这两个字符串所使用并且其它对字符串不能使用。问怎样使得对数最多。把每个字符串从后向前构建字典树，然后从下往上$dp$一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int _,tree[5007][26],cnt,val[5007];char s[57];void insert()&#123; int len=strlen(s),root=0; for(int i=len-1;i&gt;=0;--i)&#123; // cout&lt;&lt;root&lt;&lt;endl; if(!tree[root][s[i]-'A']) tree[root][s[i]-'A']=++cnt; root=tree[root][s[i]-'A']; // cout&lt;&lt;root&lt;&lt;endl; &#125; val[root]=1;&#125;int dp[5007],flag[5007],ans;void dfs(int u)&#123; if(val[u]) ++dp[u]; for(int i=0;i&lt;26;i++)&#123; if(tree[u][i])&#123; dfs(tree[u][i]); dp[u]+=dp[tree[u][i]]; if(dp[u]&gt;=2&amp;&amp;!flag[u]&amp;&amp;u!=0)&#123; flag[u]=1;++ans;dp[u]-=2; &#125; &#125; &#125; return ;&#125;int main()&#123; scanf("%d",&amp;_); for(int i=1;i&lt;=_;++i)&#123; memset(dp,0,sizeof(dp)); memset(flag,0,sizeof(flag)); memset(val,0,sizeof(val)); memset(tree,0,sizeof(tree));ans=cnt=0; int n; scanf("%d",&amp;n); for(int j=1;j&lt;=n;j++)&#123; scanf("%s",s); // cout&lt;&lt;s&lt;&lt;endl; insert(); &#125; dfs(0); cout&lt;&lt;"Case #"&lt;&lt;i&lt;&lt;": "; printf("%d\n",ans*2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces 609 E]]></title>
    <url>%2F2019%2F04%2F08%2Fcf609E%2F</url>
    <content type="text"><![CDATA[Minimum spanning tree for each edgeProblemConnected undirected weighted graph without self-loops and multiple edges is given. Graph contains n vertices and m edges. For each edge $(u, v)$ find the minimal possible weight of the spanning tree that contains the edge $(u, v)$. The weight of the spanning tree is the sum of weights of all edges included in spanning tree. InputFirst line contains two integers $n$ and $m$ $(1 \leq n \leq 2·10^5, n - 1 \leq m \leq 2·10^5)$ — the number of vertices and edges in graph. Each of the next $m$ lines contains three integers $u_i, v_i, w_i (1 \leq u_i, v_i \leq n, u_i \not= v_i, 1 \leq w_i \leq 10^9)$ — the endpoints of the i-th edge and its weight. OutputPrint $m$ lines. i-th line should contain the minimal possible weight of the spanning tree that contains i-th edge. The edges are numbered from $1$ to $m$ in order of their appearing in input. Examples input 5 71 2 31 3 11 4 52 3 22 5 33 4 24 5 4 output98118889 Solve先求出原图的最小生成树，如果边在最小生成树中则直接输出最小生成树的权值。否则输出MST权值减去这条边的两端点路径上的最大边再加上这条边的权值即可。倍增LCA寻找路径上的最大边即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+7;int flag[N&lt;&lt;1],head[N],cnt,n,m,f[N];int grade[N][24],dep[N];ll mx[N][24];struct edge&#123; int next,v;ll w;&#125;e[N&lt;&lt;1];struct ed&#123; int u,v,id;ll w; bool operator &lt; (const ed &amp; k)const&#123; return w&lt;k.w; &#125;&#125;e1[N&lt;&lt;1];void init()&#123; for(int i=1;i&lt;=n;i++) f[i]=i; cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].w=w;e[cnt].next=head[u]; head[u]=cnt;&#125;ll ans;int find(int x)&#123; return x==f[x]?x:f[x]=find(f[x]);&#125;void kruskal()&#123; sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int u=e1[i].u,v=e1[i].v;ll w=e1[i].w; // cout&lt;&lt;u&lt;&lt;" y "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; int fx=find(u),fy=find(v); if(fx!=fy)&#123; //cout&lt;&lt;u&lt;&lt;" x "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; flag[i]=1; ans+=w; f[fx]=fy; add(v,u,w);add(u,v,w); &#125; &#125;&#125;void dfs(int u,int fa,int deep)&#123; dep[u]=deep; for(int i=1;i&lt;24;i++)&#123; grade[u][i]=grade[grade[u][i-1]][i-1]; mx[u][i]=max(mx[u][i-1],mx[grade[u][i-1]][i-1]); &#125; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; grade[v][0]=u;mx[v][0]=w; dfs(v,u,deep+1); &#125; return ;&#125;ll lca(int x,int y)&#123; ll tmp=0; if(dep[x]&gt;dep[y]) swap(x,y); for(int i=23;i&gt;=0;--i)&#123; if(dep[x]&lt;dep[y]&amp;&amp;dep[grade[y][i]]&gt;=dep[x])&#123; tmp=max(tmp,mx[y][i]); y=grade[y][i]; &#125; &#125; for(int i=23;i&gt;=0;--i)&#123; if(grade[x][i]!=grade[y][i])&#123; tmp=max(tmp,max(mx[x][i],mx[y][i])); x=grade[x][i];y=grade[y][i]; &#125; &#125; if(x!=y) tmp=max(tmp,max(mx[x][0],mx[y][0])); return tmp;&#125;ll a[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++)&#123; int from,to;ll val; scanf("%d%d%lld",&amp;from,&amp;to,&amp;val); e1[i].u=from,e1[i].v=to,e1[i].w=val;e1[i].id=i; &#125; kruskal(); dfs(1,-1,0); for(int i=1;i&lt;=m;++i)&#123; if(flag[i])&#123; a[e1[i].id]=ans; &#125; else&#123; a[e1[i].id]=ans-lca(e1[i].u,e1[i].v)+e1[i].w; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%lld\n",a[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2222]]></title>
    <url>%2F2019%2F04%2F07%2Fhdu2222%2F</url>
    <content type="text"><![CDATA[Keywords SearchProblem DescriptionIn the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. ($N \leq 10000$)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than $1000000$. OutputPrint how many keywords are contained in the description. Sample Input 15shehesayshrheryasherhs Sample Output 3 Solve这道题是$AC$自动机的经典例题，给$n$个模式串与一个主串，问有多少个模式串出现在主串中。直接构建带$fail$指针的$trie$图然后再在自动机上跑匹配即可，需要注意的是到达一个节点需要找到所有它的前缀也即一直跑$fail$指针直到失配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+7;int _,n;int val[N],tree[N][26],fail[N],cnt;char s[N],p[N];void init()&#123; memset(tree,0,sizeof(tree)); memset(fail,0,sizeof(fail)); memset(val,0,sizeof(val)); cnt=0;&#125;void insert()&#123; int root=0,len=strlen(s); for(int i=0;i&lt;len;++i)&#123; if(!tree[root][s[i]-'a']) tree[root][s[i]-'a']=++cnt; root=tree[root][s[i]-'a']; //cout&lt;&lt;root&lt;&lt;endl; &#125; ++val[root]; return ;&#125;void build()&#123; queue&lt;int&gt; q; for(int i=0;i&lt;26;++i)&#123; if(tree[0][i])&#123; fail[tree[0][i]]=0; q.push(tree[0][i]); &#125; &#125; while(!q.empty())&#123; int now=q.front();q.pop(); //cout&lt;&lt;now&lt;&lt;endl; for(int i=0;i&lt;26;++i)&#123; if(tree[now][i])&#123; fail[tree[now][i]]=tree[fail[now]][i]; q.push(tree[now][i]); &#125; else tree[now][i]=tree[fail[now]][i]; &#125; &#125; return ;&#125;int find()&#123; int ans=0; int root=0,len=strlen(p); for(int j=0;j&lt;len;++j)&#123; while(root&amp;&amp;!tree[root][p[j]-'a']) root=fail[root]; root=tree[root][p[j]-'a']; //cout&lt;&lt;root&lt;&lt;endl; int now=root; while(now)&#123; ans+=val[now]; val[now]=0; now=fail[now]; &#125; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s); insert(); &#125; build(); scanf("%s",p); printf("%d\n",find()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ_QualificationRound_2]]></title>
    <url>%2F2019%2F04%2F07%2F2019GCJ-QualificationRound-2%2F</url>
    <content type="text"><![CDATA[You Can Go Your Own WayProblemYou have just entered the world’s easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid. You are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above! As an original thinker, you do not want to reuse any of Lydia’s moves. Specifically, if her path includes a unit move from some cell $A$ to some adjacent cell $B$, your path cannot also include a move from $A$ to $B$. (However, in that case, it is OK for your path to visit $A$ or visit $B$, as long as you do not go from $A$ to $B$.) Please find such a path. In the following picture, Lydia’s path is indicated in blue, and one possible valid path for you is indicated in orange: InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string P of $2N - 2$ characters, each of which is either uppercase $E$ (for east) or uppercase $S$ (for south), representing Lydia’s valid path through the maze. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a string of $2N - 2$ characters each of which is either uppercase $E$ (for east) or uppercase $S$ (for south), representing your valid path through the maze that does not conflict with Lydia’s path, as described above. It is guaranteed that at least one answer exists. Limits1 $\leq$ T $\leq$ 100.Time limit: 15 seconds per test set.Memory limit: 1GB.P contains exactly N - 1 E characters and exactly N - 1 S characters. Test set 1 (Visible)2 $\leq$ N $\leq$ 10. Test set 2 (Visible)2 $\leq$ N $\leq$ 1000. Test set 3 (Hidden)For at most 10 cases, 2 $\leq$ N $\leq$ 50000.For all other cases, 2 $\leq$ N $\leq$ 10000. Sample Input 22SE5EESSSESE Output Case #1: ESCase #2: SEEESSES Solve将输入从后向前反着输出即可。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;string s,s1;int n;stack&lt;char&gt; st;int main()&#123; int c; cin&gt;&gt;c; for(int ca=1;ca&lt;=c;++ca)&#123; while(!st.empty())st.pop(); cin&gt;&gt;n&gt;&gt;s; int x,y,tot;x=y=tot=0; for(int i=s.length()-1;i&gt;=0;--i)&#123; if(s[i]=='S') st.push('E'); if(s[i]=='E') st.push('S'); &#125; cout&lt;&lt;"Case #"&lt;&lt;ca&lt;&lt;": "; while(!st.empty())&#123; cout&lt;&lt;st.top();st.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>water</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ_QualificationRound_1]]></title>
    <url>%2F2019%2F04%2F07%2F2019GCJ-QualificationRound-1%2F</url>
    <content type="text"><![CDATA[Foregone SolutionProblemSomeone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a $4$… and the $4$ key on the keyboard of our oversized check printer is broken. Fortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a $4$, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions. InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$. OutputFor each test case, output one line containing Case #x: A B, where x is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them. (See “What if a test case has multiple correct solutions?” in the Competing section of the FAQ. This information about multiple solutions will not be explicitly stated in the remainder of the 2019 contest.) Limits1 $\leq$ T $\leq$ 100.Time limit: 10 seconds per test set.Memory limit: 1GB.At least one of the digits of N is a 4. Test set 1 (Visible)1 &lt; N &lt; $10^5$. Test set 2 (Visible)1 &lt; N &lt; $10^9$. Solving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights! Test set 3 (Hidden)1 &lt; N &lt; $10^{100}$. Sample Input 349404444 Output Case #1: 2 2Case #2: 852 88Case #3: 667 3777 Solve将原数字中所有的$4$变成$1$和$3$即可。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int _; string s,s1;int tot=0; cin&gt;&gt;_; while(_--)&#123; cin&gt;&gt;s;s1.clear(); int pos; for(int i=0;i&lt;s.length();++i)&#123; if(s[i]=='4')&#123; pos=i;break; &#125; &#125; //cout&lt;&lt;pos&lt;&lt;endl; cout&lt;&lt;"Case #"&lt;&lt;++tot&lt;&lt;": "; for(int i=pos;i&lt;s.length();++i)&#123; if(s[i]=='4')&#123; s1.push_back('1'); s[i]='3'; &#125; else s1.push_back('0'); &#125; cout&lt;&lt;s&lt;&lt;" ";int cnt=0; for(int i=pos;i&lt;s.length();++i)&#123; cout&lt;&lt;s1[cnt++]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>water</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒟蒻ACM退役贴&&总结]]></title>
    <url>%2F2019%2F03%2F31%2Fjuruo%2F</url>
    <content type="text"><![CDATA[我来过，未征服。我走了，还有千千万个我。 收获 学会写代码 2018 ACM-ICPC 焦作区域赛铜牌 2018 ACM-ICPC EC-Final铜牌 2018 CCPC 吉林区域赛铜牌 2018 ACM-ICPC 西安邀请赛铜牌 2019 CCCC天梯赛 华山论剑团队国二 2019 CCCC天梯赛 华山论剑学校北京市特等奖 2018 CCCC天梯赛 华山论剑团队国二 CCFCSP认证 单次前1.7% 学校在XCPC拿银 CCFCSP 350分|总排名前1% 某桥杯进一次国赛 天梯赛 200分 初识第一次参加宣讲会与新生赛&emsp;&emsp;初入大学的我参加的第一次宣讲会就是学院社团招新的宣讲会，在这一次宣讲会上成功加入了心心念念已久的足球队。但是有一个新鲜事物映入了我的眼帘–“ACM爱好者协会”。还很懵懂的我听见斌哥在台上讲着协会的历史，不知怎的有一种中二的热血感。当听到迄今为止协会最好成绩还只是铜牌的，什么都还不懂的我暗暗自语道一定要拿一块银牌，想必当时所有的人都是这种感觉吧^_^。宣讲的最后斌哥的那句暂不招新可以说是营造了十足的神秘感，超级炫酷！但好像这次宣讲会之后ACM就从生活中消失了，就买了几本书带着看，自己也没有去刷题啊什么的。&emsp;&emsp;可能从A协11月正式的宣讲会以及随之而来的新生赛，我才算正式开始了自己的算法竞赛生涯吧。新生赛的题感觉很友好的，那时的我都能做出几道题并拿到二等奖，虽然被很多人踩，还是很开心，毕竟是大学生活的第一个奖。梦想便从这时启航~ 寒假集训&amp;&amp;问题求解与编程&amp;&amp;暑假集训 寒假集训&emsp;&emsp;只记得第一天是教使用STL，第二天好像我就溜了，思乡心切xxx。可能这就是蒟蒻吧。 问题求解与编程&emsp;&emsp;这是一门大一下的专选课，任课老师是A协教练徐老师，自己也没想到以后还会和徐老师有更多交集。这个课让我学会了贪心、分治、搜索、dp。还熟悉了oj的使用，简直爽的飞起。也是从这学期开始自己开始买各种书看，刷一些很水很水的题，打一些其他学校的校赛，虽然好像打了两场校赛都爆零了给幼小的心灵造成严重的打击。不过却让自己认识到了自己的蒟蒻水平。也是在这学期坚定了要转专业的决心(只是院内转)。 暑假集训&emsp;&emsp;暑假集训其实才算真正的入门吧，在此之前不过是在学习C语言与C++罢了。集训的时间很长，长到自己只有二十天的暑假，长到自己感觉机房是自己的家，不过还好有LJY同学的陪伴，这就是一路上有你吧。&emsp;&emsp;每天惯例是上午讲算法，下午一场CF或专题赛。这样日复一日的生活看起来会很枯燥，但其实每天都过的很幸福很充实，因为每天都可以学到新的东西，可能这就是算法的魅力吧。最短路、线段树、KMP等等算法都是在集训中学到的，虽然距离学会还有很远的路要走。(这些算法现在已经是新生大一寒假的集训内容了，还是偏简单的那种)。后来多校合练开始了，自闭的噩梦也开始了，每天下午只能做出一两道题，这都是些什么题啊，也太难了吧，这可能是我第一次多校的唯一记忆。&emsp;&emsp;现在记得的事也不太多了，只记得博哥趁中午休息的时候从公司带了很多雪糕来分发给我们，当时就觉得协会也太暖了吧！！还有自己A掉了一道看起来比较难的最短路(还不是正解的那种)以及十分钟AK掉了线段树专场，导致我旻被我奇骂了好久出原题hhhh。&emsp;&emsp;不出所料的自己被选入了最后的集训队，一想到自己以后可以代表学校去参数了就超级超级兴奋！！！！！选拔结束的当天晚上一群人去聚餐了，认识了之前一起在机房待了一个月却不认识的很多人(属实自闭男孩)。 相守第二次参加宣讲会与新生赛&emsp;&emsp;大二上的时候稀里糊涂的就成了协会的副会长，开始翘课学算法、熬夜打比赛、熬夜刷题，基本所有时间都花在算法上了吧，进步还是挺大的。但其实现在想来学习和算法应该是可以兼顾的吧。第二次参加宣讲会，我校诞生了第一枚金牌(跨过了银牌。我也不再是在台下的那个人，我负责给新生讲解新生赛的规则。而这次新生赛我也不再是做题人而是成了出题人，见证了大一两个OI爷的神仙打架，其中一个每次训练都踩我们这些大二的学长学姐，没想到的是最后我们成了队友。 组队&amp;&amp;寒假训练&emsp;&emsp;按照学校惯例会在寒假之前进行三人组队并在寒假进行队伍合练，本蒟蒻和两个OI爷组了队，成了本队最蒻的人。寒假本来该去给大一的新生们讲算法的，但是因为320过于舒适，便咕咕咕。这次集训zn开了算法专题训练，不过很多东西我都是第一次做，做的很吃力，产生了厌学情绪，很多东西都没有认真做没用认真学，集训一周之后就回家了，定好的学习计划也都没有完成，算是废掉的一个寒假。可惜时间不能重来，现在想想真是后悔。 第一次参加某桥杯&amp;&amp;天梯赛&amp;&amp;邀请赛&emsp;&emsp;新的一学期一开学就是蓝桥杯和天梯赛，作为萌新即将要参加人生中的正式比赛特别兴奋，但却没有因此而好好刷题。大概因为那时我在学算法而且觉得没必要对桥杯和天梯赛刷题，这两个比赛又不是很难。事实证明确实不是很难，自己却打得不好，桥杯只拿了省三，大概集训队都是省二吧？天梯赛虽然在本校十个人中排名第三，但170+的分不算太高。事实证明算法竞赛是不能懈怠的，当你在现役时松懈下来那么码力和思维都会下降的特别快。受到打击之后开始认真学习以前没有吃透的算法，一遍一遍写着模板题，一遍一遍看着算法实现，直到自己完全理解，直到滚瓜烂熟。打基础的过程是不能省略的，否则便不能对一个算法融会贯通。此时觉得自己好像很强了，但再次遭遇打击，邀请赛信心满满要拿个银牌，结果却是铜首铩羽而归。因而整个人还失落了几天，便再次认识到自己的不足，会的东西还是太少了，不应该只拘泥于自己负责的那一小模块所有的算法都应该有掌握才行！ 总结&emsp;&emsp;大二是很重要的一年，基本上成型就应该是在这一年了，不应该有丝毫的怠惰。对于算法的学习也应该是成体系的，而不是杂乱的学习单个的算法，刷书应该是最明智的做法，先刷掉一两本书建立一个良好的知识体系，再查漏补缺学习书中没有但是会用到的算法。而后才是刷自己负责部分的专题，每周的cf、wannafly挑战赛、EOJ月赛等等都要做，碰到自己不会的知识才好强化学习。最重要的是每周一次的三人一机合练，培养默契与配合。另外cf的c、d、e都是可以刷掉的。 结局暑期训练&emsp;&emsp;一个暑假我的身边全是它，它伴我从南到北。两个多校合练，一个wannafly-camp，共27场比赛，近300道高质量题。区域赛中甚至出现了其中的原题。当时的我好像每一场比赛都认真打完并把力所能及的题都补完。多校一定得打、camp一定得参加、题一定得补！少了一步都不行。回学校之后便开始猛刷数据结构，虽然好像这是大多数强校大一新生都能完成得事情，不过两周做了一百多道平均码量100+行得题还是很有成就感的！ 网络赛在每年现场赛之前都会有网络赛选拔出最后的而参赛学校，网络赛&emsp;=&emsp;有没有区域赛打。第一场网络赛我校被教育的明明白白，决定着三场CCPC参数资格的CCPC网络赛我们并没有打进去而且名次还很低。幸好申请到了名额，不然莫得比赛打了。接着是南京、焦作、徐州、青岛、北京的网络赛。南京、焦作都成功入围，北京虽然没打进去但也申请到了一个名额。我记得我焦作原题场好像C了，南京也还行吧。网络赛就是原题满天飞的比赛，只要你题做的够多，你就够强(逃。 吉林&emsp;&emsp;线段树没调出来，就差一点。卒。 南京&emsp;&emsp;网络流被一个trick点坑了，全队全场在演，打铁而归。 焦作&emsp;&emsp;bfs愣是头铁写dij，差点就铁了(雾。 西安&emsp;&emsp;全程很轻松，不上不下。 某桥&amp;&amp;CSP&amp;&amp;天梯&emsp;&emsp;第二年打桥杯以为能拿省一的结果还是被安排了，CSP打的也不符预期，天梯赛中规中矩吧。对于这三个比赛只有一句话，当你和对手实力差距不大时，最大的敌人是粗心和你自己。 食堂排名 第一梯队：&emsp;南航南慕容&emsp;农大北乔峰 第二梯队：&emsp;河南理工胜在物美价廉餐券还多&emsp;北工大超级nice就是饭太少了&emsp;北华大学记不太清了，中规中矩吧 最差&emsp;西瓜大的饭最差，没有之一 技能树 就这些吧，退役蒟蒻准备ky了！每周要用半天学习算法和做题！]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+uWsgi+Django部署网站到linux服务器]]></title>
    <url>%2F2019%2F03%2F31%2FNginx-uWsgi-Django%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E5%88%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[准备工作：安装Mysql和Python3.x注意事项：安装之前，我们需要给默认的Python2.7安装pymysql+Django库，因为后面会出错就是因为未安装这两个库！12pip install pymysql==0.7.10pip install django==1.10.6 安装虚拟环境：提示：因Python3+自带虚拟环境，更简单好用，所以没必要再装一个。在home目录下创建名称为vcmt的虚拟环境。1python3.6 -m venv /home/vcmt 激活虚拟环境：1source /home/vcmt/bin/activate 退出命令：1deactivate 安装Python扩展库：第一步，在已配置好的机器上使用：1pip freeze &gt; requirements.txt 第二步，把生成的requirements.txt文件复制到目标机器上的root目录下。第三步，在目标机器上执行pip install -r requirements.txt，读取文件requirements.txt中的扩展库信息并在本机进行安装。 上传项目到服务器：把Django项目上传到服务器上。 注意：上传项目文件后把 /项目名/app名/migrations/ 下的类似00.. 的记录文件删除，有几个删除几个，但是不要删除别的文件。 修改settings.py文件：123456789101112DEBUG = FalseALLOWED_HOSTS = ['*']STATIC_ROOT = os.path.join(BASE_DIR, 'static')MEDIA_ROOT = os.path.join(BASE_DIR, 'media')STATIC_URL = '/static/' 配置Django项目：安装好Django等必须库后，进入Django项目下，同步并创建数据库，执行：12python manage.py makemigrationspython manage.py migrate 建立后台超级用户：1python manage.py createsuperuser 启动自带的服务器，测试是否可以正常运行！（此时settings.py 中的DEBUG = False）输入：1python manage.py runserver 0.0.0.0:8000 同步静态文件：1python manage.py collectstatic 配置uWsgi：在Django项目主目录下创建uwsgi.ini文件：12345678910111213141516171819202122232425262728293031[uwsgi]# 项目目录chdir=/root/biomass/# 指定项目的applicationmodule=biomass.wsgi:application# 进程个数workers=5pidfile=/root/biomass/script/uwsgi.pid# 指定IP端口#http=:9090# 指定静态文件static-map=/static=/root/biomass/static# 启动uwsgi的用户名和用户组uid=rootgid=root# 启用主进程master=true# 自动移除unix Socket和pid文件当服务停止的时候vacuum=true# 序列化接受的内容，如果可能的话thunder-lock=true# 启用线程enable-threads=true# 设置自中断时间harakiri=30# 设置缓冲post-buffering=4096# 设置日志目录daemonize=/root/biomass/script/uwsgi.log# 指定sock的文件路径socket=127.0.0.1:9090 1234567$ uwsgi --ini uwsgi.ini # 启动uwsgi配置[uwsgi-static] added mapping for /static =&gt; /home/trunk/static # 启动成功$ uwsgi --stop uwsgi.pid # 关闭uwsgisignal_pidfile()/kill(): Operation not permitted [core/uwsgi.c line 1659]$ uwsgi --reload uwsgi.pid #重新加载配置 Nginx配置：Nginx常用命令：123456789$ /etc/init.d/nginx start #启动$ /etc/init.d/nginx stop #关闭$ /etc/init.d/nginx restart #重启$ killall nginx #杀死所有nginx$ nginx -t #检查配置文件是否有错# 如果是生产环境的话Nginx正在运行，就不要直接stop start 或者 restart 直接reload就行了# 对线上影响最低$ /etc/init.d/nginx reload 创建一个xxx.conf配置文件（nginx的默认配置目录为/etc/nginx/conf.d）：1234567891011121314151617181920212223242526server &#123; # 这个server标识我要配置了 listen 80; # 80 是http默认的端口， 443 是https默认的端口（网页一般使用这两个端口） server_name 39.105.157.191 ; # 你访问的路径前面的url名称 access_log /var/log/nginx/access.log; # Nginx日志配置 error_log /var/log/nginx/error.log; # Nginx错误日志配置 charset utf-8; # Nginx编码 gzip on; # 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多 gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; # 支持压缩的类型 error_page 404 /404.html; # 错误页面 error_page 500 502 503 504 /50x.html; # 错误页面 # 指定项目路径uwsgi location / &#123; # 这个location就和咱们Django的url(r'^admin/', admin.site.urls), include /etc/nginx/uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的 uwsgi_connect_timeout 30; # 设置连接uWSGI超时时间 # 指定uwsgi的sock文件所有动态请求就会直接丢给他 uwsgi_pass 127.0.0.1:9090; &#125; # 指定静态文件路径 # location /static/ &#123; # alias /root/biomass/static/; # index index.html index.htm; #&#125;&#125; 启动uWsgi后再启动Nginx即可]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[网络流swust P1736 飞行员配对方案问题题目链接：https://www.oj.swust.edu.cn/problem/show/1736 题意有两种飞行员，一种可以和另一种的几个飞行员配对，求最大匹配。 题解二分图最大匹配问题。 在二分图的基础上增加源$S$和汇$T$，一种飞行员为$X$集合，另一种为$Y$集合。$1$、$S$向$X$集合中每个顶点连一条容量为$1$的有向边。$2$、$Y$集合中每个顶点向$T$连一条容量为$1$的有向边。$3$、$XY$集合之间的边都设为从$A$集合中的点到B集合之中的点，容量为$1$的有向边。求网络最大流，流量就是匹配数，所有满流边是一组可行解。(匈牙利写起来更方便) swust P1737 太空飞行计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1737 题意有 $n$ 个实验，每个实验有收入 $x_{i}$ ，而且实验会使用 $m_i$ 个仪器。每个仪器会有 $y_i$支出。问实施哪些实验并配置哪些仪器使收入最大。 题解最大权闭合图问题，可以转化成最小割问题，进而用最大流解决。 把每个实验看作二分图 $X$ 集合中的顶点，每个设备看作二分图 $Y$ 集合中的顶点，增加源 $S$ 和汇 $T$。1、从 $S$ 向每个 $X_i$ 连接一条容量为该点收入的有向边。2、从 $Y_i$ 向 $T$ 连接一条容量为该点支出的有向边。3、如果一个实验 $i$ 需要设备 $j$ ，连接一条从 $X_i$ 到 $Y_j$ 容量为无穷大的有向边。 统计出所有实验的收入之和$Total$，求网络最大流$Maxflow$，最大收益就是$Total - Maxflow$。对应的解就是最小割划分出的 $S$ 集合中的点，也就是最后一次增广找到阻塞流时能从 S 访问到的顶点。定义一个割划分出的$S$集合为一个解，那么割集的容量之和就是(未被选的 $A$ 集合中的顶点的权值 $+$ 被选的 $B$ 集合中的顶点的权值)，记为$Cut$。 $A$ 集合中所有顶点的权值之和记为$Total$，那么$Total - Cut$就是(被选的 $A$ 集合中的顶点的权值 $-$ 被选的 $B$ 集合中的顶点的权值)，即为我们的目标函数，记为 $A$ 。要想最大化目标函数 $A$ ，就要尽可能使$Cut$小，$Total$是固定值，所以目标函数 $A$ 取得最大值的时候，$Cut$最小，即为最小割。 swust P1738 最小路径覆盖问题题目链接：https://www.oj.swust.edu.cn/problem/show/1738 题意问最少多少条路径可以覆盖一个有向无环图所有的点。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 构造二分图，把原图每个顶点$i$拆分成二分图$X$，$Y$集合中的两个顶点$X_i$和$Y_i$。对于原图中存在的每条边$(i,j)$，在二分图中连接边$(X_i,Y_j)$。然后把二分图最大匹配模型转化为网络流模型，求网络最大流。最小路径覆盖的条数，就是原图顶点数，减去二分图最大匹配数（因为路径长度可为$0$，所以最大路径覆盖数为顶点数，每多一条边则少一个路径覆盖）。沿着匹配边查找，就是一个路径上的点，输出所有路径即可。 swust P1739 魔术球问题题目链接：https://www.oj.swust.edu.cn/problem/show/1739 题意问 $n$ 根柱子一共可以放下多少个球。放球规则为数字从小到大依次放且每根柱子的相邻的两个球的值相加为平方数。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 先从 $1$ 至无穷枚举可能放下多少个球（不能二分，因为二分得重新构图）。一旦数字 $m$ 放不下则结束枚举。可以把所有的球看成有向无环图的点，柱子看成路径。所以问题就成了最小路径覆盖 $m$ 个点。先拆点，枚举的时候每加一个点 $x_i$ 与源点相连， $y_i$ 与汇点相连，再连小于这个点且能与他相加能开方的点的边 $x_i -&gt; y_j$ 。一旦 $m$ 个点覆盖的路径大于 $n$ ，则结束枚举，并输出 $m - 1$ 。 swust P1740 圆桌问题题目链接：https://www.oj.swust.edu.cn/problem/show/1740 题意要把 $n$ 个单位的人安排到 $m$ 个餐桌上（同个餐桌不能有来自相同单位的人）。 题解二分图多重匹配问题，可以用最大流解决。 建立二分图，每个单位为$X$集合中的顶点，每个餐桌为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$顶点连接一条容量为该单位人数的有向边。2、从每个$Y_i$顶点向$T$连接一条容量为该餐桌容量的有向边。3、$X$集合中每个顶点向$Y$集合中每个顶点连接一条容量为$1$的有向边（每个单位只能有一个人去一个餐桌）。求网络最大流，如果最大流量等于所有单位人数之和，则存在解，否则无解。对于每个单位，从$X$集合对应点出发的所有满流边指向的$Y$集合的顶点就是该单位人员的安排情况（一个可行解）。 swust P1741 最长递增子序列问题题目链接：https://www.oj.swust.edu.cn/problem/show/1741 题意计算序列的最长递增子序列的长度 $s$ 。 并给出序列中最多可取出多少个长度为 $s$ 的递增子序列。如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列。 题解分层图问题，可用最大流解决。 先 $dp$ 出每个 $i$ 的最长递增子序列 $F[i]$ 。对于规则$1$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。对于规则$2$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。（ $1$ 与 $n$ 点容量为无穷）。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。求最大流。 swust P1742 试题库问题题目链接：https://www.oj.swust.edu.cn/problem/show/1742 题意试题库中有 $n$ 道题（每道题各有几种属性，共有 $k$ 种属性），现在每种类型各需要 $m_i$ 道题共 $m$ 道题组成一套试卷，问是否能组成，能的话输出选择的题目。 题解二分图多重匹配问题，用最大流解决。 建立二分图，每个类别为$X$集合中的顶点，每个题为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$连接一条容量为该类别所需数量的有向边。2、从每个$Yi$向$T$连接一条容量为$1$的有向边。3、如果一个题$i$属于一个类别$j$，连接一条从$X_j$到$Y_i$容量为$1$的有向边。求网络最大流，如果最大流量等于所有类别所需之和，则存在解，否则无解。对于每个类别，从$X$集合对应点出发的所有满流边，指向的$B$集合中的顶点就是该类别的所选的题（一个可行解）。 swust P1744 方格取数题目链接：https://www.oj.swust.edu.cn/problem/show/1744 题意一个方格取出一些数（所有的数都不想邻）的和最大。 题解选出的点满足任意两个都不相邻，这是点独立集的概念。使选出的总和最大:最大点权独立集。最大点权独立集 = 总点权 - 最小点权覆盖集 = 总点权 - 最小割 = 总点权 - 最大流。取得数总和最大转化为不取的损失最小。所以问题即可以转化为割掉最小的边，使原图不连通（即找不出方格中相邻且二分图中有边相连的点）。 把棋盘黑白染色。对于黑色的，连接源点，容量为格子中的数。对于白色的，连接汇点，容量为格子中的数。然后把所有黑点和相邻的白点连边，容量无穷大。于是我们构造出了一个二分图。题目说不能取相邻的格子，那么对于这张二分图来说，就不能让他有一条边有流经过（否则就取了两个相邻的格子了）。于是求最小割即可。等于求最大流。最后用总和减去最小割即可。 swust P1745 餐巾计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1745 题意一个餐厅 $n$ 天里每天都需要 $x$ 餐巾，可以选择花费 $p$ 元购买新的，也可以选择将已有的花 $s$ 元送去慢洗 $m$ 天，或者花 $f$ 元送去快洗 $k$ 天，或者延期洗。要花费最小。 题解最小费用最大流问题。 将 $n$ 天拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与源点相连，容量为 $x$，花费为 $0$。将 $y_i$ 与汇点相连，容量为 $x$，花费为 $0$。将 $x_i$ 与 $y_i + m$ 相连，容量无穷，费用为 $s$ 。将 $x_i$ 与 $y_i + k$ 相连，容量无穷，费用为 $f$ 。将 $x_i$ 与 $x_i + 1$ 相连，容量无穷，费用为 $0$ 。将源点与 $y_i$ 相连，容量为无穷，费用为 $p$。求最小费用最大流。 swust P1746 航空路线问题题目链接：https://www.oj.swust.edu.cn/problem/show/1746 题意给一幅图，求从最西边到最东边再回到最西边经过的城市最多。（除了起点其他城市只能走一次） 题解最大费用最大流问题。 将 $n$ 个城市拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ ，费用为 $1$ 。起点与终点容量为 $2$ 。（如果这个点流量为 $1$ ，表示这个点被使用。）如果两城市相连则连接 $x_i$ 与 $y_j$ ，容量为 $1$ ，费用为 $0$ 。从起点到终点跑最小费用最大流。 swust P1748 星际转移问题题目链接：https://www.oj.swust.edu.cn/problem/show/1748 题意人得借助 $m$ 艘太空船（容量限定）与 $n$ 个空间站从地球转移到月球，每艘太空船每天有规律的停靠在某个空间站，问最少多少天转移所有人。 题解分层图网络流问题，枚举答案。 我们把网络优化问题转化为枚举答案+可行性判定问题。枚举天数，按天数把图分层，因为乘船每坐一站天数都要增加一，把太空船航线抽象成图中的一条边，跨图的两层。由于太空船容量有限，边上也要加上容量限制。除了坐船以外，人还可以在某个空间站等待下一班太空船的到来，所以每个点要与下一层同一点连接一条容量为无穷的边。 从源点向每一天的地球链接一条容量无穷的边。从每一天的月亮向汇点链接一条容量无穷的边。从上一天的每一个节点向当天的对应节点链接一条容量无穷的边（因为人们可以留在中转站等一等）。针对每一艘飞船，获取其上一天的位置，再获取这一天的位置，在这两个点之间连一条容量为飞船满载人数的流。每次新加一天然后跑到最大流超过$k$即可。至于无解的情况只要当$ans$达到一个很大的值的时候跳出来即可。 swust P1751 数字梯形问题题目链接：https://www.oj.swust.edu.cn/problem/show/1751 题意梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。规则1：从梯形的顶至底的 $m$ 条路径互不相交。规则2：从梯形的顶至底的 $m$ 条路径仅在数字结点处相交。规则3：从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 题解求图的最大权不相交路径及其变种，用最大费用最大流解决。 把梯形每个位置拆点为 $x_i$ 与 $y_i$ 。（因为要保证每个点只能用一次）$x_i$ 与 $y_i$ 相连容量为 $1$ ，费用为点值。从一点向它的左下或右下（ $y_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为 $0$ 的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为 $1$ ，费用为 $0$。 对于规则 $2$ ，不用拆点，因为不限制点的使用。从一点向它的左下或右下（ $x_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为点值的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为无穷，费用为点值。（无穷因为不限制点的使用）对于规则 $3$ ，只需要把规则 $2$ 中除了第一层与源点连边之外的边容量全部改为无穷大。（因为不限制边的使用） swust P1752 运输问题题目链接：https://www.oj.swust.edu.cn/problem/show/1752 题意把 $m$ 个仓库的 $a_i$ 货物运送到 $n$ 个需求为 $b_i$ 的商店去，第 $i$ 个仓库运到第 $j$ 个商店的费用为 $c_{ij}$ 。求最小与最大费用。 题解费用流问题。 把所有仓库看做二分图中顶点$X_i$，所有零售商店看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为仓库中货物数量$a_i$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为商店所需货物数量$b_i$，费用为$0$的有向边。从每个Xi向每个$Y_j$连接一条容量为无穷大，费用为$c_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少运费，求最大费用最大流，最大费用流值就是最多运费。 swust P1753 分配问题题目链接：https://www.oj.swust.edu.cn/problem/show/1753 题意$n$ 个人需要工作，第 $i$ 个人需要第 $j$ 个工作的工资为 $c_{ij}$。求最小与最大费用。 题解费用流问题。 把所有人看做二分图中顶点$X_i$，所有工作看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为$1$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为$1$，费用为$0$的有向边。从每个$X_i$向每个$Y_j$连接一条容量为无穷大，费用为$C_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少工资，求最大费用最大流，最大费用流值就是最多工资。 swust P1754 负载平衡问题题目链接：https://www.oj.swust.edu.cn/problem/show/1754 题意有 $n$ 个环形仓库存着不同的货物，求最小步数使得所有仓库货物相等。 题解费用流问题。 首先求出所有仓库存货量平均值，设第$i$个仓库的盈余量为$A[i]$，$A[i] = $第$i$个仓库原有存货量 $-$ 平均存货量。建立二分图，把每个仓库抽象为两个节点$X_i$和$Y_i$。增设附加源$S$汇$T$。如果$A[i]&gt;0$，从$S$向$X_i$连一条容量为$A[i]$，费用为$0$的有向边。（有盈余）如果$A[i]&lt;0$，从$Y_i$向$T$连一条容量为$-A[i]$，费用为$0$的有向边。（需添加）每个$X_i$向两个相邻顶点$j$，从$X_i$到$X_j$连接一条容量为无穷大，费用为$1$的有向边，从$X_i$到$Y_j$连接一条容量为无穷大，费用为$1$的有向边。（旁边可能是终点，也可能是中转站）求最小费用最大流，最小费用流值就是最少搬运量。 swust P1755 深海机器人问题题目链接：https://www.oj.swust.edu.cn/problem/show/1755 题意深海资源考察探险队的潜艇将到达深海的海底进行科学考察。潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物的标本只能采集一次。本题限定深海机器人只能从其出发的位置沿着向北或者向东方向移动，而且多个深海机器人可以在同一时间占据同一位置。 题解费用流问题。 把网格中每个位置抽象成网络中一个节点，建立附加源$S$汇$T$。对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为$1$ ，费用为该边价值的有向边。（每个点的价值只能使用一次）对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为无穷大，费用为$0$ 的有向边。（多个机器人可同时在同点，不限制点的使用）从$S$到每个出发点$i$连接一条容量为该点出发的机器人数量，费用为$0$的有向边。从每个目标点$i$到$T$连接一条容量为可以到达该点的机器人数量，费用为$0$的有向边。求最大费用最大流，最大费用流值就采集到的生物标本的最高总价值。 poj P1149 PIGS题目链接：http://poj.org/problem?id=1149 题意有 $m$ 个猪圈与 $n$ 个客人，每个客人可以到 $k$ 个猪圈买猪，最多可以买 $x$ 头猪，（每个顾客走后他所打开的猪圈里的猪可以任意交换）求所有顾客最多可以买多少猪。 题解最大流 可以想到每个猪圈都有第一个顾客，后面的顾客可以拿的数量取决于前面的顾客所拿的数量，所以就单个猪圈而言，当前顾客可拿量取决于上一个顾客。所以可以拿同一个猪圈的顾客 $i$ 与 $i + 1$ 连边，边权为无穷。这样除每个猪圈第一顾客后的所有顾客都有了猪的来源，再将每个猪圈的第一个顾客与源点连边，边权为猪圈中猪数量，这样第一个顾客也有了猪的来源。再将每个顾客与汇点连边，边权为其最多可买的猪的数量。跑一次最大流即为答案。 poj P2391 Ombrophobic Bovines题目链接：http://poj.org/problem?id=2391 题意有 $n$ 个牛棚，每个牛棚有其牛的数量与其容量，现在下雨了，求最少的时间把所有的牛放到牛棚里。 题解最大流 先用 $floyd$ 求出每个点之间的最短路，那么时间限制了点对之间是否可以连边。二分时间，拆点与源汇连边，如果两点间的距离小于等于时间则连边。如果跑出满流证明时间可满足。最后通过二分求出答案。 2017urumuqi j题目链接： 题意从一个点经过另一个点到一个点的最小费用（每个点只能经过一次）。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量除中转点外都为 $1$ ，中转点容量为 $2$ 。再把图上有的边连上，费用为边权，容量为无穷。源点与起点终点连接，容量为 $1$ ，费用为 $0$ ；汇点与中转点连接，容量为 $2$ ，费用为 $0$ 。如果流量为 $2$ ，则答案为费用，否则输出 $-1$ 。 2017qingdao k题目链接： 题意上一题的复杂版，从西安到上海后再从上海到青岛，最后从青岛返回上海。上海有两个机场，其中从西安到是到浦东机场到虹桥机场到青岛，青岛回上海是回虹桥机场。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量青岛及虹桥容量为 $2$ ，其余点容量都为 $1$ 。再把图上有的无向边连上，费用为边权，容量为无穷。源点与西安、青岛连接，西安容量为 $1$ ，青岛容量为 $2$ ，费用为 $0$ ；汇点与虹桥及浦东连接，虹桥容量为 $2$ ，浦东容量为 $1$ ，费用为 $0$ 。如果流量为 $3$ ，则答案为费用，否则输出 $-1$ 。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin America I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAmeIImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 给一幅联通图，$q$次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int tot,cnt,head[M],f[M];ll ans;struct edge&#123; int v,next;ll w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v;ll w; edge1()&#123;&#125; edge1 (int u1,int v1,ll w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; tot=ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int sz[M],dep[M],fat[M],son[M],rnk[M],id[M],top[M];ll val[M];void dfs(int u,int fa,int d)&#123; sz[u]=1;dep[u]=d;son[u]=-1,fat[u]=fa; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; val[v]=w; dfs(v,u,d+1); sz[u]+=v; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fat[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=val[rnk[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;ll query(int x,int y)&#123; int fx=top[x],fy=top[y];ll res=0; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; res=max(res,seg.query(id[fx],id[x],1,n,1)); x=fat[fx],fx=top[x]; &#125; else&#123; res=max(res,seg.query(id[fy],id[y],1,n,1)); y=fat[fy],fy=top[y]; &#125; &#125; if(x==y) return res; if(dep[x]&gt;dep[y]) res=max(res,seg.query(id[son[y]],id[x],1,n,1)); else res=max(res,seg.query(id[son[x]],id[y],1,n,1)); return res;&#125;void solve()&#123; dfs(1,-1,0);dfs1(1,1);seg.build(1,n,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%lld\n",ans); else&#123; printf("%lld\n",ans-query(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%lld",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Moscow Subregional C Carpet]]></title>
    <url>%2F2019%2F03%2F29%2F2017MoscowSubregionalCCarpet%2F</url>
    <content type="text"><![CDATA[2017 Moscow Subregional C Carpethttps://vjudge.net/contest/260542#problem/C 给一个 $1000000 \times 20$ 的格子图，要求找一种方式把一颗不超过 $100000$ 个节点的树放到格子图里，并且没有边交叉。考虑把树剖分，因为不超过对数条数的链，所以依次把重链放到一列中，轻链放到下一列即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;int n;int cnt,head[M];int sz[M],f[M],son[M],x[M],y[M],tmp[M];struct edge&#123; int v,next;&#125;e[M&lt;&lt;1];void init()&#123; cnt=0;memset(head,-1,sizeof(head));memset(tmp,0,sizeof(tmp));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=1,f[u]=fa,son[u]=-1; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int z)&#123; y[u]=z;x[u]=++tmp[z]; if(son[u]==-1) return; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,z+1); &#125; dfs1(son[u],z); return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1);dfs1(1,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n", x[i],y[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5242]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5242%2F</url>
    <content type="text"><![CDATA[hdu 5242 Gamehttp://acm.hdu.edu.cn/showproblem.php?pid=5242 给一棵点权树，问从根节点出发$k$次最多能获得多少能量。同一个点的能量只能获取一次。每次从根节点出发肯定要走到叶子节点才是最优的选择。而且每次都要走的是上一次走完后的能量最多的路径。很容易想到按点权把树剖分成轻重链。每一条链都是从叶子到某个节点的，所以当重链被选择后，最重的轻链便成了重链，所以只要把剖分出的前 $k$ 条链的能量相加即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;int _,n,k,cas=1;int cnt,head[M],tot;struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];int son[M],f[M];ll sz[M],a[M],tmp[M],ans[M];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=a[u];son[u]=-1;f[u]=fa; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); if(sz[v]&gt;sz[son[u]]||son[u]==-1)&#123; sz[u]=sz[u]-sz[son[u]]+sz[v]; son[u]=v; &#125; &#125;&#125;void dfs1(int u,ll w)&#123; tmp[u]=a[u]+w; if(son[u]==-1)&#123; ans[++tot]=tmp[u]; return ; &#125; dfs1(son[u],tmp[u]); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,0); &#125; return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1); // for(int i=1;i&lt;=n;i++) printf("%d %d\n",f[i],son[i]); dfs1(1,0); ll res=0; printf("Case #%d: ",cas++); if(k&gt;tot)&#123; for(int i=1;i&lt;=tot;i++) res+=ans[i]; printf("%lld\n",res); &#125; else&#123; sort(ans+1,ans+1+tot); for(int i=tot;i&gt;tot-k;i--) res+=ans[i]; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wannafly day1 I]]></title>
    <url>%2F2019%2F03%2F29%2Fwannafly-day1-I%2F</url>
    <content type="text"><![CDATA[wannafly_day1_I.cpphttp://newoj.acmclub.cn/contests/1389/problem/8 给一棵树，给出 $m$ 次染色，问每个点的第 $k$ 次染色是什么颜色。倒着做，用线段树维护区间染色的最大次数，如果有 $k - 1$次的区间存在，就找到那个点把它的颜色更新，并把它的染色次数变为 $-inf$。复杂度 $O(nlog(n)^2)$，注意下 $update$ 的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 1e5+7;const int inf = 2147483647;int n,m,k;int tot,cnt,head[M];int sz[M],f[M],son[M],dep[M],rnk[M],top[M],id[M];int lazy[M&lt;&lt;2],mx[M&lt;&lt;2],ans[M];struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));memset(ans,0,sizeof(ans));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int d)&#123; sz[u]=1,f[u]=fa,son[u]=-1,dep[u]=d; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u,d+1); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return ; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]);&#125;void pushdown(int rt,int l,int r)&#123; if(lazy[rt]&gt;0)&#123; int v=lazy[rt]; lazy[rt]=0; mx[r]+=v;lazy[r]+=v; mx[l]+=v;lazy[l]+=v; &#125; return ;&#125;void build(int l,int r,int rt)&#123; mx[rt]=0;lazy[rt]=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int l,int r,int rt,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(mx[rt]==k-1)&#123; if(l==r)&#123; mx[rt]=-inf,ans[rnk[l]]=v,lazy[rt]=0; &#125; else&#123; pushdown(up); int mid=(l+r)&gt;&gt;1; if(mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); &#125; &#125; else mx[rt]++,lazy[rt]++; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(R&gt;mid&amp;&amp;mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); return ;&#125;void query(int x,int y,int v)&#123; int fx=top[x],fy=top[y]; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; update(id[fx],id[x],1,n,1,v); x=f[fx],fx=top[x]; &#125; else&#123; update(id[fy],id[y],1,n,1,v); y=f[fy],fy=top[y]; &#125; &#125; if(dep[x]&gt;dep[y]) update(id[y],id[x],1,n,1,v); else update(id[x],id[y],1,n,1,v);&#125;int qu[M],qv[M],qc[M];int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); init(); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); build(1,n,1); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1,1); dfs1(1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;qu[i],&amp;qv[i],&amp;qc[i]); &#125; for(int i=m;i&gt;=1;i--)&#123; query(qu[i],qv[i],qc[i]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin Ame I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-IImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 倍增找两点与$LCA$路径上的最大边权。给一幅联通图，$q$ 次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int ans,cnt,head[M],f[M];int fa[M][26],mx[M][26],dep[M];struct edge&#123; int v,next,w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v,w; edge1()&#123;&#125; edge1 (int u1,int v1,int w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); memset(dep,0,sizeof(dep));memset(fa,0,sizeof(fa));memset(mx,0,sizeof(mx)); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,int w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void dfs(int u,int depth)&#123; dep[u]=depth; int j=1; while ((1&lt;&lt;j)&lt;depth)&#123; fa[u][j]=fa[fa[u][j-1]][j-1]; mx[u][j]=max(mx[u][j-1],mx[fa[u][j-1]][j-1]); j++; &#125; for (int i=head[u];~i;i=e[i].next) if (dep[e[i].v]==0)&#123; int v=e[i].v; fa[v][0]=u;mx[v][0]=e[i].w; dfs(v,depth+1); &#125;&#125;void up(int &amp;u,int step,int &amp;res)&#123; for (int i=0;i&lt;=20;i++) if (step&amp;(1&lt;&lt;i)) &#123; res=max(mx[u][i],res); u=fa[u][i]; &#125; return ;&#125;int work(int u,int v)&#123; int res=0; if (dep[u]&lt;dep[v]) up(v,dep[v]-dep[u],res); else up(u,dep[u]-dep[v],res); for (int i=20;i&gt;=0;i--) if (fa[u][i]!=fa[v][i])&#123; res=max(res,max(mx[u][i],mx[v][i])); u=fa[u][i];v=fa[v][i]; &#125; if (u!=v) res=max(res,max(mx[u][0],mx[v][0])); return res;&#125;void solve()&#123; dfs(1,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%d\n",ans); else&#123; printf("%d\n",ans-work(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%d",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5950]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5950%2F</url>
    <content type="text"><![CDATA[hdu 5950 Recursive sequencehttp://acm.hdu.edu.cn/showproblem.php?pid=5950 $F_1=a,F_2=b。F_n=F_{n-1}+2\times F_{n-2}+n^4$。输入$n$，求$F_n$。用二项式定理把 $n^4$ 拆开，就是裸的矩阵快速幂了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 2147493647;int _;ll n,a,b;struct mat&#123; ll a[8][8]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;7;i++) a[i][i]=1; &#125; mat operator * (const mat &amp; t)const&#123; mat tmp; for(int i=0;i&lt;7;i++) for(int j=0;j&lt;7;j++) for(int k=0;k&lt;7;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=1ll,x.a[0][1]=2ll,x.a[0][2]=1ll,x.a[0][3]=4ll,x.a[0][4]=6ll,x.a[0][5]=4ll,x.a[0][6]=1ll; x.a[1][0]=1ll; x.a[2][2]=1ll,x.a[2][3]=4ll,x.a[2][4]=6ll,x.a[2][5]=4ll,x.a[2][6]=1ll; x.a[3][3]=1ll,x.a[3][4]=3ll,x.a[3][5]=3ll,x.a[3][6]=1ll; x.a[4][4]=1ll,x.a[4][5]=2ll,x.a[4][6]=1ll; x.a[5][5]=1ll,x.a[5][6]=1ll; x.a[6][6]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); if(n==1)&#123; printf("%lld\n",a); continue; &#125; if(n==2)&#123; printf("%lld\n",b); continue; &#125; mat y=matrix_pow(x,n-2ll); printf("%lld\n",((((((y.a[0][0]*b%mod+y.a[0][1]*a%mod)%mod+y.a[0][2]*16ll%mod)%mod+y.a[0][3]*8ll%mod)%mod+y.a[0][4]*4ll%mod)%mod+y.a[0][5]*2ll%mod)%mod+y.a[0][6])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2018程序设计竞赛G]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62018%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BG%2F</url>
    <content type="text"><![CDATA[湘潭大学2018程序设计竞赛Ghttps://www.nowcoder.com/acm/contest/105/G 给一个递推式，$F_i=F_{i-1}+F_{i-2}+i^3+i^2+i+1。F_1=1,F_0=0$。问$F_n$是多少。典型的用矩阵快速幂加速解决斐波那契递推式。$F_{i+1}=F_i+F_{i-1}+(i+1)^3+(i+1)^2+(i+1)+1=F_i+F_{i-1}+i^3+4 \times i^2+6 \times i+4$。构造一个$6$阶矩阵即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7ll; int _;ll n;struct mat&#123; ll a[7][7]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;6;i++) a[i][i]=1; &#125; mat operator * (const mat&amp; t)const&#123; mat tmp; for(int i=0;i&lt;6;i++) for(int j=0;j&lt;6;j++) for(int k=0;k&lt;6;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=x.a[0][1]=x.a[0][2]=1ll;x.a[0][3]=x.a[0][5]=4ll;x.a[0][4]=6ll; x.a[1][0]=1ll; x.a[2][2]=x.a[2][5]=1ll;x.a[2][3]=x.a[2][4]=3ll; x.a[3][3]=x.a[3][5]=1ll;x.a[3][4]=2ll; x.a[4][4]=x.a[4][5]=1ll; x.a[5][5]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld",&amp;n); mat y=matrix_pow(x,n-1ll); printf("%lld\n",((((y.a[0][0]+y.a[0][2])%mod+y.a[0][3])%mod+y.a[0][4])%mod+y.a[0][5])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Tsukuba H]]></title>
    <url>%2F2019%2F03%2F29%2F2017Tsukuba-H%2F</url>
    <content type="text"><![CDATA[2017Tsukuba Hhttps://vjudge.net/contest/259596#problem/G 有个人有两个课程，每个课程有很多个作业，每个作业有开始日期与截至日期。每天只能选择一个课程的一个作业做。问这个人最多与最少可以完成多少作业。最多的话贪心的去找到每天可以做的所有作业中截止日期最近的那个即可。最少的话将日期拆点表示日期只能用一次，一种作业与源点连接容量为 $1$，然后与日期一边 $[start,deadline]$ 连接容量为 $1$。另一种作业与汇点连接容量为 $1$，然后与日期另一边 $[start,deadline]$ 连接容量为 $1$。因为当日期只与一个种类作业连接或者没有作业连接时这一天都可以没作业做。相当于寻找一个最小的割集让图不连通也就是所有日期都最多只有一个种类的作业连接，找不到作业去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2010,inf=0x3f3f3f3f;int n,m,st[407],ed[407],st1[407],ed1[407],ans,ans1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;vector&lt;int&gt; s[407],s1[407];void init()&#123; while(!q.empty()) q.pop();ans=0;ans1=0; for(int i=1;i&lt;=401;i++) s[i].clear(),s1[i].clear();&#125;struct Dinic&#123; struct edge &#123; int from,to,cap,flow; &#125;; vector&lt;edge&gt;es; vector&lt;int&gt;G[maxn]; bool vis[maxn]; int dist[maxn]; int iter[maxn]; void init(int n)&#123; for(int i=0; i&lt;=n+10; i++) G[i].clear(); es.clear(); &#125; void addedge(int from,int to,int cap)&#123; es.push_back((edge)&#123; from,to,cap,0 &#125;); es.push_back((edge)&#123; to,from,0,0 &#125;); int x=es.size(); G[from].push_back(x-2); G[to].push_back(x-1); &#125; bool BFS(int s,int t)&#123; memset(vis,0,sizeof(vis)); queue &lt;int&gt; Q; vis[s]=1; dist[s]=0; Q.push(s); while(!Q.empty())&#123; int u=Q.front(); Q.pop(); for(int i=0; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; vis[e.to]=1; dist[e.to]=dist[u]+1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int u,int t,int f)&#123; if(u==t||f==0) return f; int flow=0,d; for(int &amp;i=iter[u]; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(dist[u]+1==dist[e.to]&amp;&amp;(d=DFS(e.to,t,min(f,e.cap-e.flow)))&gt;0)&#123; e.flow+=d; es[G[u][i]^1].flow-=d; flow+=d; f-=d; if(f==0) break; &#125; &#125; return flow; &#125; int Maxflow(int s,int t)&#123; int flow=0; while(BFS(s,t)) &#123; memset(iter,0,sizeof(iter)); int d=0; while(d=DFS(s,t,inf)) flow+=d; &#125; return flow; &#125;&#125;dinic;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init();dinic.init(1000+n); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;st[i],&amp;ed[i]); s[st[i]].push_back(ed[i]); &#125; for(int i=1;i&lt;=n-m;i++)&#123; scanf("%d%d",&amp;st1[i],&amp;ed1[i]); s1[st1[i]].push_back(ed1[i]); &#125; for(int i=1;i&lt;=400;i++)&#123; for(int j=0;j&lt;s[i].size();j++) q.push(s[i][j]); for(int j=0;j&lt;s1[i].size();j++) q.push(s1[i][j]); while(!q.empty())&#123; if(q.top()&lt;i) q.pop(); else&#123; q.pop(); ans++; break; &#125; &#125; &#125; printf("%d\n",ans); int s=0,t=800+n+1; for(int i=m+1;i&lt;=m+400;i++)&#123; dinic.addedge(i,i+400,1); &#125; for(int i=1;i&lt;=m;i++)&#123; dinic.addedge(s,i,1); for(int j=st[i];j&lt;=ed[i];j++) dinic.addedge(i,m+j,1); &#125; for(int i=1;i&lt;=n-m;i++)&#123; dinic.addedge(m+800+i,t,1); for(int j=st1[i];j&lt;=ed1[i];j++) dinic.addedge(m+400+j,m+800+i,1); &#125; printf("%d\n",dinic.Maxflow(s,t)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Daejeon E]]></title>
    <url>%2F2019%2F03%2F29%2F2017Daejeon-E%2F</url>
    <content type="text"><![CDATA[2017Daejeon E给出一个有 $n$ 个点 $m$ 条边的图，每条边有一个边权。问要使第 $i$ 条边成为图的最小生成树的一条边最少要删掉多少条边，求出每条边的对应答案的和。枚举边 $i$ ，找出那些边权小于 $i$ 的边权的边，这些边都是网络流里的边，然后以连接 $i$ 的两个点为源点和汇点跑网络流求最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000;const int MAXM = 4000;const int inf = 0x3f3f3f3f;struct edge&#123; int to,next,cap,flow;&#125;e[MAXM];int n,m;int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol=0;memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw=0)&#123; e[tol].to=v;e[tol].cap=w;e[tol].next=head[u]; e[tol].flow=0;head[u]=tol++; e[tol].to=u;e[tol].cap=rw;e[tol].next=head[v]; e[tol].flow=0;head[v]=tol++;&#125;int sap(int st,int ed,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u=st; pre[u]=-1; gap[0]=N; int ans=0; while(dep[st]&lt;N)&#123; if(u==ed)&#123; int Min=inf; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; if(Min&gt;e[i].cap-e[i].flow) Min=e[i].cap-e[i].flow; &#125; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; e[i].flow+=Min; e[i^1].flow-=Min; &#125; u=st; ans+=Min; continue; &#125; bool flag=false; int v; for(int i=cur[u];~i;i=e[i].next)&#123; v=e[i].to; if(e[i].cap-e[i].flow&amp;&amp;dep[v]+1==dep[u])&#123; flag=true; cur[u]=pre[v]=i; break; &#125; &#125; if(flag)&#123; u=v; continue; &#125; int Min=N; for(int i=head[u];~i;i=e[i].next)&#123; if(e[i].cap-e[i].flow&amp;&amp;dep[e[i].to]&lt;Min)&#123; Min=dep[e[i].to]; cur[u]=i; &#125; &#125; gap[dep[u]]--; if(!gap[dep[u]]) return ans; dep[u]=Min+1; gap[dep[u]]++; if(u!=st) u=e[pre[u]^1].to; &#125; return ans;&#125;struct E&#123; int u,v,w,fl; bool operator &lt; (const E &amp;k) const&#123; return w&lt;k.w; &#125;&#125;ee[1000];int tot=0;void solve()&#123; int ans=0; for(int i=1;i&lt;=tot;i++)&#123; init(); for(int j=1;j&lt;i;j++)&#123; if(ee[j].w&lt;ee[i].w)&#123; addedge(ee[j].u,ee[j].v,1); addedge(ee[j].v,ee[j].u,1); &#125; &#125; ans+=sap(ee[i].u,ee[i].v,n); &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ee[++tot].u=u;ee[tot].v=v;ee[tot].w=w;ee[tot].fl=0; &#125; sort(ee+1,ee+tot+1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017LatinAme F]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-F%2F</url>
    <content type="text"><![CDATA[2017LatinAme F Fundraisinghttps://vjudge.net/contest/259114#problem/F n个人有漂亮值、财富值以及钱财三个属性。当一个人的漂亮值比另一个人严格大，且财富值比那个人小的时候，这两个人会发生争吵。问怎样选择一个集合，使得集合里的人互不争吵且钱财之和最大。先将相同漂亮值财富值的人合并然后将人按照漂亮值排序。然后遍历所有的人找到财富值比它小的钱财最大的状态然后加上那个状态更新当前财富值。注意同样的漂亮值的人互不影响。最后看所有的财富值中最大的即是答案。注意离散化财富值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;struct node&#123; int b,f;ll d; node () &#123;&#125; node (int b1,int f1,ll d1)&#123; b=b1;f=f1;d=d1; &#125; bool operator &lt; (const node &amp; k)const &#123; if(b!=k.b) return b&lt;k.b; return f&lt;k.f; &#125;&#125;p[M];map&lt;node,ll&gt; mp;int n,tot,f[M];struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=0; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll v)&#123; if(l==r)&#123; if(v&gt;mx[rt]) mx[rt]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,v); else update(pos,rson,v); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;vector&lt;pair&lt;int,ll&gt; &gt; vec;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; mp.clear();tot=0;vec.clear(); for(int i=1;i&lt;=n;i++)&#123; int x,y;ll z; scanf("%d%d%lld",&amp;x,&amp;y,&amp;z); mp[node(x,y,0)]+=z; &#125; for(map&lt;node,ll&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; p[++tot].b=it-&gt;first.b;p[tot].f=it-&gt;first.f;p[tot].d=it-&gt;second; f[tot]=p[tot].f; &#125; sort(p+1,p+tot+1);int pre=0; sort(f+1,f+tot+1); int sz=unique(f+1,f+tot+1)-f-1; seg.build(0,sz,1); for(int i=1;i&lt;=tot;i++)&#123; if(p[i].b!=pre)&#123; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,0,sz,1,vec[i].second); &#125; vec.clear(); int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); pre=p[i].b; &#125; else&#123; int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); &#125; &#125; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,1,sz,1,vec[i].second); &#125; printf("%lld\n",seg.mx[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LYOI 2016 41]]></title>
    <url>%2F2019%2F03%2F29%2FLYOI2016-41%2F</url>
    <content type="text"><![CDATA[LYOI2016_41 一次函数https://lyoi.ac/problem/41 $n$ 个一次函数 $f_i(x) = k_i \times x + b_i$,有两个操作。第一个操作把指定一个二次函数的 $k$ 和 $b$ 改变。第二个操作给出区间 $[l,r]$ 以及 $x$ , 求 $f_r(f_{r-1}(…f_l(x)))$ 的值。根据推算得出对于一个区间的两个子区间 $l$ 与 $r$ ,$k_{rt} = k_l \times k_r$, $b_{rt} = k_r \times b_l + b_r$ 。用线段树维护 $k$ 与 $b$ ,询问的时候合并区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 2e5+7;typedef long long ll;const ll mod = 1e9+7;int n,q;ll a[M],c[M];char s[2];int ql,qr,qpos,tot;ll qx,qk,qb;struct Seg&#123; ll k[M&lt;&lt;3],b[M&lt;&lt;3]; void pushup(int rt,int l,int r)&#123; k[rt]=k[l]*k[r]%mod; b[rt]=(b[l]*k[r]%mod+b[r])%mod; &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; k[rt]=a[l],b[rt]=c[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll a,ll c)&#123; if(l==r)&#123; k[rt]=a,b[rt]=c; return ; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,a,c); else update(pos,rson,a,c); pushup(up); &#125; int query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return rt; &#125; int mid=(l+r)&gt;&gt;1,ll,rr,res; if(L&gt;mid)&#123; res=query(L,R,rson); return res; &#125; else if(R&lt;=mid)&#123; res=query(L,R,lson); return res; &#125; else&#123; ll=query(L,R,lson),rr=query(L,R,rson); pushup(++tot,ll,rr); return tot; &#125; &#125;&#125;seg;void solve()&#123; while(q--)&#123; scanf("%s",s); if(s[0]=='Q')&#123; tot=(M&lt;&lt;2)+1; scanf("%d%d%lld",&amp;ql,&amp;qr,&amp;qx); tot=seg.query(ql,qr,1,n,1); printf("%lld\n",(seg.k[tot]*qx%mod+seg.b[tot])%mod); &#125; else&#123; scanf("%d%lld%lld",&amp;qpos,&amp;qk,&amp;qb); seg.update(qpos,1,n,1,qk,qb); &#125; &#125;&#125;int main()&#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;q))&#123; for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;a[i],&amp;c[i]); seg.build(1,n,1); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nowcoder practice28 B]]></title>
    <url>%2F2019%2F03%2F29%2FNowcoder-practice28-B%2F</url>
    <content type="text"><![CDATA[Nowcoder_practice28_B 数据结构https://www.nowcoder.com/acm/contest/200/B $n$ 个数 $m$ 个操作。$1.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}$。$2.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}^{2}$。$3.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $\times x$。$4.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $+ x$。线段树模板题，维护一个加 $lazy$ 与一个乘 $lazy$ ,再维护两个答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int Nmax = 1e4+7;int n,q;ll a[Nmax];struct Seg&#123; ll sum[Nmax&lt;&lt;2],fsum[Nmax&lt;&lt;2],len[Nmax&lt;&lt;2],lazyadd[Nmax&lt;&lt;2],lazymul[Nmax&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; sum[rt]=sum[l]+sum[r]; fsum[rt]=fsum[l]+fsum[r]; &#125; void pushdown(int rt,int l,int r)&#123; if(lazymul[rt]!=1)&#123; ll v=lazymul[rt]; lazymul[rt]=1; sum[l]*=v;sum[r]*=v; fsum[l]*=(v*v);fsum[r]*=(v*v); lazymul[l]*=v;lazymul[r]*=v; lazyadd[l]*=v;lazyadd[r]*=v; &#125; if(lazyadd[rt])&#123; ll v=lazyadd[rt]; lazyadd[rt]=0; fsum[r]+=(2*sum[r]*v+v*v*len[r]);fsum[l]+=(2*sum[l]*v+v*v*len[l]); sum[r]+=(v*len[r]);sum[l]+=(v*len[l]); lazyadd[r]+=v;lazyadd[l]+=v; &#125; &#125; void build(int l,int r,int rt)&#123; sum[rt]=fsum[rt]=0;len[rt]=(ll)(r-l+1);lazyadd[rt]=0;lazymul[rt]=1; if(l==r)&#123; sum[rt]=a[l];fsum[rt]=a[l]*a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int L,int R,int l,int r,int rt,ll v,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==2)&#123; fsum[rt]+=(2*sum[rt]*v+v*v*len[rt]); sum[rt]+=(len[rt]*v); lazyadd[rt]+=v; &#125; else&#123; sum[rt]*=v;fsum[rt]*=(v*v); lazyadd[rt]*=v;lazymul[rt]*=v; &#125; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson,v,op); if(R&gt;mid) update(L,R,rson,v,op); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==1) return sum[rt]; else return fsum[rt]; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res+=query(L,R,lson,op); if(R&gt;mid) res+=query(L,R,rson,op); return res; &#125;&#125;seg;void solve()&#123; while(q--)&#123; int op,l,r;ll v; scanf("%d",&amp;op); if(op==1||op==2)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",seg.query(l,r,1,n,1,op)); &#125; else&#123; scanf("%d%d%lld",&amp;l,&amp;r,&amp;v); seg.update(l,r,1,n,1,v,op-2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); seg.build(1,n,1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[codeforces 1051Fhttp://codeforces.com/contest/1051/problem/F 给一副图，图中的边最多比点多 $20$ 条。给 $q$ 次询问，每次询问两点的最短路。随便弄一个生成树，然后求出两点在树上的距离。把非树边的两端点保存然后求分别求一次最短路。然后以所有非树边端点的最短距离更新即可。 wannafly_day1_Jhttp://newoj.acmclub.cn/contests/1389/problem/9 改成了边比点多100条，不过所有边的距离都是1，把非树边抽出来跑一下bfs求互相的最短距离。和cf1051F差不多。 wannafly_day3_Ihttps://www.nowcoder.com/acm/contest/203/I 多源最短路。在一幅无向图中给出点集，问点集中的每个点到其他点的最短距离是多少。把点集里的点都做为源点，每个点都再增加一个祖先属性，表示这个点被哪个源点的最短路所更新。然后跑一次多源最短路即可。 2017Tsukuba_Fhttps://vjudge.net/contest/259357#problem/F 问一幅有向图中每条边如果反向会让图中点1到点2的最短距离变大变小还是不变。先求出点1到各个点的最短距离与边反向之后点2到各个点的最短距离。如果变小的话就是 $dis_{1to} + dis_{2from} + w &lt; dis$ 。变大的话就是上述等式变成大于符号，但因为最短路可能有多条，所以只有这条边还是最短路无向图里的桥时才会让最短距离变大。上述两个情况都不满足的话，最短距离不变。 codeforces 1076Dhttp://codeforces.com/contest/1076/problem/D 最短路生成树$+dfs$给 $n$ 个点 $m$ 条边，找出一个边集不超过 $k$ 条边使得距离节点 $1$ 的距离是最短距离的点最多，输出这个边集首先将 $1$ 节点跑最短路建出最短路生成树，然后再在生成树上 $dfs$ 出一个 $k$ 条边的边集 2018SEERC Chttp://codeforces.com/gym/101964/problem/C 给出一棵树，这棵树由黑白点组成。选出一个黑点点集，点集中点数小于给定的k，找出所有可能的黑点点集里直径最小的那个并输出直径。考虑枚举所有的黑点点对，求出点对的距离，当有黑点满足离点对两点距离都小于等于点对距离时就可以将点加入。数形结合，可以理解为这些点在两个圆的相交部分，所以最大距离必是点对距离。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>dijkstra</tag>
        <tag>spfa</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git+hexo搭建]]></title>
    <url>%2F2019%2F03%2F29%2Fgit-hexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建所需环境首先需要 $git+node.js$。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
