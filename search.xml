<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[3b1b_structureofnn]]></title>
    <url>%2F2019%2F10%2F29%2F3b1b-structureofnn%2F</url>
    <content type="text"><![CDATA[Part1$activation$:激活，像素点的亮度。$Hidden layers$:隐含层，具体的处理。权重：下一层神经元的关注重点偏置：$Only activate meaningfully when weighted Sum &gt; bias$$ReLu$：线性整流函数，大于阈值则输出否则不输出。 Part2梯度：多元函数函数值上升最快的方向，沿梯度负方向可以最快达到最低点。用梯度下降使得代价函数最小梯度向量在一定意义上表示了变量的重要性 将输出的结果得到代价函数，然后根据使得代价函数最小的梯度调整权重与偏置。循环往复。 Part3反向传播每个点对前一层的影响加起来梯度下降把所有样本的反向传播求和取均值 只有标记好的训练集才能使用代价函数计算代价]]></content>
      <categories>
        <category>learning</category>
      </categories>
      <tags>
        <tag>neural_network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi9]]></title>
    <url>%2F2019%2F10%2F28%2Foi9%2F</url>
    <content type="text"><![CDATA[区间dp顾名思义是在区间上DP，它的主要思想就是先在小区间进行DP得到最优解，然后再利用小区间的最优解合并求大区间的最优解。 ##Q1 石子合并有$N$堆石子排成一排，每堆石子有一定的数量。现要将$N$堆石子并成为一堆。合并的过程只能每次将的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过$N-1$次合并后成为一堆。求出总的代价最小值。 分析：贪心的每次拿最小的连个合并即可。 ##Q2 石子合并有$N$堆石子排成一排，每堆石子有一定的数量。现要将$N$堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过$N-1$次合并后成为一堆。求出总的代价最小值。 分析：强行贪心？石子：$9$ $4$ $6$ $1$ $5$贪心策略：$9$ $4$ $6$ $6$ 计分$6$$9$ $10$ $6$ 计分$10$$9$ $16$ 计分$16$$25$ 计分$25$代价共计：$6+10+16+25=57$ 若如下方式合并：$13$ $6$ $1$ $5$ 计分$13$$13$ $6$ $6$ 计分$6$$13$ $12$ 计分$12$$25$ 计分$25$$13+6+12+25=56$或$9$ $4$ $6$ $6$ 计分$6$$9$ $4$ $12$ 计分$12$$13$ $12$ 计分$13$$25$ 计分$25$$6+12+13+25=56$ 显而易见?$dp[i][j]$来表示合并第$i$堆到第$j$堆石子的最小代价$dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);$$w[i][j]$为此次合并的花费 先一维从小到大枚举长度，再一维枚举左右端点，第三维枚举合并点即可。 luoguP1043数字游戏题目:给出一圈数字分成$m$堆，求每堆数字和模$10$相乘的最大最小值。 分析：一堆数字分成$m$堆，不如先把$m$看作$2$，那可以看成一个圈的石子合并，不过合并代价是取模相乘。至于圈的解法就是破环为线，把$n$个数字变为$2 \times n$个数字即可枚举出圈里的所有可能性。不过相较于石子合并得多一维枚举分成多少段。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int n,m,f1[110][110][110],f2[110][110][110],a[110],sum[110];int mod(int x)&#123; return (x%10+10)%10;&#125;int main()&#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif cin&gt;&gt;n&gt;&gt;m; //求前缀和 for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;a[i];sum[i]=sum[i-1]+a[i];&#125; for(int i=1;i&lt;=n;i++)&#123;a[i+n]=a[i],sum[i+n]=sum[i]+sum[n];&#125; //f2记录的是最小值 所以要初始化为极大值 memset(f2,127,sizeof(f2)); for(int i=1;i&lt;=2*n;i++)&#123; for(int j=i;j&lt;=2*n;j++)&#123; f1[i][j][1]=f2[i][j][1]=mod(sum[j]-sum[i-1]);//预处理每段的值 &#125; &#125; for(int l=1;l&lt;=n;l++)&#123;//区间长度 for(int i=1,j=i+l-1;j&lt;=2*n;i++,j++)&#123;//左右端点 for(int h=2;h&lt;=m;h++)&#123;//段数 for(int k=i+h-1;k&lt;j;k++)&#123;//短点 f1[i][j][h]=max(f1[i][j][h],f1[i][k][h-1]*mod(sum[j]-sum[k])); f2[i][j][h]=min(f2[i][j][h],f2[i][k][h-1]*mod(sum[j]-sum[k])); &#125; &#125; &#125; &#125; int maxn=0,minn=0x7fffffff; for(int i=1;i&lt;=n;i++)&#123; maxn=max(maxn,f1[i][i+n-1][m]); minn=min(minn,f2[i][i+n-1][m]); &#125; cout&lt;&lt;minn&lt;&lt;endl&lt;&lt;maxn; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi8]]></title>
    <url>%2F2019%2F10%2F28%2Foi8%2F</url>
    <content type="text"><![CDATA[luoguP1280题意：$n$分钟$k$个任务，每个任务给出开始与持续时间，尼克只要在闲下来时遇到任务就要做，问尼克最多休闲多久。 分析：如果这分钟没有任务的话这分钟便可以休息，那么下一分钟的答案$+1$。有任务的话任务执行结束后的那一刻的休闲时间和执行任务前的时间是一致的。 转移方程：$dp[i+1]=max(dp[i+1],dp[i]+1)$$dp[i+next]=max(dp[i+next],dp[i])$ 初始化：注意初始时除了第一个所有时间的值都为极小值，为了避免出现任务中的递增出现。 代码:1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;vector&lt;int&gt; st[maxn];int dp[maxn],p,t,n,k;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d%d",&amp;n,&amp;k); for(int i=2;i&lt;=n+1;++i) dp[i]=-1e9; for(int i=1;i&lt;=k;++i)&#123; scanf("%d%d",&amp;p,&amp;t); st[p].push_back(t); &#125; for(int i=1;i&lt;=n;++i)&#123; if(!st[i].size()) dp[i+1]=max(dp[i+1],dp[i]+1); for(int j=0;j&lt;st[i].size();++j)&#123; dp[i+st[i][j]]=max(dp[i],dp[i+st[i][j]]); &#125; &#125; printf("%d\n",dp[n+1]); return 0;&#125; luoguP1002题意：一个$n \times m$的棋盘可以向下和向右走，棋盘上有一个马，马和它覆盖的位置不能到。问有多少种方案从左上角到右下角。 分析：先把不能到的点标记上，然后容易知道一个点只能从它的上面和左面走到。那么我们从左到右从上到下枚举点更新方案数即可。 转移方程：$dp[i][j]=max(dp[i][j],dp[i-1][j]+dp[i][j-1])$ 代码：123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int maxn = 100000 + 5;const int x[]=&#123;0,-2,-1,1,2,2,1,-1,-2&#125;;const int y[]=&#123;0,1,2,2,1,-1,-2,-2,-1&#125;;int n,m,mm,mn;int vis[101][101];ull dp[101][101];int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d%d%d%d",&amp;n,&amp;m,&amp;mn,&amp;mm); n+=1;m+=1;mn+=1;mm+=1; dp[1][1]=1;vis[mn][mm]=1; for(int i=1;i&lt;=8;i++) if(mn+x[i]&gt;=0&amp;&amp;mm+y[i]&gt;=0) vis[mn+x[i]][mm+y[i]]=1; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) if(!vis[i][j]) dp[i][j]=max(dp[i][j],dp[i-1][j]+dp[i][j-1]); printf("%llu\n",dp[n][m]); return 0;&#125; luoguP1095题意:荒岛逃生，初始魔法值为$M$，需要在$T$秒内跑完$S$的距离。可以选择花费$10$魔法值进行$60$米的闪现或者跑$17$米或者停下恢复$4$点魔法值。 分析：可以知道闪现永远比跑步快除法魔法值还没恢复好的一两秒内使用跑步是优于停止恢复的。所以先更新闪现的$dp$，然后用跑步去更新闪现回复蓝量的中间值即可。 转移方程：$m&gt;=10?dp[i]=dp[i-1]+60:dp[i]=dp[i-1];$$m&gt;=10?m-=10:m+=4; $$dp[i]=max(dp[i],dp[i-1]+17);$ 代码：1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300000 + 5;int dp[maxn],m,s,t;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d%d%d",&amp;m,&amp;s,&amp;t); for(int i=1;i&lt;=t;++i)&#123; m&gt;=10?dp[i]=dp[i-1]+60:dp[i]=dp[i-1]; m&gt;=10?m-=10:m+=4; &#125; //一段路只跑是否大于当前闪现得到的最大距离 for(int i=1;i&lt;=t;++i)&#123; dp[i]=max(dp[i],dp[i-1]+17); if(dp[i]&gt;=s)&#123; printf("Yes\n%d\n",i); return 0; &#125; &#125; printf("No\n%d\n",dp[t]); return 0;&#125; luoguP1233题意：把$n$根棍子加工，如果前一根棍子的长与宽均大于下一根那么下一根不花时间否则花费一分钟时间。问最小加工时间。 分析：先把棍子按照长度从大到小排序，那么可知如果一根棍子的宽度小于前一根则必定满足条件。由此在长度相等时把宽度也按从大到小排序，相当于是寻找木棍有多少个不上升子序列。根据定理知数组的不上升子序列的最小划分等于递增子序列的大小，求递增子序列即可。 代码：123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int n,dp[maxn],tmp;struct stick&#123; int l,w; bool operator &lt; (const stick &amp; k)const&#123; if(l!=k.l) return l&gt;k.l; return w&gt;k.w; &#125;&#125;s[maxn];int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d%d",&amp;s[i].l,&amp;s[i].w); sort(s+1,s+n+1); dp[++tmp]=s[1].w; for(int i=2;i&lt;=n;++i)&#123; if(s[i].w&gt;dp[tmp])&#123; dp[++tmp]=s[i].w; continue; &#125; int pos=lower_bound(dp+1,dp+tmp+1,s[i].w)-dp; dp[pos]=s[i].w; &#125; printf("%d\n",tmp); return 0;&#125; luoguP1113题意：一个工作有前驱工作，前驱工作做完后才能做当前工作，并且工作可并行。问做完所有工作的时间是多少。 分析：拓扑排序，每次把入度为$0$的工作做掉然后更新其后继工作的工作时间。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;vector&lt;int&gt; vec[maxn];queue&lt;int&gt; q;int tim[maxn],ans[maxn],n,deg[maxn],out;void topo()&#123; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;vec[u].size();++i)&#123; int v=vec[u][i]; --deg[v]; ans[v]=max(ans[v],ans[u]+tim[v]); out=max(out,ans[v]); if(!deg[v]) q.push(v); &#125; &#125;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); int id; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;id); scanf("%d",&amp;tim[id]); int x=1; while(x)&#123; scanf("%d",&amp;x); if(x)&#123; vec[x].push_back(id); ++deg[id]; &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) if(!deg[i])&#123; ans[i]=tim[i]; out=max(out,ans[i]); q.push(i); &#125; topo(); printf("%d\n",out); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi7]]></title>
    <url>%2F2019%2F10%2F22%2Foi7%2F</url>
    <content type="text"><![CDATA[二叉树的遍历先序遍历，即先根再左再右中序遍历，即先左再根再右后序遍历，即先左再右再根 luoguP1030 求先序排列题意：给出一棵二叉树的中序与后序排列。求出它的先序排列。 思路：假设一棵二叉树的中序序列和后序序列分别是BDCEAFHG 和 DECBHGFA：①由后序遍历特征，根结点必在后序序列尾部（A）；②由中序遍历特征，根结点必在其中间，而且其左部必全部是左子树子孙（BDCE），其右部必全部是右子树子孙（FHG）；③继而，根据后序中的DECB子树可确定B为A的左孩子，根据HGF子串可确定F为A的右孩子；以此类推。 代码：123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;char s[maxn],t[maxn];int s_len,t_len;void output(int l,int r,int pos)&#123; if(l&gt;r) return ; printf("%c",t[pos]); for(int i=l;i&lt;=r;++i)&#123; if(s[i]==t[pos])&#123; output(l,i-1,pos-(r-i)-1); output(i+1,r,pos-1); break; &#125; &#125;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%s%s",s,t); s_len=strlen(s),t_len=strlen(t); output(0,s_len-1,t_len-1); return 0;&#125; luoguP1087 FBI树题意：用$2^n$长的串构造一棵二叉树，每次到一个节点如果当前串全为$0$该节点为$B$，全$1$节点为$I$，否则为$F$；然后串按中点分为左右两部分继续向下递归，输出二叉树的后序遍历。 思路：先用前缀和数组$sum_i$表示串的前$i$位有多少个$0$，那么如果全$0$就是$r-l+1==sum[r]-sum[l-1]$，全$1$就是$sum[r]-sum[l-1]==0$。然后按照二叉树建树方法向下递归即可。 代码：12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;char s[maxn];int n,sum[maxn];void output(int l,int r)&#123; char c; if(r-l+1==sum[r]-sum[l-1]) c='B'; else if(sum[r]-sum[l-1]==0) c='I'; else c='F'; if(r-l+1&gt;1)&#123; output(l,(r+l)&gt;&gt;1); output(((r+l)&gt;&gt;1)+1,r); &#125; printf("%c",c);&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); scanf("%s",s); for(int i=1;i&lt;=pow(2,n);++i)&#123; if(s[i-1]=='0') sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]; &#125; output(1,pow(2,n)); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi6]]></title>
    <url>%2F2019%2F10%2F22%2Foi6%2F</url>
    <content type="text"><![CDATA[前缀和前缀和是一种重要的预处理，能大大降低查询的时间复杂度。我们可以简单理解为“数列的前 $n$ 项的和”。 例题:有 $N$ 个的正整数放到数组 $A$ 里，现在要求一个新的数组 $B$，新数组的第 $i$ 个数 $B[i]$是原数组 $A$ 第 $0$ 到第 $i$ 个数的和。 递推：$B[i] = B[i-1] + A[i]$ ，$前提 B[0] = A[0]$ luoguP1873 砍树题意：有$n$颗树，每棵树树高为$h_i$，现在可以用电锯将高度为$H$以上的部分全部砍掉，问满足砍掉的树长之和大于等于$M$的高度最高是多少？ 思路：当高度H满足条件时，小于H的高度必定也满足条件；当高度H不满足条件时，大于H的高度必定不满足条件。满足二分的性质，二分高度即可。难点在于如何判断是否满足条件。我们可以先将树按高度排序，然后记录树高度的前缀和为$sum$。这样每次二分的高度只需要在有序序列中通过二分查找找到大于等于这个高度的第一个位置，然后砍掉的树高为$sum[n]-sum[pos-1]-(mid\times (n-pos+1))$。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1000000 + 5;int n;ll tree[maxn],l,r,mid,ans,sum[maxn],M;bool check(ll mid)&#123; int pos=lower_bound(tree+1,tree+n+1,mid)-tree; if(sum[n]-sum[pos-1]-(mid*(n-pos+1))&gt;=M) return true; return false;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d%lld",&amp;n,&amp;M); for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;tree[i]); &#125; sort(tree+1,tree+n+1); for(int i=2;i&lt;=n;++i)&#123; sum[i]=sum[i-1]+tree[i]; &#125; l=1ll,r=tree[n]; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(check(mid))&#123; ans=mid; l=mid+1; &#125; else r=mid-1; &#125; printf("%lld\n",ans); return 0;&#125; luogu1024 一元三次方程求解题意：有形如：$ax^3+bx^2+cx^1+dx^0=0$ 这样的一个一元三次方程。给出该方程中各项的系数($a,b,c,d$均为实数)，并约定该方程存在三个不同实根(根的范围在$-100$至$100$之间)，且根与根之差的绝对值$\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后$2$位。 思路：首先两点之间有根的条件为：$f_{x1} \times f_{x2} &lt; 0$，其次题目中说根与根之差的绝对值 $\ge 1$，那么就可以按区间大小为$1$枚举所有的区间，然后对区间进行二分查找即可找到所有的零点。 代码：123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;double l,r,mid,a,b,c,d,ans;double calc(double x)&#123; return a*x*x*x+b*x*x+c*x+d;&#125;void check(double x)&#123; l=x,r=x+1.0; while(l&lt;=r)&#123; mid=(l+r)/2.0; if(calc(r)==0) ans=r; if(calc(l)==0) ans=l; if(calc(mid)==0) ans=mid; if(calc(l)*calc(mid)&lt;0) r=mid-0.0001; else l=mid+0.0001; &#125; ans=mid;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%lf%lf%lf%lf",&amp;a,&amp;b,&amp;c,&amp;d); for(double x=-100.0;x&lt;100.0;x+=1.0)&#123; if(calc(x)==0) printf("%.2f ",x); if(calc(x)*calc(x+1.0)&lt;0)&#123; check(x); printf("%.2f ",ans); &#125; &#125; if(calc(100.00)==0) printf("100.00\n"); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi5]]></title>
    <url>%2F2019%2F10%2F22%2Foi5%2F</url>
    <content type="text"><![CDATA[luoguP2101命运石之门的选择题意：它由$N$个宽度为$1$高度为$H_i$的矩形组成，矩形并排排列，相邻的矩形间没有空隙，初始情况下每个矩形都是没有颜色的。你有一个宽度为$1$的刷子，你可以竖直或水平的刷，每次使用刷子，你的刷子都必须保证一直全部处于矩形中，即不能刷到矩形以外的地方去，当然你每次刷的时候也不能拐弯。你每刷一次，要花费$1$的时间，这和刷的长度无关，比如你可以从最左边刷到最右边（当然是不经过矩形以外的部分），这也只花费$1$的时间。你的目的是将全部的矩形都涂满颜色。请输出这个最短的时间，以便冈伦决定是自己来完成这个任务还是让你来做苦力。 思路：首先想到时间最大为$n$(每一个矩形竖着刷一次即可)。首先只竖着刷的最优解就是$n$，那么考虑只有加入横着刷才能使得时间变得更小。如何横着刷才是最优呢？考虑横着刷一次刷最多个矩形，那么就是从下向上刷，每次把最矮的高度刷掉，当然这会造成所有矩形不连通。那接着把所有不连通的矩阵块递归的求解答案即可。最后不能忘了和竖着刷的最优解比较。 代码：123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 5000 + 5;int n;ll height[maxn];ll calc(int l,int r,ll x)&#123; if(l&gt;r) return 0; if(l==r) return 1; ll mn=height[l]; for(int i=l+1;i&lt;=r;++i) mn=min(mn,height[i]); ll ans=mn-x; int L=l; for(int i=l;i&lt;=r;++i)&#123; if(height[i]==mn)&#123; ans+=calc(L,i-1,mn); L=i+1; &#125; &#125; if(height[r]!=mn) ans+=calc(L,r,mn); return min(1ll*(r-l+1),ans);&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld",&amp;height[i]); ll ans=min(1ll*n,calc(1,n,0)); printf("%lld\n",ans); return 0;&#125; luoguP1257 平面上的最接近点对题意：给定平面上$n$个点，找出其中的一对点的距离，使得在这$n$个点的所有点对中，该距离为所有点对中最小的。 思路：先将所有点按x大小排序，然后找一个中点将所有点分成左右两个集合。这样左右两个集合必定存在一个各自的最近点对。取$dis$为两集合最近点对距离的最小值。现在容易想到每次将一个集合划分为左右两个集合然后再将左右集合的最近距离比较。但最近距离不一定存在于两个集合中，可能一个点在集合 $A$ ，一个点在集合 $B$，而这两点间距离小于 $dis$。其中如何合并是关键。根据递归的方法可以计算出划分的两个子集中所有点对的最小距离 $dis_{left}$,$dis_{right}$，再比较两者取最小值，即 $dis=min(dis_{left},dis_{right})$ 。那么一个点在集合 $A$，一个在集合 $B$ 中的情况，可以针对此情况，用之前分解的标准值，即按照 $x$ 坐标(或者 $y$ )从小到大排序后的中间点的 $x$ 坐标作为 $mid$。划分一个 $[mid-dis,mid+dis]$区域，如果存在最小距离点对，必定存在这个区域中。 代码：12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10000 + 5;int n,tmp[maxn];struct node&#123; double x,y; bool operator &lt; (const node &amp; k)const&#123; return x&lt;k.x; &#125;&#125;nd[maxn];double dis(int i,int j)&#123; return sqrt((nd[i].x-nd[j].x)*(nd[i].x-nd[j].x)+(nd[i].y-nd[j].y)*(nd[i].y-nd[j].y));&#125;double merge(int l,int r)&#123; if(l==r) return 2&lt;&lt;20; if(l+1==r) return dis(l,r); int mid=(l+r)&gt;&gt;1,cnt=0; double ans=min(merge(l,mid),merge(mid+1,r)); for(int i=l;i&lt;=r;++i) if(fabs(nd[mid].x-nd[i].x)&lt;=ans) tmp[++cnt]=i; for(int i=1;i&lt;cnt;++i) for(int j=i+1;j&lt;=cnt;j++) ans=min(ans,dis(tmp[i],tmp[j])); return ans;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lf%lf",&amp;nd[i].x,&amp;nd[i].y); sort(nd+1,nd+n+1); printf("%.4f\n",merge(1,n)); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi4]]></title>
    <url>%2F2019%2F10%2F22%2Foi4%2F</url>
    <content type="text"><![CDATA[Hanoi问题将$A$柱上$n$个从上到下从小到大放置的圆盘可以借助$B$柱挪到$C$柱上的最小步骤数，全过程得保持从上到下从小到大顺序。 设$b[n]$表示将$n$个圆盘从$A$挪到$C$的最小步骤。先移$n-1$个到$B$，再移$1$个到$C$，再将$B$上的$n-1$个移到$C$。可以得到$b[n]=b[n-1]+1+b[n-1]$，也即$b[n]=2 \times b[n-1]+1$;推导如下：$b[n]+1=2 \times b[n-1] +2 = 2 \times (b[n-1] + 1)= 2^{n-1} \times (b[1]+1)$因为 $b[1]=1$ ，所以$b[n]=2^n-1$ luoguP1096 Hanoi双塔问题有$2\times n$个圆盘，问最小的步骤。可以把两个相同大小的圆盘看作一个，那么只是在$Hanoi$问题上每个操作多挪动一个大小相同的圆盘即可。所以n个双塔的答案应该是$ans=2\times b[n]=2^{n+1}-2$即可。这道题需要使用高精度。代码如下：1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int s[maxn],len=1,n;void mul()&#123; int op=0; for(int i=0;i&lt;len;++i)&#123; if(s[i]*2+op&gt;=10)&#123; s[i]=s[i]*2+op-10; op=1; &#125; else s[i]=s[i]*2+op,op=0; &#125; if(op==1) s[len++]=op;&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d",&amp;n); s[0]=2; for(int i=1;i&lt;=n;++i) mul(); s[0]-=2; for(int i=len-1;i&gt;=0;--i) printf("%d",s[i]); cout&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi2]]></title>
    <url>%2F2019%2F10%2F15%2Foi2%2F</url>
    <content type="text"><![CDATA[二分二分常在求让最小值最大、最大值最小的题中使用。通过每次将查找空间一分为二使得复杂度由枚举的$O(n)$下降到了$O(log_2n)$。通常由检查函数与二分代码构成。 求最大值 luoguP1577有$N$条绳子，它们的长度分别为$Li$。如果从它们中切割出$K$条长度相同的绳子，这$K$条绳子每条最长能有多长？答案保留到小数点后$2$位(直接舍掉$2$为后的小数)。 分析：先忽略实数假设给的长度都是整数求出的答案也是整数。那么可知绳子最短肯定是$1$，最长肯定是$N$条绳子的长度和。最好想的想法就是从$1$到$maxlen$枚举长度找到最长的长度即可。 检查枚举的长度是否合法的代码：12345bool check(int x)&#123; int cnt=0; for(int i=1;i&lt;=n;++i) cnt+=b[i]/x; return cnt&lt;k?false:true;&#125; 枚举的复杂度为$O(N \times maxlen)$当数据量大的时候枚举便不行了。容易想到当长度为$x$时无法满足切出$k$条绳子时那么$\geq x$的长度便都不行了。而$x$满足条件时我们便可以尝试更大的长度。发现满足二分的性质。二分的复杂度为$O(N \times log_2 maxlen)$可以通过。 特别的，这道题给出的长度为实数，不妨将实数$\times 100$转换为整数再使用二分，最后将答案转换为实数即可。 二分代码：12345678910111213141516int l=1,r=0;for(int i=1;i&lt;=n;++i)&#123; scanf("%lf",&amp;a[i]); b[i]=a[i]*100;//转换为整数 r=max(r,b[i]);//找到二分右边界&#125;while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1;//二分中点 if(check(mid))&#123;//检查中点是否满足要求 //是的话保存当前答案并且将检查区间缩小到右边 ans=mid; l=mid+1; &#125; else r=mid-1;//不是的话将检查区间缩小到左边&#125;printf("%.2f\n",ans/100.0); 求最小的最大值 luoguP1281现在要把$m$本有顺序的书分给$k$给人复制（抄写），每一个人的抄写速度都一样，一本书不允许给两个（或以上）的人抄写，分给每一个人的书，必须是连续的，比如不能把第一、第三、第四本书给同一个人抄写。 现在请你设计一种方案，使得复制时间最短。复制时间为抄写页数最多的人用去的时间。 如果有多解，则尽可能让前面的人少抄写。 分析：因为每个人的抄写速度相同，所以可以把复制时间转化为复制的页数，也就是求复制页数最短能有多短可以将书复制完。 容易想到的是从1开始枚举最短的复制页数，但复杂度为$O(pagenum \times m)$很容易超时。 枚举检查代码：123456789101112131415161718192021bool check(int x)&#123; //因为前面的人要少做，所以从后向前让后面的人做的最多 //tot表示当前是哪个人，cnt表示这个人复制的页数 int tot=k,cnt=0; for(int i=m;i&gt;=1;--i)&#123; if(cnt+a[i]&lt;=x)&#123; //复制的页数比枚举的页数小继续下一本书 cnt+=a[i]; &#125; else&#123; //复制的页数比枚举的页数大这本书得给下个人 --tot; cnt=0; ++i; &#125; //人已经用完了还没复制完所有书则失败 if(tot==0) return false; &#125; //枚举的页数可行 return true;&#125; 当时间$x$不可行时那么$\leq x$的页数便不用考虑了都不行，当时间$x$可行时那么$x$便是当前最优的答案而且可以继续向更优的答案进行考虑报。从这两点想到二分页数寻找最短的页数(时间)。 二分代码：12345678910111213141516scanf("%d%d",&amp;m,&amp;k);for(int i=1;i&lt;=m;++i) &#123; scanf("%d",&amp;a[i]); r+=a[i];//确定右边界&#125;l=1;//最小都要为1//二分模板while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(check(mid))&#123; ans=mid; r=mid-1; &#125; else l=mid+1;&#125; 附加给定三个数组，在$O(n^2)$的时间内能否在三个数组中各找到一个数加起来的和等于一个指定的数。前两个数组长度小于等于$500$，第三个数组长度小于等于$1000$。$hdu2141$]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi3]]></title>
    <url>%2F2019%2F10%2F15%2Foi3%2F</url>
    <content type="text"><![CDATA[队列队列是一种先进先出$(FIFO)$的线性表。它只允许在表的一端进行插入,而在另一端删除元素。 操作：入队出队判队空 栈只能在表的一端（栈顶）进行插入和删除运算的线性表$(FILO)$。 操作：入栈出栈判栈空 拓扑排序实现： 找出图中入度为$0$的顶点； 依次在图中删除这些顶点，删除后再找出入度为$0$的顶点； 然后再删除……再找出…… 直至删除所有顶点，即完成拓扑排序 复杂度：$O(V+E)$ 用途:对于有向无环图$(DAG)$可以将图上顶点排序后转换为线性序列，对于有向有环图可以找出图中的环。也可以判断有向图是否有环。 双向链表每一个节点有一个前驱指向它的前一个节点，有一个后继指向它的后继节点。 对于一个$1$到$n$的排列$p$(即$1$到$n$中每一个数在$p$中出现了恰好一次)，令$q_i$为第$i$个位置之后第一个比$p_i$值更大的位置，如果不存在这样的位置，则$q_i =n+1$。 举例来说，如果$n=5$且$p$为$1$ $5$ $4$ $2$ $3$，则$q$为$2$ $6$ $6$ $5$ $6$。 先将$n$个输入的数按从小到大的顺序排序，这样就可以从小到大枚举数字。但是发现输入的n个数是排列，排列可以通过如下方式排序：123456第一空for(int i=1;i&lt;=n;++i)&#123; cin&gt;&gt;x; a[x]=i;&#125;//这样a数组的下标就是原来输入序列的排序 双向链表$L$数组表示当前下标$i$左边的数，$R$数组表示当前下标$i$右边的数，下标i左边的数是$i-1$，右边的数$i+1$。12345for (int i = 1; i &lt;= n; i++) &#123; R[i] = i + 1; // 第二空 L[i] = i - 1;&#125; 将排序后的序列从小到大从双向链表中删除。因为是从小到大删除数字，所以每到一个数字已经是序列中最小的数字，所以剩下的数字都比它大，所以它右边的数字就是答案。1234567891011//a[i]表示下标//删除第a[i]下标后//a[i]下标的右边的数为R[a[i]]//R[a[i]]的左边的数变为a[i]左边的数，因为a[i]已经被删除//a[i]下标的左边的数为L[a[i]]//L[a[i]]的右边的数变为a[i]右边的数，因为a[i]已经被删除for (int i = 1; i &lt;= n; i++) &#123; L[R[a[i]]] = L[a[i]]; // 第三空 R[L[a[i]]] = R[a[i]]; // 第四空&#125; 最后输出每个下标右边的数即可1234for (int i = 1; i &lt;= n; i++)&#123; cout &lt;&lt; R[i] &lt;&lt; ' ' ; // 第五空&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi1]]></title>
    <url>%2F2019%2F10%2F15%2Foi1%2F</url>
    <content type="text"><![CDATA[Q1 求解最长上升子序列(LIS)给定一个 $n$ 个数的排列，求这个排列的 $LIS$。($ 0 \leq n \leq 1000$) 分析：$1000$的数据量时用朴素的 $O(n^2)$ 复杂度的 $dp$ 即可。即前 $i$ 个数的 $LIS$ 可以通过与 $1…i-1$ 个数比较大小如果第 $i$ 个数大于比较之数就使用转移方程。 初始状态：$for$&emsp;$i$&emsp;$in$&emsp;$1…n$&emsp;$dp[i]$ $=$ $1$转移方程：$dp[j] = max( dp[j], dp[i]+1 );$ 代码：123456789for(int i=1;i&lt;=n;i++)&#123; dp[i]=1;//初始化 for(int j=1;j&lt;i;j++)//枚举i之前的每一个j if(data[j]&lt;data[i]) //用if判断是否可以拼凑成上升子序列，如果是，则↓ dp[i] = max( dp[i], dp[j]+1 );//更新最优状态 &#125; Q2 求解最长上升子序列(LIS)给定一个 $n$ 个数的排列，求这个排列的 $LIS$。($ 0 \leq n \leq 100000$) 分析：当数据量增大时无法再使用复杂度$O(n^2)$的dp，考虑对dp进行优化。在$O(n^2)$的算法中主要无法确定当前数字放在哪个位置比较好所以得暴力的比较所有当前数字前的数字。优化的方法是将LIS存在一个数组中，每当指针向后移动一个位置就先与数组中最后一个元素进行比较如果大于就将此数字填充到数组中否则使用二分查找(数组有序)找到数组中第一个大于此数字的数并将其替换即可。 过程： 假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。 我们定义一个序列B，然后令 i = 1 to 9 逐个考察这个序列。此外，我们用一个变量Len来记录现在最长算到多少了 首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1 然后，把d[2]有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了，很容易理解吧。这时Len=1 接着，d[3] = 5，d[3]&gt;B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2 再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2 继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3 第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了 第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。 最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。 于是我们知道了LIS的长度为5。 然后应该发现一件事情了：在$B$中插入数据是有序的，而且是进行替换而不需要挪动——也就是说，我们可以使用二分查找，将每一个数字的插入时间优化到$O(logn)$。 代码：1234567891011//c为存储lis数组int cnt=0;for(int i=1;i&lt;=n;++i)&#123; if(b[i]&gt;c[cnt])&#123; c[++cnt]=b[i]; continue; &#125; int k=lower_bound(c+1,c+cnt+1,b[i])-c; c[k]=b[i];&#125;printf("%d\n",cnt); Q3 luoguP1439 最长公共子序列给出$1-n$的两个排列$P1$和$P2$，求它们的最长公共子序列。对于$100%$的数据，$n \leq 100000$ 分析：长度为100000的排列如果使用普通的O(n^2)的求LCS的dp方法肯定无法通过。这道题与普通的求LCS不同，是两个1-n的排列，根据排列所有数字出现一次的性质可以考虑把两个数组都对其中一个数组的下标进行一一映射。这样的话必有一个数组是123…n这样的升序排列，所以求LCS只需要求另一个数组的LIS即可。 例如：3&emsp;1&emsp;2&emsp;6&emsp;5&emsp;42&emsp;4&emsp;6&emsp;1&emsp;5&emsp;3 3-&gt;1&emsp;&emsp;1-&gt;2&emsp;&emsp;2-&gt;3&emsp;&emsp;6-&gt;4&emsp;&emsp;5-&gt;5&emsp;&emsp;4-&gt;6 3&emsp;1&emsp;2&emsp;6&emsp;5&emsp;4&emsp;-&gt;&emsp;1&emsp;2&emsp;3&emsp;4&emsp;5&emsp;62&emsp;4&emsp;6&emsp;1&emsp;5&emsp;3&emsp;-&gt;&emsp;3&emsp;6&emsp;4&emsp;2&emsp;5&emsp;1 代码：123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int a[maxn],b[maxn],c[maxn],tmp,n;void run()&#123; int cnt=0; for(int i=1;i&lt;=n;++i)&#123; if(b[i]&gt;c[cnt])&#123; c[++cnt]=b[i]; continue; &#125; int k=lower_bound(c+1,c+cnt+1,b[i])-c; c[k]=b[i]; &#125; printf("%d\n",cnt);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;tmp); a[tmp]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; scanf("%d",&amp;tmp); b[i]=a[tmp]; &#125; run(); return 0;&#125; Q4 求解最长公共子序列(LCS)分析：可以设dp[i][j]表示第一个数组使用了i位第二个数组使用了j位的LCS，那么最后的答案为dp[n][m]。 初始状态dp数组全为0 转移方程：12dp[i][j]=max(dp[i][j-1],dp[i-1][j]);if(a[i]==b[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1); 代码：1234567for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; dp[i][j]=max(dp[i-1][j],dp[i][j-1]); if(a1[i]==a2[j]) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+1); &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oi]]></title>
    <url>%2F2019%2F10%2F14%2Foi%2F</url>
    <content type="text"><![CDATA[Q1 两递增序列的合并给定两个非递减的整数序列A和B，将A和B合并为一个非递减的有序序列C，序列C允许有重复的数据。要求时间复杂度为$O(max(n,m))$。 分析： 代码：1234567int i=1,j=1,k=0;while(i&lt;=n&amp;&amp;j&lt;=m)&#123; if(a[i]&lt;=b[j]) c[++k]=a[i++]; else c[++k]=b[j++];&#125;while(i&lt;=n) c[++k]=a[i++];while(j&lt;=m) c[++k]=b[j++]; Q2 瑞士轮$2 \times N$ 名编号为 $1∼2N$ 的选手共进行 $R$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第$1$ 名和第 $2$ 名、第 $3$ 名和第 $4$ 名、……、第 $2K - 1$ 名和第 $2K$ 名、…… 、第 $2N - 1$ 名和第 $2N$ 名，各进行一场比赛。每场比赛胜者得 $1$分，负者得 $0$ 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在 $R$ 轮比赛过后，排名第 $Q$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 分析：先对初始数组按照分数越高，分数相同时编号越小排序。在每一轮时将第 $2N - 1$ 名和第 $2N$ 名比较得出胜者组与败者组。胜者组与败者组各自依然是有序的，按Q1方法将两个有序数组合并即可。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 200000 + 5;struct node&#123; int id; ll sl,fs; bool operator &lt; (const node &amp;k) const&#123; if(fs!=k.fs) return fs&gt;k.fs; return id&lt;k.id; &#125;&#125;p[maxn],w[maxn],l[maxn];int n,r,q;int j,k,tot;void run()&#123; j=0,k=0,tot=0; //分为败者组与胜者组 for(int i=1;i&lt;=2*n;i+=2)&#123; if(p[i].sl&lt;p[i+1].sl) ++p[i+1].fs,w[++j]=p[i+1],l[++k]=p[i]; else ++p[i].fs,w[++j]=p[i],l[++k]=p[i+1]; &#125; //Q1 j=k=1; while(j&lt;=n&amp;&amp;k&lt;=n)&#123; if(w[j].fs&gt;l[k].fs||(w[j].fs==l[k].fs&amp;&amp;w[j].id&lt;l[k].id)) p[++tot]=w[j++]; else p[++tot]=l[k++]; &#125; while(j&lt;=n) p[++tot]=w[j++]; while(k&lt;=n) p[++tot]=l[k++];&#125;int main() &#123; #ifdef LOCAL freopen("1.in", "r", stdin); freopen("1.out", "w", stdout); #endif scanf("%d%d%d",&amp;n,&amp;r,&amp;q); for(int i=1;i&lt;=2*n;++i)&#123; scanf("%lld",&amp;p[i].fs); p[i].id=i; &#125; for(int i=1;i&lt;=2*n;++i) scanf("%lld",&amp;p[i].sl); //开始先排序 sort(p+1,p+2*n+1); for(int i=1;i&lt;=r;++i)&#123; run(); &#125; printf("%d\n",p[q].id); return 0;&#125; Q3 归并排序时间复杂度：$O(nlogn)$空间复杂度：$O(n)$稳定排序 排序过程：初始序列看成n个有序子序列，每个子序列长度为1。两两合并，得到$n/2$个长度为$2$或$1$的有序子序列。再两两合并，重复直至得到一个长度为$n$的有序序列为止。 主要函数：1234567void merge_sort(int l,int r)&#123; if(l&gt;=r) return ;//长度为1时有序直接返回 int mid=(l+r)&gt;&gt;1; merge_sort(l,mid);//将左侧变为有序 merge_sort(mid+1,r);//将右侧变为有序 merge(l,mid,r);//两侧都有序后执行Q1操作将当前区间变为有序&#125; Q1操作：123456789101112void merge(int l,int mid,int r)&#123; int i,j=0,k=0,m; for(i=l;i&lt;=mid;++i) b[++j]=a[i]; for(i=mid+1;i&lt;=r;++i) c[++k]=a[i]; i=m=1; while(i&lt;=j&amp;&amp;m&lt;=k)&#123; if(c[m]&lt;b[i]) a[l++]=c[m++]; else a[l++]=b[i++]; &#125; while(i&lt;=j) a[l++]=b[i++]; while(m&lt;=k) a[l++]=c[m++];&#125; Q4 逆序对通过归并排序实现求解逆序对。分析：当归并排序进行合并操作时左右两侧的序列都是有序序列。如果右侧序列第 $j$ 个数小于左侧序列第 $i$ 个数，那么右侧序列第 $j$ 个数必定小于左侧序列第 $i+1$, $i+2$, …, $n$ 个数，所以这时有 $n-j+1$ 个逆序对存在；如果右侧序列第 $j$ 个数大于左侧序列第 $i$ 个数，这时没有逆序对存在，因为右侧的数大于左侧的数是顺序的；如果右侧序列第 $j$ 个数等于左侧序列第 $i$ 个数，此时不知道左侧有多少数字大于右侧，所以将左侧下标右移即可。 代码：12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 500000 + 5;int a[maxn],b[maxn],c[maxn],n;ll ans;void merge(int l,int mid,int r)&#123; int i,j=0,k=0,m; for(i=l;i&lt;=mid;++i) b[++j]=a[i]; for(i=mid+1;i&lt;=r;++i) c[++k]=a[i]; i=m=1; while(i&lt;=j&amp;&amp;m&lt;=k)&#123; //小于的时候计算逆序对 if(c[m]&lt;b[i]) ans+=j-i+1,a[l++]=c[m++]; //大于时无逆序对，等于时移动指针 else a[l++]=b[i++]; &#125; while(i&lt;=j) a[l++]=b[i++]; while(m&lt;=k) a[l++]=c[m++];&#125;void merge_sort(int l,int r)&#123; if(l&gt;=r) return ; int mid=(l+r)&gt;&gt;1; merge_sort(l,mid); merge_sort(mid+1,r); merge(l,mid,r);&#125;int main() &#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i) scanf("%d",&amp;a[i]); merge_sort(1,n); printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bjfu机试]]></title>
    <url>%2F2019%2F10%2F08%2Fbjfu%E6%9C%BA%E8%AF%95%2F</url>
    <content type="text"><![CDATA[保研分数计算&emsp;&emsp;综合总分=学分积$\times$0.85+量化$\times$0.05+机试题$\times$0.06+面试$\times$0.04 注意事项 考试时间为两个小时使用纸质试卷 不能使用stl与algorithm中封装好的库函数 java或py不能使用封装好的容器和函数 链表、递归、排序、文件读写一定要熟练 题目 第一题签到题求出一个四位数前两位和后两位相等并且是平方数 第二题oj数据结构习题原题链接http://www.bjfuacm.com/problem/235 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n,k;typedef struct Node&#123; int val; struct Node *next;&#125;Node,*link;void init(link &amp;l)&#123; l=new Node; l-&gt;next=NULL;&#125;void create(link &amp;L)&#123; link l=L,p; for(int i=1;i&lt;=n;++i)&#123; init(p);scanf("%d",&amp;p-&gt;val); l-&gt;next=p;l=l-&gt;next; &#125; scanf("%d",&amp;k);&#125;void findk(link L)&#123; link l=L-&gt;next;int pos=1; while(pos&lt;n-k+1)&#123; l=l-&gt;next;++pos; &#125; cout&lt;&lt;l-&gt;val&lt;&lt;endl;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); link L,l,p; while(cin&gt;&gt;n)&#123; if(n==0) break; init(L); create(L); findk(L); &#125; return 0;&#125; 第三题要求先从文本文件中读取如下所示数据(数据瞎写的)，然后对数据按关键字数字第二关键字姓名进行升序排序，最后在$O(n)$复杂度内对相同数字数据去重。特别的，根据样例输出结果可知要求使用稳定排序。这道题并没有要求使用链表，所以数组和链表都可做，并且私以为数组更好写。张三 16王五 21李四 16 123456789101112131415161718//去重//没运行，看思路即可int *flag;void Delete()&#123; flag = new int[n]; int tot=n,cnt=0; for(int i=1;i&lt;=n;++i)&#123; if(flag[a[i].id])&#123; ++cnt; --tot; &#125; else&#123; flag[a[i].id]=1; &#125; a[i-cnt]=a[i]; &#125; n=tot;&#125; 给出A(B(,D(,)),C(E(,),))1.要求建立如下图所示的树2.对树进行前序中序后序遍历3.oj原题：http://www.bjfuacm.com/problem/267 1234567891011121314151617181920\\建树代码void init(tree &amp;t)&#123; t=new node; t-&gt;lcd=t-&gt;rcd=NULL;&#125;void create(tree &amp;t,char c)&#123; init(t);t-&gt;c=c; getchar()//滤左括号 c=getchar(); if(c!=',')&#123; create(t-&gt;lcd,c); getchar();//滤逗号 &#125; c=getchar(); if(c!=')')&#123; create(t-&gt;rcd,c); getchar();//滤右括号 &#125;&#125;//也可以把给出式子转换为$AB#D##CE###$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//oj原题代码#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef struct Node&#123; char c; struct Node *lcd,*rcd;&#125;Node,*tree;void init(tree &amp;t)&#123; t=new Node; t-&gt;rcd=t-&gt;lcd=NULL;&#125;void create(tree &amp;t,char c,int &amp;flag)&#123; init(t);t-&gt;c=c; c=getchar(); if(c!='0') create(t-&gt;lcd,c,flag); c=getchar(); if(c!='0') create(t-&gt;rcd,c,flag);&#125;int findMax(tree t)&#123; int ans=0; if(t-&gt;lcd==NULL&amp;&amp;t-&gt;rcd==NULL) return 0; if(t-&gt;lcd!=NULL) ans=max(findMax(t-&gt;lcd)+1,ans); if(t-&gt;rcd!=NULL) ans=max(findMax(t-&gt;rcd)+1,ans); return ans;&#125;char s[1001];void output(tree t,int len,int pos,int ans,int &amp;flag)&#123; s[pos]=t-&gt;c;s[pos+1]='\0'; if(len==ans)&#123; printf("%d\n%s\n",pos+1,s);flag=1; return ; &#125; if(t-&gt;lcd!=NULL) output(t-&gt;lcd,len+1,pos+1,ans,flag); if(flag==1) return ; if(t-&gt;rcd!=NULL) output(t-&gt;rcd,len+1,pos+1,ans,flag); s[pos]='\0';&#125;int main()&#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); tree t; char c; while((c=getchar())!='0')&#123; int x=0,y=0,z=0,e=0; create(t,c,x); int len=findMax(t); output(t,y,z,len,e); c=getchar(); &#125; return 0;&#125; 2020保研结果]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[digital]]></title>
    <url>%2F2019%2F06%2F03%2Fdigital%2F</url>
    <content type="text"><![CDATA[digital1sudo yum -y install wget 1wget https://install.direct/go.sh 1sudo yum install zip unzip 1sudo bash go.sh 1sudo systemctl start v2ray 1cat /etc/v2ray/config.json 1wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>digital</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019蓝桥杯 糖果]]></title>
    <url>%2F2019%2F05%2F19%2F2019lanqiaotangguo%2F</url>
    <content type="text"><![CDATA[糖果题目大意是给$n$包糖果，每包糖果有$k$颗不同口味的糖，糖的口味以一共$m$种，问最少购买多少包糖果可以凑齐所有的口味。$ 1 \leq m,k \leq 20 ,1 \leq n \leq 100 $ #题解状压DP裸题，将每一种口味看作是二进制的一位，那么每一包糖果都可以看作是一个二进制数字，而最终的目的m种口味也是一个二进制数。所以有$ dp[i] $表示第i个二进制数有多少种口味的糖也即有多少个1。递推式为$ dp[i|packet[j]] = min(dp[i]+1,dp[i|packet[j]]), 1 \leq j \leq n, 1 \leq i \leq 2^m-1 $ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 200000 + 5;int n,m,k,dp[maxn],pac[107];int main() &#123; #ifdef LOCAL freopen("2019lanqiaotangguo.in", "r", stdin); freopen("2019lanqiaotangguo.out", "w", stdout); #endif scanf("%d%d%d",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=k;j++)&#123; int x; scanf("%d",&amp;x); pac[i]+=1&lt;&lt;(x-1); &#125; &#125; dp[0]=0; int ed=(1&lt;&lt;m)-1; for(int i=1;i&lt;=ed;++i) dp[i]=1000000000; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;=ed;j++)&#123; dp[j|pac[i]]=min(dp[j]+1,dp[j|pac[i]]); &#125; &#125; if(dp[ed]==1000000000) printf("-1\n"); else printf("%d\n",dp[ed]); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文自动机]]></title>
    <url>%2F2019%2F05%2F03%2Fuoj103%2F</url>
    <content type="text"><![CDATA[回文自动机回文问题终极神器Pam，再也不用manacher+Sam写到崩溃了。 概述回文自动机是一个DFA，简称Pam，在Pam能得到一个串中所有本质不同的所有回文串以及其出现的次数（以及其它很多东西）。是由毛子神犇MikhailRubinchik在2014年提出的一个数据结构。Pam由两棵树组成，一棵树的节点存储所有长度为奇数的回文串，另一颗的节点存储所有长度为偶数的回文串。注意树中并不真正的存储回文串，而是可以通过自动机边转移时得到回文串。两棵树由fail指针相连，避免了分类讨论（Pam最绝妙之处）。在转移时如果上一个状态的回文串的左右两边字母相同表示可以由此字母转移到下一个回文状态。如果当前状态的左右两边字母不同那么就通过fail指针转移到当前串的最长回文后缀上去接着寻找，直到找到满足条件的点为止。 定义 tree[maxn][26]:代表DFA由边转移得到的节点 len[maxn]:当前节点表示的回文串的长度 cnt[maxn]:当前回文串在原串中出现的次数 fail[maxn]:当前回文串的最长回文后缀所在节点编号 tot:节点编号，0为偶数树的根，1为奇数树的根 last:上一个状态的节点编号 设上一个状态点为last，转移得到的点为v，显然由概述可知$len[v]=len[last]+2, len[0]=0, len[1]=-1$初始化$fail[0]=1,fail[1]=0$，且当前点的最大回文后缀可以通过上一个状态的最大回文后缀一直寻找最大回文后缀找到。 abba的Pam如下图所示： 例题 uoj103:求$max(times[i]*len[i])$，$times$表示本质不同的回文串出现的次数，$len$表示回文串长度。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 300000 + 5;int len[maxn],cnt[maxn],fail[maxn],tot,tree[maxn][26],last;char s[maxn];struct Pam&#123; void init()&#123; tot=-1; len[++tot]=0;fail[tot]=1; len[++tot]=-1; last=0; &#125; void insert(int x)&#123; int now = last; while(s[x]!=s[x-len[now]-1]) now=fail[now]; if(!tree[now][s[x]-'a'])&#123; len[++tot]=len[now]+2; int now_fail=fail[now]; while(s[x]!=s[x-len[now_fail]-1]) now_fail=fail[now_fail]; fail[tot]=tree[now_fail][s[x]-'a']; tree[now][s[x]-'a']=tot; &#125; last=tree[now][s[x]-'a']; ++cnt[tree[now][s[x]-'a']]; &#125; ll create(int n)&#123; for(int i=1;i&lt;=n;++i)&#123; insert(i); &#125; ll ans=0; for(int i=tot;i&gt;=2;--i)&#123; cnt[fail[i]]+=cnt[i]; ans=max(ans,1ll*cnt[i]*len[i]); &#125; return ans; &#125;&#125;p;int main() &#123; #ifdef LOCAL freopen("uoj103.in", "r", stdin); freopen("uoj103.out", "w", stdout); #endif scanf("%s",s+1); p.init(); printf("%lld\n", p.create(strlen(s+1))); return 0;&#125; 2018南京网络赛I:给一个数字串，求本质不同的回文子串的和。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2000000 + 5;const ll mod = 1e9+7;int tree[maxn][11],last,fail[maxn],tot,len[maxn],n,ch[maxn];ll sum[maxn],ans,sm[maxn],sub[maxn];char s[maxn];struct Pam&#123; void init()&#123; ll res=1; for(int i=1;i&lt;=n;++i)&#123; sub[i]=res; sm[i]=s[i]-'0'; res=res*10%mod; &#125; tot=-1; fail[++tot]=1;len[tot]=0; len[++tot]=-1;ch[tot]=1; &#125; void insert(int x)&#123; int now=last; while(s[x]!=s[x-len[now]-1]) now=fail[now]; int tmp=s[x]-'0'; if(!tree[now][tmp])&#123; len[++tot]=len[now]+2; sum[tot]=(((sum[now]*10%mod+sm[x]*sub[len[now]+2]%mod)%mod+sm[x-len[now]-1])%mod-sm[x-len[now]-1]*ch[now]+mod)%mod; ans=(ans+sum[tot])%mod; int now_fail=fail[now]; while(s[x]!=s[x-len[now_fail]-1]) now_fail=fail[now_fail]; fail[tot]=tree[now_fail][tmp]; tree[now][tmp]=tot; &#125; last=tree[now][tmp]; &#125; void create()&#123; init(); for(int i=1;i&lt;=n;++i)&#123; insert(i); &#125; printf("%lld\n",ans); &#125;&#125;p;int main() &#123; #ifdef LOCAL freopen("2018nanjingonlineI.in", "r", stdin); freopen("2018nanjingonlineI.out", "w", stdout); #endif scanf("%s",s+1); n=strlen(s+1); p.create(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>pam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj3991]]></title>
    <url>%2F2019%2F04%2F29%2Fbzoj3991%2F</url>
    <content type="text"><![CDATA[寻宝游戏问题小B最近正在玩一个寻宝游戏，这个游戏的地图中有$N$个村庄和$N-1$条道路，并且任何两个村庄之间有且仅有一条路径可达。游戏开始时，玩家可以任意选择一个村庄，瞬间转移到这个村庄，然后可以任意在地图的道路上行走，若走到某个村庄中有宝物，则视为找到该村庄内的宝物，直到找到所有宝物并返回到最初转移到的村庄为止。小B希望评测一下这个游戏的难度，因此他需要知道玩家找到所有宝物需要行走的最短路程。但是这个游戏中宝物经常变化，有时某个村庄中会突然出现宝物，有时某个村庄内的宝物会突然消失，因此小B需要不断地更新数据，但是小B太懒了，不愿意自己计算，因此他向你求助。为了简化问题，我们认为最开始时所有村庄内均没有宝物. Input第一行，两个整数$N$、$M$，其中$M$为宝物的变动次数。 接下来的$N-1$行，每行三个整数$x$、$y$、$z$，表示村庄$x$、$y$之间有一条长度为z的道路。接下来的$M$行，每行一个整数$t$，表示一个宝物变动的操作。若该操作前村庄$t$内没有宝物，则操作后村庄内有宝物；若该操作前村庄$t$内有宝物，则操作后村庄内没有宝物。 Output$M$行，每行一个整数，其中第$i$行的整数表示第$i$次操作之后玩家找到所有宝物需要行走的最短路程。若只有一个村庄内有宝物，或者所有村庄内都没有宝物，则输出$0$。 Sample Input4 51 2 302 3 502 4 6023421 Sample Output0100220220280 Hint$1 \leq N \leq 100000$$1 \leq M \leq 100000$对于全部的数据，$1 \leq z \leq 10^9$ Solve给定一棵树中的点集，每次操作删除或者增加点集中的一个点，询问$ 2\times \sum dis$ 是多少。$ 2\times \sum dis = \sum_2^n{dis_{i,i-1}} + dis_{1,n}$。其中下标号为各个点的dfs序。对于每次操作，只需要用set维护这个点集即可。加上一个点$ ans=ans+dis_{pre,pos}+dis_{pos,next}-dis_{pre,next} $。减去一个点$ ans=ans-dis_{pre,pos}-dis_{pos,next}+dis_{pre,next} $。最后输出$ ans+add , add=dis_{1,n} $。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int n,m,head[maxn],cnt,flag[maxn],dfn[maxn],rnk[maxn],tot;struct edge&#123; int v,next;ll w;&#125;e[maxn&lt;&lt;1];void init()&#123; cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].w=w;e[cnt].next=head[u]; head[u]=cnt;&#125;int grade[maxn][21];ll val[maxn][21],dep[maxn];void dfs(int u,int fa,int d)&#123; dep[u]=d;dfn[u]=++tot;rnk[tot]=u; for(int i=1;i&lt;=20;++i)&#123; grade[u][i]=grade[grade[u][i-1]][i-1]; val[u][i]=val[u][i-1]+val[grade[u][i-1]][i-1]; &#125; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; grade[v][0]=u;val[v][0]=w;dfs(v,u,d+1); &#125;&#125;ll lca(int x,int y)&#123; ll ans=0; if(dep[x]&gt;dep[y]) swap(x,y); for(int i=20;i&gt;=0;--i)&#123; if(dep[x]&lt;=dep[grade[y][i]])&#123; ans+=val[y][i]; y=grade[y][i]; &#125; &#125; for(int i=20;i&gt;=0;--i)&#123; if(grade[x][i]!=grade[y][i])&#123; ans+=(val[x][i]+val[y][i]); x=grade[x][i];y=grade[y][i]; &#125; &#125; if(x!=y) ans+=(val[x][0]+val[y][0]); return ans;&#125;set&lt;int&gt; st;int main() &#123; #ifdef LOCAL freopen("bzoj3991.in", "r", stdin); freopen("bzoj3991.out", "w", stdout); #endif scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;n;++i)&#123; int f,t;ll vv; scanf("%d%d%lld",&amp;f,&amp;t,&amp;vv); add(f,t,vv);add(t,f,vv); &#125; dfs(1,-1,1); ll ans=0,add;st.insert(0),st.insert(n+1); while(m--)&#123; int pos;add=0; scanf("%d",&amp;pos); if(!flag[pos]) st.insert(dfn[pos]); int pre=*--st.find(dfn[pos]); int nxt=*++st.find(dfn[pos]); if(!flag[pos])&#123; flag[pos]=1; if(pre&gt;0) ans+=lca(pos,rnk[pre]); if(nxt&lt;n+1) ans+=lca(pos,rnk[nxt]); if(pre&gt;0&amp;&amp;nxt&lt;n+1) ans-=lca(rnk[pre],rnk[nxt]); &#125; else&#123; flag[pos]=0; st.erase(dfn[pos]); if(pre&gt;0) ans-=lca(pos,rnk[pre]); if(nxt&lt;n+1) ans-=lca(pos,rnk[nxt]); if(pre&gt;0&amp;&amp;nxt&lt;n+1) ans+=lca(rnk[pre],rnk[nxt]); &#125; if(st.size()&gt;=4) add=lca(rnk[*++st.find(0)],rnk[*--st.find(n+1)]); printf("%lld\n",ans+add); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx+uwsgi+django原理]]></title>
    <url>%2F2019%2F04%2F28%2Fnginxuwsgidjango%2F</url>
    <content type="text"><![CDATA[nginx+uwsgi+django介绍 Nginx是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。 uWSGI是一个web服务器，它同时实现了uwsgi协议和WSGI协议。 概念说明 APP（我们的网站），例如django，bottle这些。记录怎么处理客户端发来的请求的逻辑部分。 uWSGI，是一个程序，充当Web服务器或中间件。 如果架构是Nginx+uWSGI+APP，uWSGI是一个中间件 如果架构是uWSGI+APP，uWSGI是一个服务器 Web协议 WSGI，是一个协议，Python用于Web开发的协议。 uwsgi，是uWSGI程序实现的一个自有的协议。 Web协议出现顺序：CGI -&gt; FCGI -&gt; WSGI -&gt; uwsgi CGI，最早的协议 FCGI，比CGI快 WSGI，Python专用的协议 uwsgi，比FCGI和WSGI都快，是uWSGI项目自有的协议，主要特征是采用二进制来存储数据，之前的协议都是使用字符串，所以在存储空间和解析速度上，都优于字符串型协议。 Nginx(反向代理服务器) 什么是反向代理？ 正向代理，翻墙用的代理服务器就是正向代理，浏览器主动请求代理服务器，代理服务器转发请求到对应的目标服务器 反向代理，部署在Web服务器上，代理所有外部网络对内部网络的访问。浏览器访问服务器，必须经过这个代理，是被动的。 正向代理的主动方是客户端，反向代理的主动方是Web服务器。 反向代理的作用： 安全。客户端对Web服务器的访问需要先经过反向代理服务器。这样可以防止外部程序对Web服务器的直接攻击。 负载均衡。反向代理服务器可以根据Web服务器的负载情况，动态地把HTTP请求交给不同的Web服务器来处理，前提是要有多个Web服务器。（这个和我们的网站没啥关系） 提升Web服务器的IO性能。一个HTTP请求的数据，从客户端传输给服务器，是需要时间的，例如N秒，如果直接传给Web服务器，Web服务器就需要让一个进程阻塞N秒，来接收IO，这样会降低Web服务器的性能。如果使用反向代理服务器，先让反向代理服务器接收完整的HTTP请求，再把请求发给Web服务器，就能提升Web服务器的性能。还有一些静态文件的请求，可以直接交给反向代理来处理，不需要经过Web服务器。 优点 uWSGI+Django比单独使用Django的好处： 支持的并发量更高 方便管理多进程，发挥多核的优势 提升性能，因为uwsgi协议比WSGI协议有优势 Nginx+uWSGI+Django比uWSGI+Django好处（参考反向代理的作用1与作用3）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vscode+cmder]]></title>
    <url>%2F2019%2F04%2F28%2Fvscode-cmder%2F</url>
    <content type="text"><![CDATA[更换内置终端在settings.json加上下面的代码,将其中路径更换就可以了。123"terminal.integrated.shell.windows": "cmd.exe","terminal.integrated.env.windows": &#123;"CMDER_ROOT": "D:\\cmder"&#125;,"terminal.integrated.shellArgs.windows": ["/k", "D:\\cmder\\vendor\\init.bat"], 添加tasks配置在tasks.json设置全局option如下：12345678910111213"version": "2.0.0", "windows": &#123; "options": &#123; "shell": &#123; //在执行task时启动cmder，不自定义shell会报错 "executable": "cmd.exe", "args": [ "/d", "/c", "D:\\cmder\\vendor\\init.bat", "&amp;&amp;" ] &#125;, "cwd": "$&#123;fileDirname&#125;" //执行命令前切换到当前文件上一级 &#125; &#125;, "tasks": []]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tasks.json in vscode]]></title>
    <url>%2F2019%2F04%2F28%2Ftasks-jsoninvscode%2F</url>
    <content type="text"><![CDATA[tasks配置简介tasks的任务就是帮我们快捷的在命令行中(VSC内置的PS，期待哪天能配合cmder)输出命令。按ctrl+shift+b可以在所有编译任务中选择一个编译任务。也可以为任务设置快捷键。 option设置在tasks.json设置全局option如下：12345678910111213"version": "2.0.0", "windows": &#123; "options": &#123; "shell": &#123; //在执行task时启动cmder，不自定义会报错(如果使用cmder才配置这个) "executable": "cmd.exe", "args": [ "/d", "/c", "D:\\cmder\\vendor\\init.bat", "&amp;&amp;" ] &#125;, "cwd": "$&#123;fileDirname&#125;" //执行命令前切换到当前文件上一级 &#125; &#125;, "tasks": [] Python配置12345678910111213&#123; "label": "python", //任务名称 "type": "shell", "group": &#123; //所在分组 "kind": "build", //类型编译 "isDefault": true //添加到默认编译类型 &#125;, "command": "D:/Anaconda3/python.exe", //编译命令 "args": [ "$&#123;fileBasename&#125;" //参数，表示文件路径 ], "problemMatcher": [] //遇到错误提示&#125; dot配置12345678910111213141516171819202122&#123; "label": "dot", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "reveal": "silent",//只在出错时弹出命令行 "echo": true, "showReuseMessage": false, "panel": "shared" &#125;, "command": "dot", "args": [ "-Tpdf", "$&#123;fileBasename&#125;", "-o", "$&#123;fileBasenameNoExtension&#125;.pdf" ], "problemMatcher": []&#125;]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zoj4109]]></title>
    <url>%2F2019%2F04%2F28%2Fzoj4109%2F</url>
    <content type="text"><![CDATA[Welcome PartyProblemsThe 44th World Finals of the International Collegiate Programming Contest (ICPC 2020) will be held in Moscow, Russia. To celebrate this annual event for the best competitive programmers around the world, it is decided to host a welcome party for all participants of the World Finals, numbered from to for convenience. The party will be held in a large hall. For security reasons, all participants must present their badge to the staff and pass a security check in order to be admitted into the hall. Due to the lack of equipment to perform the security check, it is decided to open only one entrance to the hall, and therefore only one person can enter the hall at a time. Some participants are friends with each other. There are pairs of mutual friendship relations. Needless to say, parties are more fun with friends. When a participant enters the hall, if he or she finds that none of his or her friends is in the hall, then that participant will be unhappy, even if his or her friends will be in the hall later. So, one big problem for the organizer is the order according to which participants enter the hall, as this will determine the number of unhappy participants. You are asked to find an order that minimizes the number of unhappy participants. Because participants with smaller numbers are more important (for example the ICPC director may get the number 1), if there are multiple such orders, you need to find the lexicographically smallest one, so that important participants enter the hall first. Please note that if participant and are friends, and if participant and are friends, it’s NOT necessary that participant and are friends. InputThere are multiple test cases. The first line of the input contains a positive integer $T$, indicating the number of cases. For each test case: The first line contains two integers $n$ and $m$ $(1 \leq n,m \leq 10^6)$, the number of participants and the number of friendship relations. The following lines each contains two integers $a$ and $b$ $(1 \leq a,b \leq n, a \not= b)$, indicating that the $a$-th and the $b$-th participant are friends. Each friendship pair is only described once in the input. It is guaranteed that neither the sum of $n$ nor the sum of $m$ of all cases will exceed $10^6$. OutputFor each case, print a single integer on the first line, indicating the minimum number of unhappy participants. On the second line, print a permutation of $1$ to $n$ separated by a space, indicating the lexicographically smallest ordering of participants entering the hall that achieves this minimum number. Please, DO NOT output extra spaces at the end of each line, or your solution may be considered incorrect! Sample Input24 31 21 31 44 21 23 4Sample Output11 2 3 421 2 3 4 Solve给一个森林，只有当森林里节点的父亲节点被遍历过这个点才有机会被遍历。求遍历森立的最小字典序并输出。并查集判森林。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int maxn = 1000000 + 5;int f[maxn],a,b,_,n,m,flag[maxn];vector&lt;int&gt; e[maxn];int find(int x)&#123; int tmp=x; while(tmp!=f[tmp]) tmp=f[tmp]; int y; while(x!=tmp)&#123; y=f[x]; f[x]=tmp; x=y; &#125; return x; &#125;int bfs()&#123; int ans=0; vector&lt;int&gt; vec; priority_queue&lt;int,vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i=1;i&lt;=n;++i)&#123; if(f[i]==i)&#123; ++ans;q.push(i); &#125; flag[i]=0; &#125; while(!q.empty())&#123; int u=q.top();q.pop(); if(flag[u]) continue; vec.push_back(u); flag[u]=1; for(int i=0;i&lt;e[u].size();++i)&#123; q.push(e[u][i]); &#125; &#125; printf("%d\n",ans); for(int i=0;i&lt;vec.size();++i) printf("%d%c",vec[i],i==vec.size()-1?'\n':' ');&#125;int main() &#123; #ifdef LOCAL freopen("zoj4109.in", "r", stdin); freopen("zoj4109.out", "w", stdout); #endif scanf("%d",&amp;_); while(_--)&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; f[i]=i;e[i].clear(); &#125; for(int i=1;i&lt;=m;++i)&#123; int ff,t; scanf("%d%d",&amp;ff,&amp;t); e[ff].push_back(t); e[t].push_back(ff); int fx=find(ff),fy=find(t); if(fx&lt;fy)&#123; f[fy]=fx; &#125; else&#123; f[fx]=fy; &#125; &#125; bfs(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>bfs</tag>
        <tag>dsu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-2050-1006]]></title>
    <url>%2F2019%2F04%2F27%2F2019-2050-1006%2F</url>
    <content type="text"><![CDATA[冰水挑战描述现在，我们要依次面对 $n$ 个冰水挑战，每个挑战你都可以选择接受或不接受。接受第 $i$ 个挑战会让你丧失 $a_i$点体力，因为每个挑战所处的环境不同，如果你要挑战它，在挑战它之前你的体力 $x$ 会变成 $min(x,b_i)$，当你完成这个挑战的时候，你的体力会变成 $x−a_i$，体力任何时候不允许小于等于 $0$，无论你是否接受第 $i$ 个挑战，在这个挑战结束以后你的体力都会增加 $c_i$。现在我们想知道最多可以完成多少个挑战。 输入格式第一行一个正整数 $T (T \leq 50)$ 表示数据组数。接下来 $T$ 组数据，每组第一行两个正整数 $n,c (1 \leq n \leq 10^3, 1 \leq c \leq 10^9)$，表示挑战的数量和初始体力，接下来 $n$ 行，每行三个非负整数 $a_i,b_i,c_i(0 \leq a_i, b_i, c_i \leq 10^9)$。 输出格式对于每组数据输出一行一个数，表示你最多能完成几个挑战。 样例输入23 101 2 04 8 36 10 12 11 1 11 1 1 样例输出20 Solve这是一道01背包的改版题，$dp[i][j]$表示前$i$个冰桶挑战挑战$j$个的最大值，每到一个挑战要判断是否满足条件，满足的话进行状态转移，因为不管是否挑战都要加上$c_i$所以一定要有加上$c_i$的状态转移。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 1e3+7;ll dp[N][N],st;ll a[N],b[N],c[N];int _,n;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; scanf("%d%lld",&amp;n,&amp;st);memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;++i)&#123; scanf("%lld%lld%lld",&amp;a[i],&amp;b[i],&amp;c[i]); &#125; dp[0][0]=st; for(int i=1;i&lt;=n;++i)&#123; for(int j=0;j&lt;i;++j)&#123; if(dp[i-1][j])&#123; dp[i][j]=max(dp[i][j],dp[i-1][j]+c[i]); if(min(dp[i-1][j],b[i])&gt;a[i]) dp[i][j+1]=max(dp[i][j+1],min(dp[i-1][j],b[i])-a[i]+c[i]); &#125; &#125; &#125; /*dp[0]=st; for(int i=1;i&lt;=n;++i)&#123; dp[0]+=c[i]; for(int j=i;j&gt;0;--j)&#123; if(dp[j-1])&#123; ll tmp=min(dp[j-1],b[i]); if(tmp&gt;a[i]) dp[j]=max(dp[j],tmp-a[i]+c[i]); if(j-1) dp[j-1]+=c[i]; &#125; &#125; &#125;*/ for(int i=n;i&gt;=0;--i)&#123; if(dp[n][i])&#123; printf("%d\n",i); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-2050-1005]]></title>
    <url>%2F2019%2F04%2F27%2F2019-2050-1005%2F</url>
    <content type="text"><![CDATA[球赛描述Alice和Bob在进行乒乓球比赛，比赛一共打了 $n$ 个球，对于每一球，如果Alice赢了，那么裁判员会在计分板上记下’$A$’，如果Bob赢了则会记下’$B$’。时间转眼间到了2050年，计分板上某些信息因为时间流逝丢失了，但我们想要复现当年的激烈局面。丢失的位置用’$?$’表示，我们想知道，计分板上对应的乒乓球球赛，最多进行了多少局（最后一局可以没打完，但是如果没打完的话就不计入答案）？在一局比赛中，先得$11$分的一方为胜方，$10$平后，先多得$2$分的一方为胜方。 输入格式对于每组数据输出一行一个数，表示乒乓球球赛最多进行的局数。 输出格式每行输出一个整数表示最小花费。 样例输入1AAAAAAAAAA?BBBBBBBBBB? 样例输出2 Solve设$dp[i][j][k]$表示前 $i$ 场对局比分为 $j:k$ 的最多局数。由于$10:10$的比分与$9:9$的比分是等价的，所有如果有$10:10$的比分出现就把它变成$9:9$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 10000 + 5;int dp[maxn][12][12];//表示前i场对局比分为j:k的最多局数char s[maxn];struct node&#123; int x, y, z;&#125;;node cal(int i, int j)&#123; node tmp; if (i == 11 || j == 11) &#123; tmp.x = tmp.y = 0; tmp.z = 1; &#125; else &#123; tmp.z = 0; if (i == 10 &amp;&amp; j == 10) &#123; tmp.x = tmp.y = 9; &#125; else &#123; tmp.x = i; tmp.y = j; &#125; &#125; return tmp;&#125;int main()&#123;#ifdef LOCAL freopen("1005.in", "r", stdin); freopen("1005.out", "w", stdout);#endif int _; scanf("%d", &amp;_); while (_--) &#123; scanf("%s", s); int len = strlen(s); memset(dp, 128, sizeof(dp)); dp[0][0][0] = 0; for (int i = 1; i &lt;= len; ++i) &#123; for (int j = 0; j &lt;= 10; ++j) &#123; for (int k = 0; k &lt;= 10; ++k) &#123; if (s[i - 1] == 'A' || s[i - 1] == '?') &#123; node tmp = cal(j + 1, k); dp[i][tmp.x][tmp.y] = max(dp[i][tmp.x][tmp.y], dp[i - 1][j][k] + tmp.z); &#125; if (s[i - 1] == 'B' || s[i - 1] == '?') &#123; node tmp = cal(j, k + 1); dp[i][tmp.x][tmp.y] = max(dp[i][tmp.x][tmp.y], dp[i - 1][j][k] + tmp.z); &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt;= 10; ++i) for (int j = 0; j &lt;= 10; ++j) ans = max(ans, dp[len][i][j]); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1935]]></title>
    <url>%2F2019%2F04%2F23%2Fbzoj1935%2F</url>
    <content type="text"><![CDATA[Tree 园丁的烦恼问题很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……” “是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。 “该死的，你究竟是什么来头？” “陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。 这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。 Input第一行有两个整数$n$，$m$（$0 \leq n \leq 500000$，$1 \leq m \leq 500000$）。$n$代表皇家花园的树木的总数，$m$代表骑士们询问的次数。 文件接下来的$n$行，每行都有两个整数$x_i$，$y_i$，代表第$i$棵树的坐标（$0 \leq x_i$，$y_i \leq 10000000$）。 文件的最后$m$行，每行都有四个整数$a_j$，$b_j$，$c_j$，$d_j$，表示第$j$次询问，其中所问的矩形以（$a_j$，$b_j$）为左下坐标，以（$c_j$，$d_j$）为右上坐标。 Output共输出$m$行，每行一个整数，即回答国王以（$a_j$，$b_j$）和（$c_j$，$d_j$）为界的矩形里有多少棵树。 Sample Input3 10 00 11 00 0 1 1 Sample Output3 Solve给$n$($n \leq 10^5$)个点，$0 \leq x_i,y_i \leq 10^7$。随后m次询问子矩形中有多少个点。二维偏序问题，先把询问的矩形拆成四个以原点为左下角的子矩形，然后把点与询问按$x$轴排序。for所有的询问，每到一个询问把$x$轴坐标小于他的点的$y$轴坐标加入到bit中，然后再询问得到的就是$x$与$y$都小于他的点。 Note如果点的范围再扩大得话使用离散化即可，因为点的个数始终是很小的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 500000 + 5;const int N = 1e7+1;int c[N+1],x1,yy,x2,y2,n,m,ans[maxn];struct Point&#123; int x,y,flag,pos; bool operator &lt; (const Point &amp; k)const&#123; if(x!=k.x) return x&lt;k.x; return y&lt;k.y; &#125;&#125;p[maxn],q[maxn&lt;&lt;2];void add(int x,int y)&#123; for(;x&lt;=N;x+=x&amp;(-x))&#123; c[x]+=y; &#125;&#125;int query(int x)&#123; int ans=0; for(;x;x-=x&amp;(-x)) ans+=c[x]; return ans;&#125;int main() &#123; #ifdef LOCAL freopen("bzoj1935.in", "r", stdin); freopen("bzoj1935.out", "w", stdout); #endif scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;++i)&#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y);p[i].x+=1;p[i].y+=1; &#125; for(int i=1;i&lt;=m;++i)&#123; scanf("%d%d%d%d",&amp;x2,&amp;y2,&amp;x1,&amp;yy);x2+=1;x1+=1;y2+=1;yy+=1; int t=4*(i-1)+1; q[t].x=x1,q[t].y=yy,q[t].flag=1,q[t].pos=q[t+1].pos=q[t+2].pos=q[t+3].pos=i; if(x2-1&amp;&amp;y2-1) q[t+1].x=x2-1,q[t+1].y=y2-1,q[t+1].flag=1; if(x2-1) q[t+2].x=x2-1,q[t+2].y=yy,q[t+2].flag=-1; if(y2-1) q[t+3].x=x1,q[t+3].y=y2-1,q[t+3].flag=-1; &#125; sort(p+1,p+n+1); sort(q+1,q+4*m+1); for(int i=1,j=1;i&lt;=4*m;++i)&#123; while(p[j].x&lt;=q[i].x&amp;&amp;j&lt;=n)&#123; add(p[j].y,1);++j; &#125; ans[q[i].pos]+=(q[i].flag*query(q[i].y)); &#125; for(int i=1;i&lt;=m;++i) printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>bit</tag>
        <tag>偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[establish vscode c/c++ environment]]></title>
    <url>%2F2019%2F04%2F19%2Festablishvscodec-c-environment%2F</url>
    <content type="text"><![CDATA[Mingw on Windows之前一直使用VSC自带的Compile&amp;&amp;Run插件，但不能自定义编译参数很难受。 配置所需环境 下载VSCode 下载Mingw(如果有Codeblocks可以使用Codeblocks里的Mingw) 将Mingw的bin加入到环境变量 配置编译器路径这一步将告诉VSC使用哪个编译器对.cpp/.c文件进行编译。 按Ctrl + Shift + P打开命令板。它看起来像这样： 键入“C / C ++”，然后从建议列表中选择“ 编辑配置 ”。VSC创建一个文件c_cpp_properties.json。配置如下。 1234567891011121314151617181920&#123; "configurations": [ &#123; "name": "Win32", "includePath": [ "$&#123;workspaceFolder&#125;/**" ], "defines": [ "_DEBUG", "UNICODE", "_UNICODE" ], "compilerPath": "D:/software/CodeBlocks/MinGW/bin/g++.exe",//换成自己的gcc.exe或者g++.exe "cStandard": "c11", "cppStandard": "c++17", "intelliSenseMode": "gcc-x64"//gcc和g++使用gcc-x64 &#125; ], "version": 4&#125; 创建tasks.json这一步将对源程序进行编译，可以自己设置编译命令以及编译参数。 按Ctrl + Shift + P打开命令板，然后键入“任务”并选择Tasks: Add a default build task 然后选择 Others。VSC将创建一个tasks.json文件并在编辑器中打开它。配置如下 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; "version": "2.0.0", "tasks": [ &#123; "label": "build", "type": "shell", "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "reveal": "silent", "echo": true, "showReuseMessage": false, "panel": "shared", &#125;, "command": "g++", //编译命令 "args": [ //编译参数 "--std=c++14", "$&#123;file&#125;", //文件路径 "-o", "$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe", //将生成的filename.exe放到与.cpp文件同一文件夹下 //$&#123;fileDirname&#125;为.cpp文件上一级路径，$&#123;fileBasenameNoExtension&#125;为不带扩展的原文件名 "-g", // 生成和调试有关的信息 "-Wall", // 开启额外警告 "-D LOCAL" //编译时DEFINE一个LOCAL ], "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "\\"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125; &#125; ]&#125; 配置调试文件前两步完成之后就可以按F5对文件编译并产生.exe文件了，但是还无法调试，这一步将配置调试信息。 按Ctrl + Shift + D到调试页面，然后再点击上方小齿轮选择GDB\LLDB，VSC将创建一个launch.json文件并打开它。配置如下 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "Launch", "preLaunchTask": "build", "type": "cppdbg", "request": "launch", "program": "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe", //调试的.exe文件所在位置 "args": [], "stopAtEntry": false, "cwd": "$&#123;fileDirname&#125;", //调试将在此目录也就是文件所在目录下进行，将读取此目录下的in、out文件 "environment": [], "externalConsole": true, "MIMode": "gdb", "miDebuggerPath": "D:\\software\\CodeBlocks\\MinGW\\bin\\gdb32.exe", //填写gdb.exe所在路径 "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ]&#125; F5运行由于VSC的弹出框会一闪而逝，所以一般将输入输出重定向，也就是为什么要在tasks.json的编译参数中加上”-D LOCAL“的原因。新建一个test.cpp写上如下代码并运行，发现虽然代码中没有定义LOCAL，但是还是会重定向输入输出，因为在编译时-D命令帮我们完成了”#define LOCAL“的工作。123456789101112131415#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 100000 + 5;int x;int main() &#123; #ifdef LOCAL freopen("test.in", "r", stdin); freopen("test.out", "w", stdout); #endif cin&gt;&gt;x; cout&lt;&lt;x; puts("hh"); return 0;&#125; 编写代码片段由于每个文件都得使用重定向，那每个文件都敲一次显然是很浪费时间的。所以使用VSC提供的代码片段功能节省时间。 点击左下角齿轮并点击用户代码片段，选择cpp.json文件进行配置。 配置文件init片段，每次新建一个文件夹后可以快速补全所有信息。 配置debug片段。 配置好了每次输入acm回车即可将头文件及main函数补充完整，输入debug即可得到”#ifdef LOCAL…#endif”。 12345678910111213141516171819202122232425262728&#123; "ACM-model": &#123; "prefix": "acm", //匹配前缀，当输入这个字符串的前缀时，会有代码补全信息 "body": [ //补全的代码片段 "#include &lt;bits/stdc++.h&gt;", "using namespace std;", "typedef long long ll;", "const int maxn = $&#123;1:100000&#125; + 5;", //补全后的代码光标会停在$1处 "$2\nint main() &#123;", //按一次tab键后光标转移到$2处 "\t#ifdef LOCAL", "\t\tfreopen(\"$&#123;TM_FILENAME_BASE&#125;.in\", \"r\", stdin);", //$&#123;TM_FILENAME_BASE&#125;是提供的变量，得到不带后缀的文件名 "\t\tfreopen(\"$&#123;TM_FILENAME_BASE&#125;.out\", \"w\", stdout);", "\t#endif", "\t$0", //$0为按tab键光标的终止位置 "\treturn 0;", "&#125;" ], "description": "init acm model" &#125;, "Debug-model":&#123; "prefix": "debug", "body": [ "#ifdef LOCAL\n\t$0", "#endif" ], "description": "debug" &#125;, &#125; VSC还提供许多变量，并且允许对变量利用re和format转换，有兴趣的可以去官网看。 分屏使用]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 2050 1003]]></title>
    <url>%2F2019%2F04%2F15%2F2019-2050-1003%2F</url>
    <content type="text"><![CDATA[分宿舍描述现在一共有$n+m+2k$个人要住进房间里，包括$n+k$个男生以及$m+k$个女生，其中k对异性男女为情侣。房间有三种类型，双人间$a$元一间，三人间$b$元一间，情侣间$c$元一间。除情侣间外，其他间房都可以不住满。最少花多少钱使得所有人都有房住？ 输入格式一共$T(T \leq 50)$组数据。每组数据输入$6$个整数，分别是$n,m,k,a,b,a$。$0 \leq n,m,k \leq 10^3$, $0 \leq a,b,c \leq 10^9$。 输出格式每行输出一个整数表示最小花费。 样例输入23 0 1 1 3 33 3 2 1 6 2 样例输出36 Solve设$dp[i]$表示前i个人安排双人间和三人间的最优解。先预处理出来$dp$数组，其中$dp[0] = 0$,$dp[1] = min(a, b) = dp[2]$,$dp[3] = min(2 \times a, b)$。输出$max( dp[n+i] + dp[m+i] + (k-i) \times c ),0 \leq i\leq k$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll n,m,k,a,b,c,dp[2007];int _;ll Min(ll x,ll y)&#123; return x&gt;y?y:x;&#125;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c); dp[0]=0;dp[1]=dp[2]=Min(a,b);dp[3]=Min(2*a,b); for(int i=4;i&lt;=2003;++i)&#123; dp[i]=Min(dp[i-2]+a,dp[i-3]+b); &#125; ll ans=dp[n+k]+dp[m+k]; for(ll i=0;i&lt;k;++i)&#123; ans=Min(ans,dp[n+i]+dp[m+i]+(k-i)*c); &#125; printf("%lld\n",ans); &#125; return 0;&#125;// ll check(ll x)&#123;// ll k=x/3+(x%3==0?0:1);// ll tot=k*b;// for(ll i=0;i&lt;k;++i)&#123;// ll tmp=i*b;// ll p=x-i*3;// ll k1=p/2+(p%2==0?0:1);// tmp+=k1*a;// tot=Min(tot,tmp);// &#125;// return tot;// &#125;// int main()&#123;// scanf("%d",&amp;_);// while(_--)&#123;// ll ans=1e18;// scanf("%lld%lld%lld%lld%lld%lld",&amp;n,&amp;m,&amp;k,&amp;a,&amp;b,&amp;c);// for(ll i=0;i&lt;=k;++i)&#123;// ll tmpn=n+i,tmpm=m+i;// ll tmp=(k-i)*c;// tmp+=(check(tmpn)+check(tmpm));// ans=Min(ans,tmp);// &#125;// printf("%lld\n",ans);// &#125;// return 0;// &#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ RoundA 3]]></title>
    <url>%2F2019%2F04%2F15%2F2019GCJ-RoundA-3%2F</url>
    <content type="text"><![CDATA[Alien RhymeProblemDuring some extraterrestrial exploration, you found evidence of alien poetry! Your team of linguists has determined that each word in the alien language has an accent on exactly one position (letter) in the word; the part of the word starting from the accented letter is called the accent-suffix. Two words are said to rhyme if both of their accent-suffixes are equal. For example, the words $PROL$ and $TARPOL$ rhyme if the accented letter in both is the $O$ or the $L$, but they do not rhyme if the accented letters are the Rs, or the $R$ in $PROL$ and the $P$ in $TARPOL$, or the $O$ in $PROL$ and the $L$ in $TARPOL$. You have recovered a list of $N$ words that may be part of an alien poem. Unfortunately, you do not know which is the accented letter for each word. You believe that you can discard zero or more of these words, assign accented letters to the remaining words, and then arrange those words into pairs such that each word rhymes only with the other word in its pair, and with none of the words in other pairs. You want to know the largest number of words that can be arranged into pairs in this way. InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case starts with a line with a single integer $N$. Then, $N$ lines follow, each of which contains a string Wi of uppercase English letters, representing a distinct word. Notice that the same word can have different accentuations in different test cases. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the size of the largest subset of words meeting the criteria described above. Limits$1 \leq T \leq 100.$Time limit: 20 seconds per test set.Memory limit: 1GB.1 $\leq$ length of $W_i \leq 50$, for all $i$.Wi consists of uppercase English letters, for all $i$.$W_i \not= W_j$, for all $i \not= j$. (Words are not repeated within a test case.) Test set 1 (Visible)$2 \leq N \leq 6$. Test set 2 (Hidden)$2 \leq N \leq 1000.$ Sample Input42TARPOLPROL3TARPORPROLTARPRO6CODEJAMJAMHAMNALAMHUMNOLOM4PIHIWIFI OutputCase #1: 2Case #2: 0Case #3: 6Case #4: 2 Solve给定$n$个字符串，如果两个字符串有相同的后缀，那么后缀开始的那个字母就被这两个字符串所使用并且其它对字符串不能使用。问怎样使得对数最多。把每个字符串从后向前构建字典树，然后从下往上$dp$一下即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;int _,tree[5007][26],cnt,val[5007];char s[57];void insert()&#123; int len=strlen(s),root=0; for(int i=len-1;i&gt;=0;--i)&#123; // cout&lt;&lt;root&lt;&lt;endl; if(!tree[root][s[i]-'A']) tree[root][s[i]-'A']=++cnt; root=tree[root][s[i]-'A']; // cout&lt;&lt;root&lt;&lt;endl; &#125; val[root]=1;&#125;int dp[5007],flag[5007],ans;void dfs(int u)&#123; if(val[u]) ++dp[u]; for(int i=0;i&lt;26;i++)&#123; if(tree[u][i])&#123; dfs(tree[u][i]); dp[u]+=dp[tree[u][i]]; if(dp[u]&gt;=2&amp;&amp;!flag[u]&amp;&amp;u!=0)&#123; flag[u]=1;++ans;dp[u]-=2; &#125; &#125; &#125; return ;&#125;int main()&#123; scanf("%d",&amp;_); for(int i=1;i&lt;=_;++i)&#123; memset(dp,0,sizeof(dp)); memset(flag,0,sizeof(flag)); memset(val,0,sizeof(val)); memset(tree,0,sizeof(tree));ans=cnt=0; int n; scanf("%d",&amp;n); for(int j=1;j&lt;=n;j++)&#123; scanf("%s",s); // cout&lt;&lt;s&lt;&lt;endl; insert(); &#125; dfs(0); cout&lt;&lt;"Case #"&lt;&lt;i&lt;&lt;": "; printf("%d\n",ans*2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codeforces 609 E]]></title>
    <url>%2F2019%2F04%2F08%2Fcf609E%2F</url>
    <content type="text"><![CDATA[Minimum spanning tree for each edgeProblemConnected undirected weighted graph without self-loops and multiple edges is given. Graph contains n vertices and m edges. For each edge $(u, v)$ find the minimal possible weight of the spanning tree that contains the edge $(u, v)$. The weight of the spanning tree is the sum of weights of all edges included in spanning tree. InputFirst line contains two integers $n$ and $m$ $(1 \leq n \leq 2·10^5, n - 1 \leq m \leq 2·10^5)$ — the number of vertices and edges in graph. Each of the next $m$ lines contains three integers $u_i, v_i, w_i (1 \leq u_i, v_i \leq n, u_i \not= v_i, 1 \leq w_i \leq 10^9)$ — the endpoints of the i-th edge and its weight. OutputPrint $m$ lines. i-th line should contain the minimal possible weight of the spanning tree that contains i-th edge. The edges are numbered from $1$ to $m$ in order of their appearing in input. Examples input 5 71 2 31 3 11 4 52 3 22 5 33 4 24 5 4 output98118889 Solve先求出原图的最小生成树，如果边在最小生成树中则直接输出最小生成树的权值。否则输出MST权值减去这条边的两端点路径上的最大边再加上这条边的权值即可。倍增LCA寻找路径上的最大边即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 2e5+7;int flag[N&lt;&lt;1],head[N],cnt,n,m,f[N];int grade[N][24],dep[N];ll mx[N][24];struct edge&#123; int next,v;ll w;&#125;e[N&lt;&lt;1];struct ed&#123; int u,v,id;ll w; bool operator &lt; (const ed &amp; k)const&#123; return w&lt;k.w; &#125;&#125;e1[N&lt;&lt;1];void init()&#123; for(int i=1;i&lt;=n;i++) f[i]=i; cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].w=w;e[cnt].next=head[u]; head[u]=cnt;&#125;ll ans;int find(int x)&#123; return x==f[x]?x:f[x]=find(f[x]);&#125;void kruskal()&#123; sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int u=e1[i].u,v=e1[i].v;ll w=e1[i].w; // cout&lt;&lt;u&lt;&lt;" y "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; int fx=find(u),fy=find(v); if(fx!=fy)&#123; //cout&lt;&lt;u&lt;&lt;" x "&lt;&lt;v&lt;&lt;" "&lt;&lt;w&lt;&lt;endl; flag[i]=1; ans+=w; f[fx]=fy; add(v,u,w);add(u,v,w); &#125; &#125;&#125;void dfs(int u,int fa,int deep)&#123; dep[u]=deep; for(int i=1;i&lt;24;i++)&#123; grade[u][i]=grade[grade[u][i-1]][i-1]; mx[u][i]=max(mx[u][i-1],mx[grade[u][i-1]][i-1]); &#125; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; grade[v][0]=u;mx[v][0]=w; dfs(v,u,deep+1); &#125; return ;&#125;ll lca(int x,int y)&#123; ll tmp=0; if(dep[x]&gt;dep[y]) swap(x,y); for(int i=23;i&gt;=0;--i)&#123; if(dep[x]&lt;dep[y]&amp;&amp;dep[grade[y][i]]&gt;=dep[x])&#123; tmp=max(tmp,mx[y][i]); y=grade[y][i]; &#125; &#125; for(int i=23;i&gt;=0;--i)&#123; if(grade[x][i]!=grade[y][i])&#123; tmp=max(tmp,max(mx[x][i],mx[y][i])); x=grade[x][i];y=grade[y][i]; &#125; &#125; if(x!=y) tmp=max(tmp,max(mx[x][0],mx[y][0])); return tmp;&#125;ll a[N];int main()&#123; scanf("%d%d",&amp;n,&amp;m); init(); for(int i=1;i&lt;=m;i++)&#123; int from,to;ll val; scanf("%d%d%lld",&amp;from,&amp;to,&amp;val); e1[i].u=from,e1[i].v=to,e1[i].w=val;e1[i].id=i; &#125; kruskal(); dfs(1,-1,0); for(int i=1;i&lt;=m;++i)&#123; if(flag[i])&#123; a[e1[i].id]=ans; &#125; else&#123; a[e1[i].id]=ans-lca(e1[i].u,e1[i].v)+e1[i].w; &#125; &#125; for(int i=1;i&lt;=m;i++) printf("%lld\n",a[i]); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu2222]]></title>
    <url>%2F2019%2F04%2F07%2Fhdu2222%2F</url>
    <content type="text"><![CDATA[Keywords SearchProblem DescriptionIn the modern time, Search engine came into the life of everybody like Google, Baidu, etc.Wiskey also wants to bring this feature to his image retrieval system.Every image have a long description, when users type some keywords to find the image, the system will match the keywords with description of image and show the image which the most keywords be matched.To simplify the problem, giving you a description of image, and some keywords, you should tell me how many keywords will be match. InputFirst line will contain one integer means how many cases will follow by.Each case will contain two integers N means the number of keywords and N keywords follow. ($N \leq 10000$)Each keyword will only contains characters ‘a’-‘z’, and the length will be not longer than 50.The last line is the description, and the length will be not longer than $1000000$. OutputPrint how many keywords are contained in the description. Sample Input 15shehesayshrheryasherhs Sample Output 3 Solve这道题是$AC$自动机的经典例题，给$n$个模式串与一个主串，问有多少个模式串出现在主串中。直接构建带$fail$指针的$trie$图然后再在自动机上跑匹配即可，需要注意的是到达一个节点需要找到所有它的前缀也即一直跑$fail$指针直到失配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5+7;int _,n;int val[N],tree[N][26],fail[N],cnt;char s[N],p[N];void init()&#123; memset(tree,0,sizeof(tree)); memset(fail,0,sizeof(fail)); memset(val,0,sizeof(val)); cnt=0;&#125;void insert()&#123; int root=0,len=strlen(s); for(int i=0;i&lt;len;++i)&#123; if(!tree[root][s[i]-'a']) tree[root][s[i]-'a']=++cnt; root=tree[root][s[i]-'a']; //cout&lt;&lt;root&lt;&lt;endl; &#125; ++val[root]; return ;&#125;void build()&#123; queue&lt;int&gt; q; for(int i=0;i&lt;26;++i)&#123; if(tree[0][i])&#123; fail[tree[0][i]]=0; q.push(tree[0][i]); &#125; &#125; while(!q.empty())&#123; int now=q.front();q.pop(); //cout&lt;&lt;now&lt;&lt;endl; for(int i=0;i&lt;26;++i)&#123; if(tree[now][i])&#123; fail[tree[now][i]]=tree[fail[now]][i]; q.push(tree[now][i]); &#125; else tree[now][i]=tree[fail[now]][i]; &#125; &#125; return ;&#125;int find()&#123; int ans=0; int root=0,len=strlen(p); for(int j=0;j&lt;len;++j)&#123; while(root&amp;&amp;!tree[root][p[j]-'a']) root=fail[root]; root=tree[root][p[j]-'a']; //cout&lt;&lt;root&lt;&lt;endl; int now=root; while(now)&#123; ans+=val[now]; val[now]=0; now=fail[now]; &#125; &#125; return ans;&#125;int main()&#123; scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d",&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf("%s",s); insert(); &#125; build(); scanf("%s",p); printf("%d\n",find()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>ac自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ_QualificationRound_2]]></title>
    <url>%2F2019%2F04%2F07%2F2019GCJ-QualificationRound-2%2F</url>
    <content type="text"><![CDATA[You Can Go Your Own WayProblemYou have just entered the world’s easiest maze. You start in the northwest cell of an $N$ by $N$ grid of unit cells, and you must reach the southeast cell. You have only two types of moves available: a unit move to the east, and a unit move to the south. You can move into any cell, but you may not make a move that would cause you to leave the grid. You are excited to be the first in the world to solve the maze, but then you see footprints. Your rival, Labyrinth Lydia, has already solved the maze before you, using the same rules described above! As an original thinker, you do not want to reuse any of Lydia’s moves. Specifically, if her path includes a unit move from some cell $A$ to some adjacent cell $B$, your path cannot also include a move from $A$ to $B$. (However, in that case, it is OK for your path to visit $A$ or visit $B$, as long as you do not go from $A$ to $B$.) Please find such a path. In the following picture, Lydia’s path is indicated in blue, and one possible valid path for you is indicated in orange: InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow; each case consists of two lines. The first line contains one integer $N$, giving the dimensions of the maze, as described above. The second line contains a string P of $2N - 2$ characters, each of which is either uppercase $E$ (for east) or uppercase $S$ (for south), representing Lydia’s valid path through the maze. OutputFor each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is a string of $2N - 2$ characters each of which is either uppercase $E$ (for east) or uppercase $S$ (for south), representing your valid path through the maze that does not conflict with Lydia’s path, as described above. It is guaranteed that at least one answer exists. Limits1 $\leq$ T $\leq$ 100.Time limit: 15 seconds per test set.Memory limit: 1GB.P contains exactly N - 1 E characters and exactly N - 1 S characters. Test set 1 (Visible)2 $\leq$ N $\leq$ 10. Test set 2 (Visible)2 $\leq$ N $\leq$ 1000. Test set 3 (Hidden)For at most 10 cases, 2 $\leq$ N $\leq$ 50000.For all other cases, 2 $\leq$ N $\leq$ 10000. Sample Input 22SE5EESSSESE Output Case #1: ESCase #2: SEEESSES Solve将输入从后向前反着输出即可。 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;string s,s1;int n;stack&lt;char&gt; st;int main()&#123; int c; cin&gt;&gt;c; for(int ca=1;ca&lt;=c;++ca)&#123; while(!st.empty())st.pop(); cin&gt;&gt;n&gt;&gt;s; int x,y,tot;x=y=tot=0; for(int i=s.length()-1;i&gt;=0;--i)&#123; if(s[i]=='S') st.push('E'); if(s[i]=='E') st.push('S'); &#125; cout&lt;&lt;"Case #"&lt;&lt;ca&lt;&lt;": "; while(!st.empty())&#123; cout&lt;&lt;st.top();st.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>water</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019GCJ_QualificationRound_1]]></title>
    <url>%2F2019%2F04%2F07%2F2019GCJ-QualificationRound-1%2F</url>
    <content type="text"><![CDATA[Foregone SolutionProblemSomeone just won the Code Jam lottery, and we owe them $N$ jamcoins! However, when we tried to print out an oversized check, we encountered a problem. The value of $N$, which is an integer, includes at least one digit that is a $4$… and the $4$ key on the keyboard of our oversized check printer is broken. Fortunately, we have a workaround: we will send our winner two checks for positive integer amounts $A$ and $B$, such that neither $A$ nor $B$ contains any digit that is a $4$, and $A + B = N$. Please help us find any pair of values $A$ and $B$ that satisfy these conditions. InputThe first line of the input gives the number of test cases, $T$. $T$ test cases follow; each consists of one line with an integer $N$. OutputFor each test case, output one line containing Case #x: A B, where x is the test case number (starting from 1), and $A$ and $B$ are positive integers as described above. It is guaranteed that at least one solution exists. If there are multiple solutions, you may output any one of them. (See “What if a test case has multiple correct solutions?” in the Competing section of the FAQ. This information about multiple solutions will not be explicitly stated in the remainder of the 2019 contest.) Limits1 $\leq$ T $\leq$ 100.Time limit: 10 seconds per test set.Memory limit: 1GB.At least one of the digits of N is a 4. Test set 1 (Visible)1 &lt; N &lt; $10^5$. Test set 2 (Visible)1 &lt; N &lt; $10^9$. Solving the first two test sets for this problem should get you a long way toward advancing. The third test set is worth only 1 extra point, for extra fun and bragging rights! Test set 3 (Hidden)1 &lt; N &lt; $10^{100}$. Sample Input 349404444 Output Case #1: 2 2Case #2: 852 88Case #3: 667 3777 Solve将原数字中所有的$4$变成$1$和$3$即可。 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int _; string s,s1;int tot=0; cin&gt;&gt;_; while(_--)&#123; cin&gt;&gt;s;s1.clear(); int pos; for(int i=0;i&lt;s.length();++i)&#123; if(s[i]=='4')&#123; pos=i;break; &#125; &#125; //cout&lt;&lt;pos&lt;&lt;endl; cout&lt;&lt;"Case #"&lt;&lt;++tot&lt;&lt;": "; for(int i=pos;i&lt;s.length();++i)&#123; if(s[i]=='4')&#123; s1.push_back('1'); s[i]='3'; &#125; else s1.push_back('0'); &#125; cout&lt;&lt;s&lt;&lt;" ";int cnt=0; for(int i=pos;i&lt;s.length();++i)&#123; cout&lt;&lt;s1[cnt++]; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>water</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蒟蒻ACM退役贴&&总结]]></title>
    <url>%2F2019%2F03%2F31%2Fjuruo%2F</url>
    <content type="text"><![CDATA[我来过，未征服。我走了，还有千千万个我。 收获 学会写代码 2018 ACM-ICPC 焦作区域赛铜牌 2018 ACM-ICPC EC-Final铜牌 2018 CCPC 吉林区域赛铜牌 2018 ACM-ICPC 西安邀请赛铜牌 2019 CCCC天梯赛 华山论剑团队国二 2019 CCCC天梯赛 华山论剑学校北京市特等奖 2018 CCCC天梯赛 华山论剑团队国二 CCFCSP认证 单次前1.7% 学校在XCPC拿银 CCFCSP 350分|总排名前1% 某桥杯进一次国赛 天梯赛 200分 初识第一次参加宣讲会与新生赛&emsp;&emsp;初入大学的我参加的第一次宣讲会就是学院社团招新的宣讲会，在这一次宣讲会上成功加入了心心念念已久的足球队。但是有一个新鲜事物映入了我的眼帘–“ACM爱好者协会”。还很懵懂的我听见斌哥在台上讲着协会的历史，不知怎的有一种中二的热血感。当听到迄今为止协会最好成绩还只是铜牌的，什么都还不懂的我暗暗自语道一定要拿一块银牌，想必当时所有的人都是这种感觉吧^_^。宣讲的最后斌哥的那句暂不招新可以说是营造了十足的神秘感，超级炫酷！但好像这次宣讲会之后ACM就从生活中消失了，就买了几本书带着看，自己也没有去刷题啊什么的。&emsp;&emsp;可能从A协11月正式的宣讲会以及随之而来的新生赛，我才算正式开始了自己的算法竞赛生涯吧。新生赛的题感觉很友好的，那时的我都能做出几道题并拿到二等奖，虽然被很多人踩，还是很开心，毕竟是大学生活的第一个奖。梦想便从这时启航~ 寒假集训&amp;&amp;问题求解与编程&amp;&amp;暑假集训 寒假集训&emsp;&emsp;只记得第一天是教使用STL，第二天好像我就溜了，思乡心切xxx。可能这就是蒟蒻吧。 问题求解与编程&emsp;&emsp;这是一门大一下的专选课，任课老师是A协教练徐老师，自己也没想到以后还会和徐老师有更多交集。这个课让我学会了贪心、分治、搜索、dp。还熟悉了oj的使用，简直爽的飞起。也是从这学期开始自己开始买各种书看，刷一些很水很水的题，打一些其他学校的校赛，虽然好像打了两场校赛都爆零了给幼小的心灵造成严重的打击。不过却让自己认识到了自己的蒟蒻水平。也是在这学期坚定了要转专业的决心(只是院内转)。 暑假集训&emsp;&emsp;暑假集训其实才算真正的入门吧，在此之前不过是在学习C语言与C++罢了。集训的时间很长，长到自己只有二十天的暑假，长到自己感觉机房是自己的家，不过还好有LJY同学的陪伴，这就是一路上有你吧。&emsp;&emsp;每天惯例是上午讲算法，下午一场CF或专题赛。这样日复一日的生活看起来会很枯燥，但其实每天都过的很幸福很充实，因为每天都可以学到新的东西，可能这就是算法的魅力吧。最短路、线段树、KMP等等算法都是在集训中学到的，虽然距离学会还有很远的路要走。(这些算法现在已经是新生大一寒假的集训内容了，还是偏简单的那种)。后来多校合练开始了，自闭的噩梦也开始了，每天下午只能做出一两道题，这都是些什么题啊，也太难了吧，这可能是我第一次多校的唯一记忆。&emsp;&emsp;现在记得的事也不太多了，只记得博哥趁中午休息的时候从公司带了很多雪糕来分发给我们，当时就觉得协会也太暖了吧！！还有自己A掉了一道看起来比较难的最短路(还不是正解的那种)以及十分钟AK掉了线段树专场，导致我旻被我奇骂了好久出原题hhhh。&emsp;&emsp;不出所料的自己被选入了最后的集训队，一想到自己以后可以代表学校去参数了就超级超级兴奋！！！！！选拔结束的当天晚上一群人去聚餐了，认识了之前一起在机房待了一个月却不认识的很多人(属实自闭男孩)。 相守第二次参加宣讲会与新生赛&emsp;&emsp;大二上的时候稀里糊涂的就成了协会的副会长，开始翘课学算法、熬夜打比赛、熬夜刷题，基本所有时间都花在算法上了吧，进步还是挺大的。但其实现在想来学习和算法应该是可以兼顾的吧。第二次参加宣讲会，我校诞生了第一枚金牌(跨过了银牌。我也不再是在台下的那个人，我负责给新生讲解新生赛的规则。而这次新生赛我也不再是做题人而是成了出题人，见证了大一两个OI爷的神仙打架，其中一个每次训练都踩我们这些大二的学长学姐，没想到的是最后我们成了队友。 组队&amp;&amp;寒假训练&emsp;&emsp;按照学校惯例会在寒假之前进行三人组队并在寒假进行队伍合练，本蒟蒻和两个OI爷组了队，成了本队最蒻的人。寒假本来该去给大一的新生们讲算法的，但是因为320过于舒适，便咕咕咕。这次集训zn开了算法专题训练，不过很多东西我都是第一次做，做的很吃力，产生了厌学情绪，很多东西都没有认真做没用认真学，集训一周之后就回家了，定好的学习计划也都没有完成，算是废掉的一个寒假。可惜时间不能重来，现在想想真是后悔。 第一次参加某桥杯&amp;&amp;天梯赛&amp;&amp;邀请赛&emsp;&emsp;新的一学期一开学就是蓝桥杯和天梯赛，作为萌新即将要参加人生中的正式比赛特别兴奋，但却没有因此而好好刷题。大概因为那时我在学算法而且觉得没必要对桥杯和天梯赛刷题，这两个比赛又不是很难。事实证明确实不是很难，自己却打得不好，桥杯只拿了省三，大概集训队都是省二吧？天梯赛虽然在本校十个人中排名第三，但170+的分不算太高。事实证明算法竞赛是不能懈怠的，当你在现役时松懈下来那么码力和思维都会下降的特别快。受到打击之后开始认真学习以前没有吃透的算法，一遍一遍写着模板题，一遍一遍看着算法实现，直到自己完全理解，直到滚瓜烂熟。打基础的过程是不能省略的，否则便不能对一个算法融会贯通。此时觉得自己好像很强了，但再次遭遇打击，邀请赛信心满满要拿个银牌，结果却是铜首铩羽而归。因而整个人还失落了几天，便再次认识到自己的不足，会的东西还是太少了，不应该只拘泥于自己负责的那一小模块所有的算法都应该有掌握才行！ 总结&emsp;&emsp;大二是很重要的一年，基本上成型就应该是在这一年了，不应该有丝毫的怠惰。对于算法的学习也应该是成体系的，而不是杂乱的学习单个的算法，刷书应该是最明智的做法，先刷掉一两本书建立一个良好的知识体系，再查漏补缺学习书中没有但是会用到的算法。而后才是刷自己负责部分的专题，每周的cf、wannafly挑战赛、EOJ月赛等等都要做，碰到自己不会的知识才好强化学习。最重要的是每周一次的三人一机合练，培养默契与配合。另外cf的c、d、e都是可以刷掉的。 结局暑期训练&emsp;&emsp;一个暑假我的身边全是它，它伴我从南到北。两个多校合练，一个wannafly-camp，共27场比赛，近300道高质量题。区域赛中甚至出现了其中的原题。当时的我好像每一场比赛都认真打完并把力所能及的题都补完。多校一定得打、camp一定得参加、题一定得补！少了一步都不行。回学校之后便开始猛刷数据结构，虽然好像这是大多数强校大一新生都能完成得事情，不过两周做了一百多道平均码量100+行得题还是很有成就感的！ 网络赛在每年现场赛之前都会有网络赛选拔出最后的而参赛学校，网络赛&emsp;=&emsp;有没有区域赛打。第一场网络赛我校被教育的明明白白，决定着三场CCPC参数资格的CCPC网络赛我们并没有打进去而且名次还很低。幸好申请到了名额，不然莫得比赛打了。接着是南京、焦作、徐州、青岛、北京的网络赛。南京、焦作都成功入围，北京虽然没打进去但也申请到了一个名额。我记得我焦作原题场好像C了，南京也还行吧。网络赛就是原题满天飞的比赛，只要你题做的够多，你就够强(逃。 吉林&emsp;&emsp;线段树没调出来，就差一点。卒。 南京&emsp;&emsp;网络流被一个trick点坑了，全队全场在演，打铁而归。 焦作&emsp;&emsp;bfs愣是头铁写dij，差点就铁了(雾。 西安&emsp;&emsp;全程很轻松，不上不下。 某桥&amp;&amp;CSP&amp;&amp;天梯&emsp;&emsp;第二年打桥杯以为能拿省一的结果还是被安排了，CSP打的也不符预期，天梯赛中规中矩吧。对于这三个比赛只有一句话，当你和对手实力差距不大时，最大的敌人是粗心和你自己。 食堂排名 第一梯队：&emsp;南航南慕容&emsp;农大北乔峰 第二梯队：&emsp;河南理工胜在物美价廉餐券还多&emsp;北工大超级nice就是饭太少了&emsp;北华大学记不太清了，中规中矩吧 最差&emsp;西瓜大的饭最差，没有之一 技能树 就这些吧，退役蒟蒻准备ky了！每周要用半天学习算法和做题！]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx+uWsgi+Django部署网站到linux服务器]]></title>
    <url>%2F2019%2F03%2F31%2FNginx-uWsgi-Django%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E5%88%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[准备工作：安装Mysql和Python3.x注意事项：安装之前，我们需要给默认的Python2.7安装pymysql+Django库，因为后面会出错就是因为未安装这两个库！12pip install pymysql==0.7.10pip install django==1.10.6 安装虚拟环境：提示：因Python3+自带虚拟环境，更简单好用，所以没必要再装一个。在home目录下创建名称为vcmt的虚拟环境。1python3.6 -m venv /home/vcmt 激活虚拟环境：1source /home/vcmt/bin/activate 退出命令：1deactivate 安装Python扩展库：第一步，在已配置好的机器上使用：1pip freeze &gt; requirements.txt 第二步，把生成的requirements.txt文件复制到目标机器上的root目录下。第三步，在目标机器上执行pip install -r requirements.txt，读取文件requirements.txt中的扩展库信息并在本机进行安装。 上传项目到服务器：把Django项目上传到服务器上。 注意：上传项目文件后把 /项目名/app名/migrations/ 下的类似00.. 的记录文件删除，有几个删除几个，但是不要删除别的文件。 修改settings.py文件：123456789101112DEBUG = FalseALLOWED_HOSTS = ['*']STATIC_ROOT = os.path.join(BASE_DIR, 'static')MEDIA_ROOT = os.path.join(BASE_DIR, 'media')STATIC_URL = '/static/' 配置Django项目：安装好Django等必须库后，进入Django项目下，同步并创建数据库，执行：12python manage.py makemigrationspython manage.py migrate 建立后台超级用户：1python manage.py createsuperuser 启动自带的服务器，测试是否可以正常运行！（此时settings.py 中的DEBUG = False）输入：1python manage.py runserver 0.0.0.0:8000 同步静态文件：1python manage.py collectstatic 配置uWsgi：在Django项目主目录下创建uwsgi.ini文件：12345678910111213141516171819202122232425262728293031[uwsgi]# 项目目录chdir=/root/biomass/# 指定项目的applicationmodule=biomass.wsgi:application# 进程个数workers=5pidfile=/root/biomass/script/uwsgi.pid# 指定IP端口#http=:9090# 指定静态文件static-map=/static=/root/biomass/static# 启动uwsgi的用户名和用户组uid=rootgid=root# 启用主进程master=true# 自动移除unix Socket和pid文件当服务停止的时候vacuum=true# 序列化接受的内容，如果可能的话thunder-lock=true# 启用线程enable-threads=true# 设置自中断时间harakiri=30# 设置缓冲post-buffering=4096# 设置日志目录daemonize=/root/biomass/script/uwsgi.log# 指定sock的文件路径socket=127.0.0.1:9090 1234567$ uwsgi --ini uwsgi.ini # 启动uwsgi配置[uwsgi-static] added mapping for /static =&gt; /home/trunk/static # 启动成功$ uwsgi --stop uwsgi.pid # 关闭uwsgisignal_pidfile()/kill(): Operation not permitted [core/uwsgi.c line 1659]$ uwsgi --reload uwsgi.pid #重新加载配置 Nginx配置：Nginx常用命令：123456789$ /etc/init.d/nginx start #启动$ /etc/init.d/nginx stop #关闭$ /etc/init.d/nginx restart #重启$ killall nginx #杀死所有nginx$ nginx -t #检查配置文件是否有错# 如果是生产环境的话Nginx正在运行，就不要直接stop start 或者 restart 直接reload就行了# 对线上影响最低$ /etc/init.d/nginx reload 创建一个xxx.conf配置文件（nginx的默认配置目录为/etc/nginx/conf.d）：1234567891011121314151617181920212223242526server &#123; # 这个server标识我要配置了 listen 80; # 80 是http默认的端口， 443 是https默认的端口（网页一般使用这两个端口） server_name 39.105.157.191 ; # 你访问的路径前面的url名称 access_log /var/log/nginx/access.log; # Nginx日志配置 error_log /var/log/nginx/error.log; # Nginx错误日志配置 charset utf-8; # Nginx编码 gzip on; # 启用压缩,这个的作用就是给用户一个网页,比如3M压缩后1M这样传输速度就会提高很多 gzip_types text/plain application/x-javascript text/css text/javascript application/x-httpd-php application/json text/json image/jpeg image/gif image/png application/octet-stream; # 支持压缩的类型 error_page 404 /404.html; # 错误页面 error_page 500 502 503 504 /50x.html; # 错误页面 # 指定项目路径uwsgi location / &#123; # 这个location就和咱们Django的url(r'^admin/', admin.site.urls), include /etc/nginx/uwsgi_params; # 导入一个Nginx模块他是用来和uWSGI进行通讯的 uwsgi_connect_timeout 30; # 设置连接uWSGI超时时间 # 指定uwsgi的sock文件所有动态请求就会直接丢给他 uwsgi_pass 127.0.0.1:9090; &#125; # 指定静态文件路径 # location /static/ &#123; # alias /root/biomass/static/; # index index.html index.htm; #&#125;&#125; 启动uWsgi后再启动Nginx即可]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E7%BD%91%E7%BB%9C%E6%B5%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[网络流swust P1736 飞行员配对方案问题题目链接：https://www.oj.swust.edu.cn/problem/show/1736 题意有两种飞行员，一种可以和另一种的几个飞行员配对，求最大匹配。 题解二分图最大匹配问题。 在二分图的基础上增加源$S$和汇$T$，一种飞行员为$X$集合，另一种为$Y$集合。$1$、$S$向$X$集合中每个顶点连一条容量为$1$的有向边。$2$、$Y$集合中每个顶点向$T$连一条容量为$1$的有向边。$3$、$XY$集合之间的边都设为从$A$集合中的点到B集合之中的点，容量为$1$的有向边。求网络最大流，流量就是匹配数，所有满流边是一组可行解。(匈牙利写起来更方便) swust P1737 太空飞行计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1737 题意有 $n$ 个实验，每个实验有收入 $x_{i}$ ，而且实验会使用 $m_i$ 个仪器。每个仪器会有 $y_i$支出。问实施哪些实验并配置哪些仪器使收入最大。 题解最大权闭合图问题，可以转化成最小割问题，进而用最大流解决。 把每个实验看作二分图 $X$ 集合中的顶点，每个设备看作二分图 $Y$ 集合中的顶点，增加源 $S$ 和汇 $T$。1、从 $S$ 向每个 $X_i$ 连接一条容量为该点收入的有向边。2、从 $Y_i$ 向 $T$ 连接一条容量为该点支出的有向边。3、如果一个实验 $i$ 需要设备 $j$ ，连接一条从 $X_i$ 到 $Y_j$ 容量为无穷大的有向边。 统计出所有实验的收入之和$Total$，求网络最大流$Maxflow$，最大收益就是$Total - Maxflow$。对应的解就是最小割划分出的 $S$ 集合中的点，也就是最后一次增广找到阻塞流时能从 S 访问到的顶点。定义一个割划分出的$S$集合为一个解，那么割集的容量之和就是(未被选的 $A$ 集合中的顶点的权值 $+$ 被选的 $B$ 集合中的顶点的权值)，记为$Cut$。 $A$ 集合中所有顶点的权值之和记为$Total$，那么$Total - Cut$就是(被选的 $A$ 集合中的顶点的权值 $-$ 被选的 $B$ 集合中的顶点的权值)，即为我们的目标函数，记为 $A$ 。要想最大化目标函数 $A$ ，就要尽可能使$Cut$小，$Total$是固定值，所以目标函数 $A$ 取得最大值的时候，$Cut$最小，即为最小割。 swust P1738 最小路径覆盖问题题目链接：https://www.oj.swust.edu.cn/problem/show/1738 题意问最少多少条路径可以覆盖一个有向无环图所有的点。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 构造二分图，把原图每个顶点$i$拆分成二分图$X$，$Y$集合中的两个顶点$X_i$和$Y_i$。对于原图中存在的每条边$(i,j)$，在二分图中连接边$(X_i,Y_j)$。然后把二分图最大匹配模型转化为网络流模型，求网络最大流。最小路径覆盖的条数，就是原图顶点数，减去二分图最大匹配数（因为路径长度可为$0$，所以最大路径覆盖数为顶点数，每多一条边则少一个路径覆盖）。沿着匹配边查找，就是一个路径上的点，输出所有路径即可。 swust P1739 魔术球问题题目链接：https://www.oj.swust.edu.cn/problem/show/1739 题意问 $n$ 根柱子一共可以放下多少个球。放球规则为数字从小到大依次放且每根柱子的相邻的两个球的值相加为平方数。 题解有向无环图最小路径覆盖，可以转化成二分图最大匹配问题，从而用最大流解决。 先从 $1$ 至无穷枚举可能放下多少个球（不能二分，因为二分得重新构图）。一旦数字 $m$ 放不下则结束枚举。可以把所有的球看成有向无环图的点，柱子看成路径。所以问题就成了最小路径覆盖 $m$ 个点。先拆点，枚举的时候每加一个点 $x_i$ 与源点相连， $y_i$ 与汇点相连，再连小于这个点且能与他相加能开方的点的边 $x_i -&gt; y_j$ 。一旦 $m$ 个点覆盖的路径大于 $n$ ，则结束枚举，并输出 $m - 1$ 。 swust P1740 圆桌问题题目链接：https://www.oj.swust.edu.cn/problem/show/1740 题意要把 $n$ 个单位的人安排到 $m$ 个餐桌上（同个餐桌不能有来自相同单位的人）。 题解二分图多重匹配问题，可以用最大流解决。 建立二分图，每个单位为$X$集合中的顶点，每个餐桌为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$顶点连接一条容量为该单位人数的有向边。2、从每个$Y_i$顶点向$T$连接一条容量为该餐桌容量的有向边。3、$X$集合中每个顶点向$Y$集合中每个顶点连接一条容量为$1$的有向边（每个单位只能有一个人去一个餐桌）。求网络最大流，如果最大流量等于所有单位人数之和，则存在解，否则无解。对于每个单位，从$X$集合对应点出发的所有满流边指向的$Y$集合的顶点就是该单位人员的安排情况（一个可行解）。 swust P1741 最长递增子序列问题题目链接：https://www.oj.swust.edu.cn/problem/show/1741 题意计算序列的最长递增子序列的长度 $s$ 。 并给出序列中最多可取出多少个长度为 $s$ 的递增子序列。如果允许在取出的序列中多次使用 $x_1$ 和 $x_n$ ，则从给定序列中最多可取出多少个长度为 $s$ 的递增子序列。 题解分层图问题，可用最大流解决。 先 $dp$ 出每个 $i$ 的最长递增子序列 $F[i]$ 。对于规则$1$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。对于规则$2$，将$n$个值拆点，拆成 $x_i$ 与 $y_i$ 。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ 。（ $1$ 与 $n$ 点容量为无穷）。如果 $F[i] = s$ ,则将 $x_i$ 与源点相连，如果 $F[i] = 1$ ，则将 $y_i$ 与汇点相连。容量为 $1$ 。如果 $i &lt; j$ 且 $F[i] + 1 = F[j]$ ,连接 $y_i$ 与 $x_j$ 。容量为 $1$ 。求最大流。 swust P1742 试题库问题题目链接：https://www.oj.swust.edu.cn/problem/show/1742 题意试题库中有 $n$ 道题（每道题各有几种属性，共有 $k$ 种属性），现在每种类型各需要 $m_i$ 道题共 $m$ 道题组成一套试卷，问是否能组成，能的话输出选择的题目。 题解二分图多重匹配问题，用最大流解决。 建立二分图，每个类别为$X$集合中的顶点，每个题为$Y$集合中的顶点，增设附加源$S$和汇$T$。1、从$S$向每个$X_i$连接一条容量为该类别所需数量的有向边。2、从每个$Yi$向$T$连接一条容量为$1$的有向边。3、如果一个题$i$属于一个类别$j$，连接一条从$X_j$到$Y_i$容量为$1$的有向边。求网络最大流，如果最大流量等于所有类别所需之和，则存在解，否则无解。对于每个类别，从$X$集合对应点出发的所有满流边，指向的$B$集合中的顶点就是该类别的所选的题（一个可行解）。 swust P1744 方格取数题目链接：https://www.oj.swust.edu.cn/problem/show/1744 题意一个方格取出一些数（所有的数都不想邻）的和最大。 题解选出的点满足任意两个都不相邻，这是点独立集的概念。使选出的总和最大:最大点权独立集。最大点权独立集 = 总点权 - 最小点权覆盖集 = 总点权 - 最小割 = 总点权 - 最大流。取得数总和最大转化为不取的损失最小。所以问题即可以转化为割掉最小的边，使原图不连通（即找不出方格中相邻且二分图中有边相连的点）。 把棋盘黑白染色。对于黑色的，连接源点，容量为格子中的数。对于白色的，连接汇点，容量为格子中的数。然后把所有黑点和相邻的白点连边，容量无穷大。于是我们构造出了一个二分图。题目说不能取相邻的格子，那么对于这张二分图来说，就不能让他有一条边有流经过（否则就取了两个相邻的格子了）。于是求最小割即可。等于求最大流。最后用总和减去最小割即可。 swust P1745 餐巾计划问题题目链接：https://www.oj.swust.edu.cn/problem/show/1745 题意一个餐厅 $n$ 天里每天都需要 $x$ 餐巾，可以选择花费 $p$ 元购买新的，也可以选择将已有的花 $s$ 元送去慢洗 $m$ 天，或者花 $f$ 元送去快洗 $k$ 天，或者延期洗。要花费最小。 题解最小费用最大流问题。 将 $n$ 天拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与源点相连，容量为 $x$，花费为 $0$。将 $y_i$ 与汇点相连，容量为 $x$，花费为 $0$。将 $x_i$ 与 $y_i + m$ 相连，容量无穷，费用为 $s$ 。将 $x_i$ 与 $y_i + k$ 相连，容量无穷，费用为 $f$ 。将 $x_i$ 与 $x_i + 1$ 相连，容量无穷，费用为 $0$ 。将源点与 $y_i$ 相连，容量为无穷，费用为 $p$。求最小费用最大流。 swust P1746 航空路线问题题目链接：https://www.oj.swust.edu.cn/problem/show/1746 题意给一幅图，求从最西边到最东边再回到最西边经过的城市最多。（除了起点其他城市只能走一次） 题解最大费用最大流问题。 将 $n$ 个城市拆点，拆成 $x_i$ 与 $y_i$。将 $x_i$ 与 $y_i$ 相连，容量为 $1$ ，费用为 $1$ 。起点与终点容量为 $2$ 。（如果这个点流量为 $1$ ，表示这个点被使用。）如果两城市相连则连接 $x_i$ 与 $y_j$ ，容量为 $1$ ，费用为 $0$ 。从起点到终点跑最小费用最大流。 swust P1748 星际转移问题题目链接：https://www.oj.swust.edu.cn/problem/show/1748 题意人得借助 $m$ 艘太空船（容量限定）与 $n$ 个空间站从地球转移到月球，每艘太空船每天有规律的停靠在某个空间站，问最少多少天转移所有人。 题解分层图网络流问题，枚举答案。 我们把网络优化问题转化为枚举答案+可行性判定问题。枚举天数，按天数把图分层，因为乘船每坐一站天数都要增加一，把太空船航线抽象成图中的一条边，跨图的两层。由于太空船容量有限，边上也要加上容量限制。除了坐船以外，人还可以在某个空间站等待下一班太空船的到来，所以每个点要与下一层同一点连接一条容量为无穷的边。 从源点向每一天的地球链接一条容量无穷的边。从每一天的月亮向汇点链接一条容量无穷的边。从上一天的每一个节点向当天的对应节点链接一条容量无穷的边（因为人们可以留在中转站等一等）。针对每一艘飞船，获取其上一天的位置，再获取这一天的位置，在这两个点之间连一条容量为飞船满载人数的流。每次新加一天然后跑到最大流超过$k$即可。至于无解的情况只要当$ans$达到一个很大的值的时候跳出来即可。 swust P1751 数字梯形问题题目链接：https://www.oj.swust.edu.cn/problem/show/1751 题意梯形的第一行有 $m$ 个数字。从梯形的顶部的 $m$ 个数字开始，在每个数字处可以沿左下或右下方向移动，形成一条从梯形的顶至底的路径。规则1：从梯形的顶至底的 $m$ 条路径互不相交。规则2：从梯形的顶至底的 $m$ 条路径仅在数字结点处相交。规则3：从梯形的顶至底的 $m$ 条路径允许在数字结点相交或边相交。 题解求图的最大权不相交路径及其变种，用最大费用最大流解决。 把梯形每个位置拆点为 $x_i$ 与 $y_i$ 。（因为要保证每个点只能用一次）$x_i$ 与 $y_i$ 相连容量为 $1$ ，费用为点值。从一点向它的左下或右下（ $y_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为 $0$ 的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为 $1$ ，费用为 $0$。 对于规则 $2$ ，不用拆点，因为不限制点的使用。从一点向它的左下或右下（ $x_i$ 与 $x_j$ ）分别连接一条容量为 $1$ ，费用为点值的边。第一层的点与源点相连，容量为 $1$ ，费用为 $0$。最后一层的点与汇点相连，容量为无穷，费用为点值。（无穷因为不限制点的使用）对于规则 $3$ ，只需要把规则 $2$ 中除了第一层与源点连边之外的边容量全部改为无穷大。（因为不限制边的使用） swust P1752 运输问题题目链接：https://www.oj.swust.edu.cn/problem/show/1752 题意把 $m$ 个仓库的 $a_i$ 货物运送到 $n$ 个需求为 $b_i$ 的商店去，第 $i$ 个仓库运到第 $j$ 个商店的费用为 $c_{ij}$ 。求最小与最大费用。 题解费用流问题。 把所有仓库看做二分图中顶点$X_i$，所有零售商店看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为仓库中货物数量$a_i$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为商店所需货物数量$b_i$，费用为$0$的有向边。从每个Xi向每个$Y_j$连接一条容量为无穷大，费用为$c_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少运费，求最大费用最大流，最大费用流值就是最多运费。 swust P1753 分配问题题目链接：https://www.oj.swust.edu.cn/problem/show/1753 题意$n$ 个人需要工作，第 $i$ 个人需要第 $j$ 个工作的工资为 $c_{ij}$。求最小与最大费用。 题解费用流问题。 把所有人看做二分图中顶点$X_i$，所有工作看做二分图中顶点$Y_i$，建立附加源$S$汇$T$。从$S$向每个$X_i$连一条容量为$1$，费用为$0$的有向边。从每个$Y_i$向$T$连一条容量为$1$，费用为$0$的有向边。从每个$X_i$向每个$Y_j$连接一条容量为无穷大，费用为$C_{ij}$的有向边。求最小费用最大流，最小费用流值就是最少工资，求最大费用最大流，最大费用流值就是最多工资。 swust P1754 负载平衡问题题目链接：https://www.oj.swust.edu.cn/problem/show/1754 题意有 $n$ 个环形仓库存着不同的货物，求最小步数使得所有仓库货物相等。 题解费用流问题。 首先求出所有仓库存货量平均值，设第$i$个仓库的盈余量为$A[i]$，$A[i] = $第$i$个仓库原有存货量 $-$ 平均存货量。建立二分图，把每个仓库抽象为两个节点$X_i$和$Y_i$。增设附加源$S$汇$T$。如果$A[i]&gt;0$，从$S$向$X_i$连一条容量为$A[i]$，费用为$0$的有向边。（有盈余）如果$A[i]&lt;0$，从$Y_i$向$T$连一条容量为$-A[i]$，费用为$0$的有向边。（需添加）每个$X_i$向两个相邻顶点$j$，从$X_i$到$X_j$连接一条容量为无穷大，费用为$1$的有向边，从$X_i$到$Y_j$连接一条容量为无穷大，费用为$1$的有向边。（旁边可能是终点，也可能是中转站）求最小费用最大流，最小费用流值就是最少搬运量。 swust P1755 深海机器人问题题目链接：https://www.oj.swust.edu.cn/problem/show/1755 题意深海资源考察探险队的潜艇将到达深海的海底进行科学考察。潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。每条预定路径上的生物标本的价值是已知的，而且生物的标本只能采集一次。本题限定深海机器人只能从其出发的位置沿着向北或者向东方向移动，而且多个深海机器人可以在同一时间占据同一位置。 题解费用流问题。 把网格中每个位置抽象成网络中一个节点，建立附加源$S$汇$T$。对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为$1$ ，费用为该边价值的有向边。（每个点的价值只能使用一次）对于每个顶点$i$，$j$为$i$东边或南边相邻的一个节点，连接节点$i$与节点$j$一条容量为无穷大，费用为$0$ 的有向边。（多个机器人可同时在同点，不限制点的使用）从$S$到每个出发点$i$连接一条容量为该点出发的机器人数量，费用为$0$的有向边。从每个目标点$i$到$T$连接一条容量为可以到达该点的机器人数量，费用为$0$的有向边。求最大费用最大流，最大费用流值就采集到的生物标本的最高总价值。 poj P1149 PIGS题目链接：http://poj.org/problem?id=1149 题意有 $m$ 个猪圈与 $n$ 个客人，每个客人可以到 $k$ 个猪圈买猪，最多可以买 $x$ 头猪，（每个顾客走后他所打开的猪圈里的猪可以任意交换）求所有顾客最多可以买多少猪。 题解最大流 可以想到每个猪圈都有第一个顾客，后面的顾客可以拿的数量取决于前面的顾客所拿的数量，所以就单个猪圈而言，当前顾客可拿量取决于上一个顾客。所以可以拿同一个猪圈的顾客 $i$ 与 $i + 1$ 连边，边权为无穷。这样除每个猪圈第一顾客后的所有顾客都有了猪的来源，再将每个猪圈的第一个顾客与源点连边，边权为猪圈中猪数量，这样第一个顾客也有了猪的来源。再将每个顾客与汇点连边，边权为其最多可买的猪的数量。跑一次最大流即为答案。 poj P2391 Ombrophobic Bovines题目链接：http://poj.org/problem?id=2391 题意有 $n$ 个牛棚，每个牛棚有其牛的数量与其容量，现在下雨了，求最少的时间把所有的牛放到牛棚里。 题解最大流 先用 $floyd$ 求出每个点之间的最短路，那么时间限制了点对之间是否可以连边。二分时间，拆点与源汇连边，如果两点间的距离小于等于时间则连边。如果跑出满流证明时间可满足。最后通过二分求出答案。 2017urumuqi j题目链接： 题意从一个点经过另一个点到一个点的最小费用（每个点只能经过一次）。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量除中转点外都为 $1$ ，中转点容量为 $2$ 。再把图上有的边连上，费用为边权，容量为无穷。源点与起点终点连接，容量为 $1$ ，费用为 $0$ ；汇点与中转点连接，容量为 $2$ ，费用为 $0$ 。如果流量为 $2$ ，则答案为费用，否则输出 $-1$ 。 2017qingdao k题目链接： 题意上一题的复杂版，从西安到上海后再从上海到青岛，最后从青岛返回上海。上海有两个机场，其中从西安到是到浦东机场到虹桥机场到青岛，青岛回上海是回虹桥机场。 题解费用流 相当于求从起点和终点到中转点的最小费用和。因为限制点只能使用一次，所以拆点，$i$ 和 $i + 1$ 点的费用都为 $0$ ，容量青岛及虹桥容量为 $2$ ，其余点容量都为 $1$ 。再把图上有的无向边连上，费用为边权，容量为无穷。源点与西安、青岛连接，西安容量为 $1$ ，青岛容量为 $2$ ，费用为 $0$ ；汇点与虹桥及浦东连接，虹桥容量为 $2$ ，浦东容量为 $1$ ，费用为 $0$ 。如果流量为 $3$ ，则答案为费用，否则输出 $-1$ 。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin America I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAmeIImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 给一幅联通图，$q$次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int tot,cnt,head[M],f[M];ll ans;struct edge&#123; int v,next;ll w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v;ll w; edge1()&#123;&#125; edge1 (int u1,int v1,ll w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; tot=ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,ll w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;int sz[M],dep[M],fat[M],son[M],rnk[M],id[M],top[M];ll val[M];void dfs(int u,int fa,int d)&#123; sz[u]=1;dep[u]=d;son[u]=-1,fat[u]=fa; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v;ll w=e[i].w; if(v==fa) continue; val[v]=w; dfs(v,u,d+1); sz[u]+=v; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fat[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=val[rnk[l]]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;ll query(int x,int y)&#123; int fx=top[x],fy=top[y];ll res=0; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; res=max(res,seg.query(id[fx],id[x],1,n,1)); x=fat[fx],fx=top[x]; &#125; else&#123; res=max(res,seg.query(id[fy],id[y],1,n,1)); y=fat[fy],fy=top[y]; &#125; &#125; if(x==y) return res; if(dep[x]&gt;dep[y]) res=max(res,seg.query(id[son[y]],id[x],1,n,1)); else res=max(res,seg.query(id[son[x]],id[y],1,n,1)); return res;&#125;void solve()&#123; dfs(1,-1,0);dfs1(1,1);seg.build(1,n,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%lld\n",ans); else&#123; printf("%lld\n",ans-query(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%lld",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Moscow Subregional C Carpet]]></title>
    <url>%2F2019%2F03%2F29%2F2017MoscowSubregionalCCarpet%2F</url>
    <content type="text"><![CDATA[2017 Moscow Subregional C Carpethttps://vjudge.net/contest/260542#problem/C 给一个 $1000000 \times 20$ 的格子图，要求找一种方式把一颗不超过 $100000$ 个节点的树放到格子图里，并且没有边交叉。考虑把树剖分，因为不超过对数条数的链，所以依次把重链放到一列中，轻链放到下一列即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int M = 1e5+7;int n;int cnt,head[M];int sz[M],f[M],son[M],x[M],y[M],tmp[M];struct edge&#123; int v,next;&#125;e[M&lt;&lt;1];void init()&#123; cnt=0;memset(head,-1,sizeof(head));memset(tmp,0,sizeof(tmp));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].next=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=1,f[u]=fa,son[u]=-1; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int z)&#123; y[u]=z;x[u]=++tmp[z]; if(son[u]==-1) return; for(int i=head[u];~i;i=e[i].next)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,z+1); &#125; dfs1(son[u],z); return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; init(); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1);dfs1(1,1); for(int i=1;i&lt;=n;i++) printf("%d %d\n", x[i],y[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5242]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5242%2F</url>
    <content type="text"><![CDATA[hdu 5242 Gamehttp://acm.hdu.edu.cn/showproblem.php?pid=5242 给一棵点权树，问从根节点出发$k$次最多能获得多少能量。同一个点的能量只能获取一次。每次从根节点出发肯定要走到叶子节点才是最优的选择。而且每次都要走的是上一次走完后的能量最多的路径。很容易想到按点权把树剖分成轻重链。每一条链都是从叶子到某个节点的，所以当重链被选择后，最重的轻链便成了重链，所以只要把剖分出的前 $k$ 条链的能量相加即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;int _,n,k,cas=1;int cnt,head[M],tot;struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];int son[M],f[M];ll sz[M],a[M],tmp[M],ans[M];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa)&#123; sz[u]=a[u];son[u]=-1;f[u]=fa; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u); if(sz[v]&gt;sz[son[u]]||son[u]==-1)&#123; sz[u]=sz[u]-sz[son[u]]+sz[v]; son[u]=v; &#125; &#125;&#125;void dfs1(int u,ll w)&#123; tmp[u]=a[u]+w; if(son[u]==-1)&#123; ans[++tot]=tmp[u]; return ; &#125; dfs1(son[u],tmp[u]); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,0); &#125; return ;&#125;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); scanf("%d",&amp;_); while(_--)&#123; init(); scanf("%d%d",&amp;n,&amp;k); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1); // for(int i=1;i&lt;=n;i++) printf("%d %d\n",f[i],son[i]); dfs1(1,0); ll res=0; printf("Case #%d: ",cas++); if(k&gt;tot)&#123; for(int i=1;i&lt;=tot;i++) res+=ans[i]; printf("%lld\n",res); &#125; else&#123; sort(ans+1,ans+1+tot); for(int i=tot;i&gt;tot-k;i--) res+=ans[i]; printf("%lld\n",res); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wannafly day1 I]]></title>
    <url>%2F2019%2F03%2F29%2Fwannafly-day1-I%2F</url>
    <content type="text"><![CDATA[wannafly_day1_I.cpphttp://newoj.acmclub.cn/contests/1389/problem/8 给一棵树，给出 $m$ 次染色，问每个点的第 $k$ 次染色是什么颜色。倒着做，用线段树维护区间染色的最大次数，如果有 $k - 1$次的区间存在，就找到那个点把它的颜色更新，并把它的染色次数变为 $-inf$。复杂度 $O(nlog(n)^2)$，注意下 $update$ 的写法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 1e5+7;const int inf = 2147483647;int n,m,k;int tot,cnt,head[M];int sz[M],f[M],son[M],dep[M],rnk[M],top[M],id[M];int lazy[M&lt;&lt;2],mx[M&lt;&lt;2],ans[M];struct edge&#123; int v,nex;&#125;e[M&lt;&lt;1];void init()&#123; tot=cnt=0;memset(head,-1,sizeof(head));memset(ans,0,sizeof(ans));&#125;void add(int u,int v)&#123; e[++cnt].v=v;e[cnt].nex=head[u]; head[u]=cnt;&#125;void dfs(int u,int fa,int d)&#123; sz[u]=1,f[u]=fa,son[u]=-1,dep[u]=d; for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==fa) continue; dfs(v,u,d+1); sz[u]+=sz[v]; if(son[u]==-1||sz[v]&gt;sz[son[u]]) son[u]=v; &#125; return ;&#125;void dfs1(int u,int t)&#123; id[u]=++tot; rnk[tot]=u; top[u]=t; if(son[u]==-1) return ; dfs1(son[u],t); for(int i=head[u];~i;i=e[i].nex)&#123; int v=e[i].v; if(v==f[u]||v==son[u]) continue; dfs1(v,v); &#125; return ;&#125;void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]);&#125;void pushdown(int rt,int l,int r)&#123; if(lazy[rt]&gt;0)&#123; int v=lazy[rt]; lazy[rt]=0; mx[r]+=v;lazy[r]+=v; mx[l]+=v;lazy[l]+=v; &#125; return ;&#125;void build(int l,int r,int rt)&#123; mx[rt]=0;lazy[rt]=0; if(l==r) return ; int mid=(l+r)&gt;&gt;1; build(lson); build(rson);&#125;void update(int L,int R,int l,int r,int rt,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(mx[rt]==k-1)&#123; if(l==r)&#123; mx[rt]=-inf,ans[rnk[l]]=v,lazy[rt]=0; &#125; else&#123; pushdown(up); int mid=(l+r)&gt;&gt;1; if(mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); &#125; &#125; else mx[rt]++,lazy[rt]++; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid&amp;&amp;mx[rt&lt;&lt;1]&gt;=0) update(L,R,lson,v); if(R&gt;mid&amp;&amp;mx[rt&lt;&lt;1|1]&gt;=0) update(L,R,rson,v); pushup(up); return ;&#125;void query(int x,int y,int v)&#123; int fx=top[x],fy=top[y]; while(fx!=fy)&#123; if(dep[fx]&gt;dep[fy])&#123; update(id[fx],id[x],1,n,1,v); x=f[fx],fx=top[x]; &#125; else&#123; update(id[fy],id[y],1,n,1,v); y=f[fy],fy=top[y]; &#125; &#125; if(dep[x]&gt;dep[y]) update(id[y],id[x],1,n,1,v); else update(id[x],id[y],1,n,1,v);&#125;int qu[M],qv[M],qc[M];int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); init(); scanf("%d%d%d",&amp;n,&amp;m,&amp;k); build(1,n,1); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); add(u,v);add(v,u); &#125; dfs(1,-1,1); dfs1(1,1); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;qu[i],&amp;qv[i],&amp;qc[i]); &#125; for(int i=m;i&gt;=1;i--)&#123; query(qu[i],qv[i],qc[i]); &#125; for(int i=1;i&lt;=n;i++) printf("%d%c",ans[i],i==n?'\n':' '); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>Heavy_Light_Decomposition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Latin Ame I Imperial roads]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-IImperialroads%2F</url>
    <content type="text"><![CDATA[2017LatinAme I Imperial roadshttps://vjudge.net/contest/259114#problem/I 倍增找两点与$LCA$路径上的最大边权。给一幅联通图，$q$ 次询问，每次给定一条边，要你选择一个边集包含给的边且使图依旧联通并且边权和最小。首先图的最小生成树是让图联通且边权和最小的选择。但是不一定包含给的边。当不包含的时候只需要把给的边的两点的链中的最大边找出来用树边权减去再加上给的边权即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int M = 1e5+7;inline int read()&#123; int x=0; bool f=0; char ch=getchar(); while (ch&lt;'0' || '9'&lt;ch) f|=ch=='-', ch=getchar(); while ('0'&lt;=ch &amp;&amp; ch&lt;='9') x=x*10+ch-'0', ch=getchar(); return f?-x:x;&#125;int n,m,q;int ans,cnt,head[M],f[M];int fa[M][26],mx[M][26],dep[M];struct edge&#123; int v,next,w;&#125;e[M&lt;&lt;1];struct edge1&#123; int u,v,w; edge1()&#123;&#125; edge1 (int u1,int v1,int w1) &#123; u=u1,v=v1;w=w1; &#125; bool operator &lt; (const edge1 &amp; k)const&#123; if(w!=k.w) return w&lt;k.w; if(w==k.w&amp;&amp;u!=k.u) return u&lt;k.u; return v&lt;k.v; &#125;&#125;e1[M&lt;&lt;2];map&lt;edge1,int&gt; mp;void init()&#123; ans=cnt=0;memset(head,-1,sizeof(head));mp.clear(); memset(dep,0,sizeof(dep));memset(fa,0,sizeof(fa));memset(mx,0,sizeof(mx)); for(int i=1;i&lt;=n;i++) f[i]=i;&#125;void add(int u,int v,int w)&#123; e[++cnt].v=v;e[cnt].next=head[u];e[cnt].w=w; head[u]=cnt;&#125;int find(int x)&#123;return x==f[x]?x:f[x]=find(f[x]);&#125;void dfs(int u,int depth)&#123; dep[u]=depth; int j=1; while ((1&lt;&lt;j)&lt;depth)&#123; fa[u][j]=fa[fa[u][j-1]][j-1]; mx[u][j]=max(mx[u][j-1],mx[fa[u][j-1]][j-1]); j++; &#125; for (int i=head[u];~i;i=e[i].next) if (dep[e[i].v]==0)&#123; int v=e[i].v; fa[v][0]=u;mx[v][0]=e[i].w; dfs(v,depth+1); &#125;&#125;void up(int &amp;u,int step,int &amp;res)&#123; for (int i=0;i&lt;=20;i++) if (step&amp;(1&lt;&lt;i)) &#123; res=max(mx[u][i],res); u=fa[u][i]; &#125; return ;&#125;int work(int u,int v)&#123; int res=0; if (dep[u]&lt;dep[v]) up(v,dep[v]-dep[u],res); else up(u,dep[u]-dep[v],res); for (int i=20;i&gt;=0;i--) if (fa[u][i]!=fa[v][i])&#123; res=max(res,max(mx[u][i],mx[v][i])); u=fa[u][i];v=fa[v][i]; &#125; if (u!=v) res=max(res,max(mx[u][0],mx[v][0])); return res;&#125;void solve()&#123; dfs(1,1); q=read();//scanf("%d",&amp;q); while(q--)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); if(!mp[edge1(u,v,0)]) printf("%d\n",ans); else&#123; printf("%d\n",ans-work(u,v)+mp[edge1(u,v,0)]); &#125; &#125;&#125;int main()&#123; //freopen("1.in","r",stdin); //freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init(); for(int i=1;i&lt;=m;i++) e1[i].u=read(),e1[i].v=read(),e1[i].w=read();//scanf("%d%d%d",&amp;e1[i].u,&amp;e1[i].v,&amp;e1[i].w); sort(e1+1,e1+m+1); for(int i=1;i&lt;=m;i++)&#123; int fx=find(e1[i].u),fy=find(e1[i].v); if(fx!=fy)&#123; add(e1[i].u,e1[i].v,e1[i].w);add(e1[i].v,e1[i].u,e1[i].w); f[fx]=fy; ans+=e1[i].w; &#125; else&#123; mp[edge1(e1[i].u,e1[i].v,0)]=e1[i].w;mp[edge1(e1[i].v,e1[i].u,0)]=e1[i].w; &#125; &#125; solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu 5950]]></title>
    <url>%2F2019%2F03%2F29%2Fhdu-5950%2F</url>
    <content type="text"><![CDATA[hdu 5950 Recursive sequencehttp://acm.hdu.edu.cn/showproblem.php?pid=5950 $F_1=a,F_2=b。F_n=F_{n-1}+2\times F_{n-2}+n^4$。输入$n$，求$F_n$。用二项式定理把 $n^4$ 拆开，就是裸的矩阵快速幂了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 2147493647;int _;ll n,a,b;struct mat&#123; ll a[8][8]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;7;i++) a[i][i]=1; &#125; mat operator * (const mat &amp; t)const&#123; mat tmp; for(int i=0;i&lt;7;i++) for(int j=0;j&lt;7;j++) for(int k=0;k&lt;7;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=1ll,x.a[0][1]=2ll,x.a[0][2]=1ll,x.a[0][3]=4ll,x.a[0][4]=6ll,x.a[0][5]=4ll,x.a[0][6]=1ll; x.a[1][0]=1ll; x.a[2][2]=1ll,x.a[2][3]=4ll,x.a[2][4]=6ll,x.a[2][5]=4ll,x.a[2][6]=1ll; x.a[3][3]=1ll,x.a[3][4]=3ll,x.a[3][5]=3ll,x.a[3][6]=1ll; x.a[4][4]=1ll,x.a[4][5]=2ll,x.a[4][6]=1ll; x.a[5][5]=1ll,x.a[5][6]=1ll; x.a[6][6]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld%lld%lld",&amp;n,&amp;a,&amp;b); if(n==1)&#123; printf("%lld\n",a); continue; &#125; if(n==2)&#123; printf("%lld\n",b); continue; &#125; mat y=matrix_pow(x,n-2ll); printf("%lld\n",((((((y.a[0][0]*b%mod+y.a[0][1]*a%mod)%mod+y.a[0][2]*16ll%mod)%mod+y.a[0][3]*8ll%mod)%mod+y.a[0][4]*4ll%mod)%mod+y.a[0][5]*2ll%mod)%mod+y.a[0][6])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[湘潭大学2018程序设计竞赛G]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%B9%98%E6%BD%AD%E5%A4%A7%E5%AD%A62018%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9BG%2F</url>
    <content type="text"><![CDATA[湘潭大学2018程序设计竞赛Ghttps://www.nowcoder.com/acm/contest/105/G 给一个递推式，$F_i=F_{i-1}+F_{i-2}+i^3+i^2+i+1。F_1=1,F_0=0$。问$F_n$是多少。典型的用矩阵快速幂加速解决斐波那契递推式。$F_{i+1}=F_i+F_{i-1}+(i+1)^3+(i+1)^2+(i+1)+1=F_i+F_{i-1}+i^3+4 \times i^2+6 \times i+4$。构造一个$6$阶矩阵即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll mod = 1e9+7ll; int _;ll n;struct mat&#123; ll a[7][7]; mat()&#123; memset(a,0,sizeof(a)); &#125; void init()&#123; for(int i=0;i&lt;6;i++) a[i][i]=1; &#125; mat operator * (const mat&amp; t)const&#123; mat tmp; for(int i=0;i&lt;6;i++) for(int j=0;j&lt;6;j++) for(int k=0;k&lt;6;k++) tmp.a[i][j]=(tmp.a[i][j]+a[i][k]*t.a[k][j]%mod)%mod; return tmp; &#125;&#125;;mat matrix_pow(mat x,ll k)&#123; mat ans,res;res=x; ans.init(); while(k)&#123; if(k&amp;1) ans=ans*res; res=res*res; k&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; mat x; x.a[0][0]=x.a[0][1]=x.a[0][2]=1ll;x.a[0][3]=x.a[0][5]=4ll;x.a[0][4]=6ll; x.a[1][0]=1ll; x.a[2][2]=x.a[2][5]=1ll;x.a[2][3]=x.a[2][4]=3ll; x.a[3][3]=x.a[3][5]=1ll;x.a[3][4]=2ll; x.a[4][4]=x.a[4][5]=1ll; x.a[5][5]=1ll; scanf("%d",&amp;_); while(_--)&#123; scanf("%lld",&amp;n); mat y=matrix_pow(x,n-1ll); printf("%lld\n",((((y.a[0][0]+y.a[0][2])%mod+y.a[0][3])%mod+y.a[0][4])%mod+y.a[0][5])%mod); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>matrix_pow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Tsukuba H]]></title>
    <url>%2F2019%2F03%2F29%2F2017Tsukuba-H%2F</url>
    <content type="text"><![CDATA[2017Tsukuba Hhttps://vjudge.net/contest/259596#problem/G 有个人有两个课程，每个课程有很多个作业，每个作业有开始日期与截至日期。每天只能选择一个课程的一个作业做。问这个人最多与最少可以完成多少作业。最多的话贪心的去找到每天可以做的所有作业中截止日期最近的那个即可。最少的话将日期拆点表示日期只能用一次，一种作业与源点连接容量为 $1$，然后与日期一边 $[start,deadline]$ 连接容量为 $1$。另一种作业与汇点连接容量为 $1$，然后与日期另一边 $[start,deadline]$ 连接容量为 $1$。因为当日期只与一个种类作业连接或者没有作业连接时这一天都可以没作业做。相当于寻找一个最小的割集让图不连通也就是所有日期都最多只有一个种类的作业连接，找不到作业去做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn=2010,inf=0x3f3f3f3f;int n,m,st[407],ed[407],st1[407],ed1[407],ans,ans1;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;vector&lt;int&gt; s[407],s1[407];void init()&#123; while(!q.empty()) q.pop();ans=0;ans1=0; for(int i=1;i&lt;=401;i++) s[i].clear(),s1[i].clear();&#125;struct Dinic&#123; struct edge &#123; int from,to,cap,flow; &#125;; vector&lt;edge&gt;es; vector&lt;int&gt;G[maxn]; bool vis[maxn]; int dist[maxn]; int iter[maxn]; void init(int n)&#123; for(int i=0; i&lt;=n+10; i++) G[i].clear(); es.clear(); &#125; void addedge(int from,int to,int cap)&#123; es.push_back((edge)&#123; from,to,cap,0 &#125;); es.push_back((edge)&#123; to,from,0,0 &#125;); int x=es.size(); G[from].push_back(x-2); G[to].push_back(x-1); &#125; bool BFS(int s,int t)&#123; memset(vis,0,sizeof(vis)); queue &lt;int&gt; Q; vis[s]=1; dist[s]=0; Q.push(s); while(!Q.empty())&#123; int u=Q.front(); Q.pop(); for(int i=0; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(!vis[e.to]&amp;&amp;e.cap&gt;e.flow) &#123; vis[e.to]=1; dist[e.to]=dist[u]+1; Q.push(e.to); &#125; &#125; &#125; return vis[t]; &#125; int DFS(int u,int t,int f)&#123; if(u==t||f==0) return f; int flow=0,d; for(int &amp;i=iter[u]; i&lt;G[u].size(); i++)&#123; edge &amp;e=es[G[u][i]]; if(dist[u]+1==dist[e.to]&amp;&amp;(d=DFS(e.to,t,min(f,e.cap-e.flow)))&gt;0)&#123; e.flow+=d; es[G[u][i]^1].flow-=d; flow+=d; f-=d; if(f==0) break; &#125; &#125; return flow; &#125; int Maxflow(int s,int t)&#123; int flow=0; while(BFS(s,t)) &#123; memset(iter,0,sizeof(iter)); int d=0; while(d=DFS(s,t,inf)) flow+=d; &#125; return flow; &#125;&#125;dinic;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;m))&#123; init();dinic.init(1000+n); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;st[i],&amp;ed[i]); s[st[i]].push_back(ed[i]); &#125; for(int i=1;i&lt;=n-m;i++)&#123; scanf("%d%d",&amp;st1[i],&amp;ed1[i]); s1[st1[i]].push_back(ed1[i]); &#125; for(int i=1;i&lt;=400;i++)&#123; for(int j=0;j&lt;s[i].size();j++) q.push(s[i][j]); for(int j=0;j&lt;s1[i].size();j++) q.push(s1[i][j]); while(!q.empty())&#123; if(q.top()&lt;i) q.pop(); else&#123; q.pop(); ans++; break; &#125; &#125; &#125; printf("%d\n",ans); int s=0,t=800+n+1; for(int i=m+1;i&lt;=m+400;i++)&#123; dinic.addedge(i,i+400,1); &#125; for(int i=1;i&lt;=m;i++)&#123; dinic.addedge(s,i,1); for(int j=st[i];j&lt;=ed[i];j++) dinic.addedge(i,m+j,1); &#125; for(int i=1;i&lt;=n-m;i++)&#123; dinic.addedge(m+800+i,t,1); for(int j=st1[i];j&lt;=ed1[i];j++) dinic.addedge(m+400+j,m+800+i,1); &#125; printf("%d\n",dinic.Maxflow(s,t)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017Daejeon E]]></title>
    <url>%2F2019%2F03%2F29%2F2017Daejeon-E%2F</url>
    <content type="text"><![CDATA[2017Daejeon E给出一个有 $n$ 个点 $m$ 条边的图，每条边有一个边权。问要使第 $i$ 条边成为图的最小生成树的一条边最少要删掉多少条边，求出每条边的对应答案的和。枚举边 $i$ ，找出那些边权小于 $i$ 的边权的边，这些边都是网络流里的边，然后以连接 $i$ 的两个点为源点和汇点跑网络流求最小割。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000;const int MAXM = 4000;const int inf = 0x3f3f3f3f;struct edge&#123; int to,next,cap,flow;&#125;e[MAXM];int n,m;int tol;int head[MAXN];int gap[MAXN],dep[MAXN],pre[MAXN],cur[MAXN];void init()&#123; tol=0;memset(head,-1,sizeof(head));&#125;void addedge(int u,int v,int w,int rw=0)&#123; e[tol].to=v;e[tol].cap=w;e[tol].next=head[u]; e[tol].flow=0;head[u]=tol++; e[tol].to=u;e[tol].cap=rw;e[tol].next=head[v]; e[tol].flow=0;head[v]=tol++;&#125;int sap(int st,int ed,int N)&#123; memset(gap,0,sizeof(gap)); memset(dep,0,sizeof(dep)); memcpy(cur,head,sizeof(head)); int u=st; pre[u]=-1; gap[0]=N; int ans=0; while(dep[st]&lt;N)&#123; if(u==ed)&#123; int Min=inf; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; if(Min&gt;e[i].cap-e[i].flow) Min=e[i].cap-e[i].flow; &#125; for(int i=pre[u];~i;i=pre[e[i^1].to])&#123; e[i].flow+=Min; e[i^1].flow-=Min; &#125; u=st; ans+=Min; continue; &#125; bool flag=false; int v; for(int i=cur[u];~i;i=e[i].next)&#123; v=e[i].to; if(e[i].cap-e[i].flow&amp;&amp;dep[v]+1==dep[u])&#123; flag=true; cur[u]=pre[v]=i; break; &#125; &#125; if(flag)&#123; u=v; continue; &#125; int Min=N; for(int i=head[u];~i;i=e[i].next)&#123; if(e[i].cap-e[i].flow&amp;&amp;dep[e[i].to]&lt;Min)&#123; Min=dep[e[i].to]; cur[u]=i; &#125; &#125; gap[dep[u]]--; if(!gap[dep[u]]) return ans; dep[u]=Min+1; gap[dep[u]]++; if(u!=st) u=e[pre[u]^1].to; &#125; return ans;&#125;struct E&#123; int u,v,w,fl; bool operator &lt; (const E &amp;k) const&#123; return w&lt;k.w; &#125;&#125;ee[1000];int tot=0;void solve()&#123; int ans=0; for(int i=1;i&lt;=tot;i++)&#123; init(); for(int j=1;j&lt;i;j++)&#123; if(ee[j].w&lt;ee[i].w)&#123; addedge(ee[j].u,ee[j].v,1); addedge(ee[j].v,ee[j].u,1); &#125; &#125; ans+=sap(ee[i].u,ee[i].v,n); &#125; printf("%d\n",ans);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); ee[++tot].u=u;ee[tot].v=v;ee[tot].w=w;ee[tot].fl=0; &#125; sort(ee+1,ee+tot+1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>network_flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017LatinAme F]]></title>
    <url>%2F2019%2F03%2F29%2F2017LatinAme-F%2F</url>
    <content type="text"><![CDATA[2017LatinAme F Fundraisinghttps://vjudge.net/contest/259114#problem/F n个人有漂亮值、财富值以及钱财三个属性。当一个人的漂亮值比另一个人严格大，且财富值比那个人小的时候，这两个人会发生争吵。问怎样选择一个集合，使得集合里的人互不争吵且钱财之和最大。先将相同漂亮值财富值的人合并然后将人按照漂亮值排序。然后遍历所有的人找到财富值比它小的钱财最大的状态然后加上那个状态更新当前财富值。注意同样的漂亮值的人互不影响。最后看所有的财富值中最大的即是答案。注意离散化财富值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int M = 1e5+7;struct node&#123; int b,f;ll d; node () &#123;&#125; node (int b1,int f1,ll d1)&#123; b=b1;f=f1;d=d1; &#125; bool operator &lt; (const node &amp; k)const &#123; if(b!=k.b) return b&lt;k.b; return f&lt;k.f; &#125;&#125;p[M];map&lt;node,ll&gt; mp;int n,tot,f[M];struct Seg&#123; ll mx[M&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; mx[rt]=max(mx[l],mx[r]); &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; mx[rt]=0; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll v)&#123; if(l==r)&#123; if(v&gt;mx[rt]) mx[rt]=v; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,v); else update(pos,rson,v); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return mx[rt]; &#125; int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res=max(res,query(L,R,lson)); if(R&gt;mid) res=max(res,query(L,R,rson)); return res; &#125;&#125;seg;vector&lt;pair&lt;int,ll&gt; &gt; vec;int main()&#123; freopen("1.in","r",stdin); freopen("1.out","w",stdout); while(~scanf("%d",&amp;n))&#123; mp.clear();tot=0;vec.clear(); for(int i=1;i&lt;=n;i++)&#123; int x,y;ll z; scanf("%d%d%lld",&amp;x,&amp;y,&amp;z); mp[node(x,y,0)]+=z; &#125; for(map&lt;node,ll&gt;::iterator it=mp.begin();it!=mp.end();it++)&#123; p[++tot].b=it-&gt;first.b;p[tot].f=it-&gt;first.f;p[tot].d=it-&gt;second; f[tot]=p[tot].f; &#125; sort(p+1,p+tot+1);int pre=0; sort(f+1,f+tot+1); int sz=unique(f+1,f+tot+1)-f-1; seg.build(0,sz,1); for(int i=1;i&lt;=tot;i++)&#123; if(p[i].b!=pre)&#123; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,0,sz,1,vec[i].second); &#125; vec.clear(); int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); pre=p[i].b; &#125; else&#123; int pos=lower_bound(f+1,f+sz+1,p[i].f)-f; vec.push_back(make_pair(pos,p[i].d+seg.query(0,pos-1,0,sz,1))); &#125; &#125; for(int i=0;i&lt;vec.size();i++)&#123; seg.update(vec[i].first,1,sz,1,vec[i].second); &#125; printf("%lld\n",seg.mx[1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LYOI 2016 41]]></title>
    <url>%2F2019%2F03%2F29%2FLYOI2016-41%2F</url>
    <content type="text"><![CDATA[LYOI2016_41 一次函数https://lyoi.ac/problem/41 $n$ 个一次函数 $f_i(x) = k_i \times x + b_i$,有两个操作。第一个操作把指定一个二次函数的 $k$ 和 $b$ 改变。第二个操作给出区间 $[l,r]$ 以及 $x$ , 求 $f_r(f_{r-1}(…f_l(x)))$ 的值。根据推算得出对于一个区间的两个子区间 $l$ 与 $r$ ,$k_{rt} = k_l \times k_r$, $b_{rt} = k_r \times b_l + b_r$ 。用线段树维护 $k$ 与 $b$ ,询问的时候合并区间即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;const int M = 2e5+7;typedef long long ll;const ll mod = 1e9+7;int n,q;ll a[M],c[M];char s[2];int ql,qr,qpos,tot;ll qx,qk,qb;struct Seg&#123; ll k[M&lt;&lt;3],b[M&lt;&lt;3]; void pushup(int rt,int l,int r)&#123; k[rt]=k[l]*k[r]%mod; b[rt]=(b[l]*k[r]%mod+b[r])%mod; &#125; void build(int l,int r,int rt)&#123; if(l==r)&#123; k[rt]=a[l],b[rt]=c[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int pos,int l,int r,int rt,ll a,ll c)&#123; if(l==r)&#123; k[rt]=a,b[rt]=c; return ; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(pos,lson,a,c); else update(pos,rson,a,c); pushup(up); &#125; int query(int L,int R,int l,int r,int rt)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; return rt; &#125; int mid=(l+r)&gt;&gt;1,ll,rr,res; if(L&gt;mid)&#123; res=query(L,R,rson); return res; &#125; else if(R&lt;=mid)&#123; res=query(L,R,lson); return res; &#125; else&#123; ll=query(L,R,lson),rr=query(L,R,rson); pushup(++tot,ll,rr); return tot; &#125; &#125;&#125;seg;void solve()&#123; while(q--)&#123; scanf("%s",s); if(s[0]=='Q')&#123; tot=(M&lt;&lt;2)+1; scanf("%d%d%lld",&amp;ql,&amp;qr,&amp;qx); tot=seg.query(ql,qr,1,n,1); printf("%lld\n",(seg.k[tot]*qx%mod+seg.b[tot])%mod); &#125; else&#123; scanf("%d%lld%lld",&amp;qpos,&amp;qk,&amp;qb); seg.update(qpos,1,n,1,qk,qb); &#125; &#125;&#125;int main()&#123; // freopen("1.in","r",stdin); // freopen("1.out","w",stdout); while(~scanf("%d%d",&amp;n,&amp;q))&#123; for(int i=1;i&lt;=n;i++) scanf("%lld%lld",&amp;a[i],&amp;c[i]); seg.build(1,n,1); solve(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nowcoder practice28 B]]></title>
    <url>%2F2019%2F03%2F29%2FNowcoder-practice28-B%2F</url>
    <content type="text"><![CDATA[Nowcoder_practice28_B 数据结构https://www.nowcoder.com/acm/contest/200/B $n$ 个数 $m$ 个操作。$1.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}$。$2.$ 给出 $l$ 与 $r$ 求 $\sum_{l}^{r}a_{i}^{2}$。$3.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $\times x$。$4.$ 给出 $l 、r、x$ 对于区间 $l、r$ 中的所有数 $+ x$。线段树模板题，维护一个加 $lazy$ 与一个乘 $lazy$ ,再维护两个答案即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#define lson l,mid,rt&lt;&lt;1#define rson mid+1,r,rt&lt;&lt;1|1#define up rt,rt&lt;&lt;1,rt&lt;&lt;1|1using namespace std;typedef long long ll;const int Nmax = 1e4+7;int n,q;ll a[Nmax];struct Seg&#123; ll sum[Nmax&lt;&lt;2],fsum[Nmax&lt;&lt;2],len[Nmax&lt;&lt;2],lazyadd[Nmax&lt;&lt;2],lazymul[Nmax&lt;&lt;2]; void pushup(int rt,int l,int r)&#123; sum[rt]=sum[l]+sum[r]; fsum[rt]=fsum[l]+fsum[r]; &#125; void pushdown(int rt,int l,int r)&#123; if(lazymul[rt]!=1)&#123; ll v=lazymul[rt]; lazymul[rt]=1; sum[l]*=v;sum[r]*=v; fsum[l]*=(v*v);fsum[r]*=(v*v); lazymul[l]*=v;lazymul[r]*=v; lazyadd[l]*=v;lazyadd[r]*=v; &#125; if(lazyadd[rt])&#123; ll v=lazyadd[rt]; lazyadd[rt]=0; fsum[r]+=(2*sum[r]*v+v*v*len[r]);fsum[l]+=(2*sum[l]*v+v*v*len[l]); sum[r]+=(v*len[r]);sum[l]+=(v*len[l]); lazyadd[r]+=v;lazyadd[l]+=v; &#125; &#125; void build(int l,int r,int rt)&#123; sum[rt]=fsum[rt]=0;len[rt]=(ll)(r-l+1);lazyadd[rt]=0;lazymul[rt]=1; if(l==r)&#123; sum[rt]=a[l];fsum[rt]=a[l]*a[l]; return ; &#125; int mid=(l+r)&gt;&gt;1; build(lson); build(rson); pushup(up); &#125; void update(int L,int R,int l,int r,int rt,ll v,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==2)&#123; fsum[rt]+=(2*sum[rt]*v+v*v*len[rt]); sum[rt]+=(len[rt]*v); lazyadd[rt]+=v; &#125; else&#123; sum[rt]*=v;fsum[rt]*=(v*v); lazyadd[rt]*=v;lazymul[rt]*=v; &#125; return ; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) update(L,R,lson,v,op); if(R&gt;mid) update(L,R,rson,v,op); pushup(up); &#125; ll query(int L,int R,int l,int r,int rt,int op)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(op==1) return sum[rt]; else return fsum[rt]; &#125; pushdown(up); int mid=(l+r)&gt;&gt;1;ll res=0; if(L&lt;=mid) res+=query(L,R,lson,op); if(R&gt;mid) res+=query(L,R,rson,op); return res; &#125;&#125;seg;void solve()&#123; while(q--)&#123; int op,l,r;ll v; scanf("%d",&amp;op); if(op==1||op==2)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%lld\n",seg.query(l,r,1,n,1,op)); &#125; else&#123; scanf("%d%d%lld",&amp;l,&amp;r,&amp;v); seg.update(l,r,1,n,1,v,op-2); &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;q); for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a[i]); seg.build(1,n,1); solve(); return 0;&#125;]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>segment-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题合集]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[codeforces 1051Fhttp://codeforces.com/contest/1051/problem/F 给一副图，图中的边最多比点多 $20$ 条。给 $q$ 次询问，每次询问两点的最短路。随便弄一个生成树，然后求出两点在树上的距离。把非树边的两端点保存然后求分别求一次最短路。然后以所有非树边端点的最短距离更新即可。 wannafly_day1_Jhttp://newoj.acmclub.cn/contests/1389/problem/9 改成了边比点多100条，不过所有边的距离都是1，把非树边抽出来跑一下bfs求互相的最短距离。和cf1051F差不多。 wannafly_day3_Ihttps://www.nowcoder.com/acm/contest/203/I 多源最短路。在一幅无向图中给出点集，问点集中的每个点到其他点的最短距离是多少。把点集里的点都做为源点，每个点都再增加一个祖先属性，表示这个点被哪个源点的最短路所更新。然后跑一次多源最短路即可。 2017Tsukuba_Fhttps://vjudge.net/contest/259357#problem/F 问一幅有向图中每条边如果反向会让图中点1到点2的最短距离变大变小还是不变。先求出点1到各个点的最短距离与边反向之后点2到各个点的最短距离。如果变小的话就是 $dis_{1to} + dis_{2from} + w &lt; dis$ 。变大的话就是上述等式变成大于符号，但因为最短路可能有多条，所以只有这条边还是最短路无向图里的桥时才会让最短距离变大。上述两个情况都不满足的话，最短距离不变。 codeforces 1076Dhttp://codeforces.com/contest/1076/problem/D 最短路生成树$+dfs$给 $n$ 个点 $m$ 条边，找出一个边集不超过 $k$ 条边使得距离节点 $1$ 的距离是最短距离的点最多，输出这个边集首先将 $1$ 节点跑最短路建出最短路生成树，然后再在生成树上 $dfs$ 出一个 $k$ 条边的边集 2018SEERC Chttp://codeforces.com/gym/101964/problem/C 给出一棵树，这棵树由黑白点组成。选出一个黑点点集，点集中点数小于给定的k，找出所有可能的黑点点集里直径最小的那个并输出直径。考虑枚举所有的黑点点对，求出点对的距离，当有黑点满足离点对两点距离都小于等于点对距离时就可以将点加入。数形结合，可以理解为这些点在两个圆的相交部分，所以最大距离必是点对距离。]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>MST</tag>
        <tag>bfs</tag>
        <tag>dijkstra</tag>
        <tag>spfa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git+hexo搭建]]></title>
    <url>%2F2019%2F03%2F29%2Fgit-hexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建所需环境首先需要 $git+node.js$。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
